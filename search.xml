<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS3滤镜filter</title>
    <url>/2020/02/10/15/17/CSS3%E6%BB%A4%E9%95%9Cfilter/</url>
    <content><![CDATA[<p>网页图片的色彩处理<a id="more"></a></p>
<h6 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h6><table>
<thead>
<tr>
<th align="center">none</th>
<th>默认值，没有效果。</th>
</tr>
</thead>
<tbody><tr>
<td align="center">blur(<em>px</em>)</td>
<td>给图像设置高斯模糊。”radius”一值设定高斯函数的标准差，或者是屏幕上以多少像素融在一起， 所以值越大越模糊；  如果没有设定值，则默认是0；这个参数可设置css长度值，但不接受百分比值。</td>
</tr>
<tr>
<td align="center">brightness(<em>%</em>)</td>
<td>给图片应用一种线性乘法，使其看起来更亮或更暗。如果值是0%，图像会全黑。值是100%，则图像无变化。其他的值对应线性乘数效果。值超过100%也是可以的，图像会比原来更亮。如果没有设定值，默认是1。</td>
</tr>
<tr>
<td align="center">contrast(<em>%</em>)</td>
<td>调整图像的对比度。值是0%的话，图像会全黑。值是100%，图像不变。值可以超过100%，意味着会运用更低的对比。若没有设置值，默认是1。</td>
</tr>
<tr>
<td align="center">drop-shadow(<em>h-shadow v-shadow blur spread color</em>)</td>
<td>给图像设置一个阴影效果。阴影是合成在图像下面，可以有模糊度的，可以以特定颜色画出的遮罩图的偏移版本。 函数接受<shadow>(在CSS3背景中定义)类型的值，除了”inset”关键字是不允许的。该函数与已有的box-shadow box-shadow属性很相似；不同之处在于，通过滤镜，一些浏览器为了更好的性能会提供硬件加速。参数如下：<offset-x><offset-y>(必须)这是设置阴影偏移量的两个 值. <offset-x> 设定水平方向距离. 负值会使阴影出现在元素左边. <offset-y>设定垂直距离.负值会使阴影出现在元素上方。查看<length>可能的单位.<strong>如果两个值都是0</strong>, 则阴影出现在元素正后面 (如果设置了 and/or ，会有模糊效果).<blur-radius> (可选)这是第三个code&gt;值. 值越大，越模糊，则阴影会变得更大更淡.不允许负值 若未设定，默认是0 (则阴影的边界很锐利).<spread-radius>(可选)这是第四个 值. 正值会使阴影扩张和变大，负值会是阴影缩小.若未设定，默认是0 (阴影会与元素一样大小). 注意: Webkit, 以及一些其他浏览器 不支持第四个长度，如果加了也不会渲染。 <color> (可选)查看 该值可能的关键字和标记。若未设定，颜色值基于浏览器。在Gecko (Firefox), Presto (Opera)和Trident (Internet Explorer)中， 会应用color<strong>color</strong>属性的值。另外, 如果颜色值省略，WebKit中阴影是透明的。</color></spread-radius></blur-radius></length></offset-y></offset-x></offset-y></offset-x></shadow></td>
</tr>
<tr>
<td align="center">grayscale(<em>%</em>)</td>
<td>将图像转换为灰度图像。值定义转换的比例。值为100%则完全转为灰度图像，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0；</td>
</tr>
<tr>
<td align="center">hue-rotate(<em>deg</em>)</td>
<td>给图像应用色相旋转。”angle”一值设定图像会被调整的色环角度值。值为0deg，则图像无变化。若值未设置，默认值是0deg。该值虽然没有最大值，超过360deg的值相当于又绕一圈。</td>
</tr>
<tr>
<td align="center">invert(<em>%</em>)</td>
<td>反转输入图像。值定义转换的比例。100%的价值是完全反转。值为0%则图像无变化。值在0%和100%之间，则是效果的线性乘子。 若值未设置，值默认是0。</td>
</tr>
<tr>
<td align="center">opacity(<em>%</em>)</td>
<td>转化图像的透明程度。值定义转换的比例。值为0%则是完全透明，值为100%则图像无变化。值在0%和100%之间，则是效果的线性乘子，也相当于图像样本乘以数量。 若值未设置，值默认是1。该函数与已有的opacity属性很相似，不同之处在于通过filter，一些浏览器为了提升性能会提供硬件加速。</td>
</tr>
<tr>
<td align="center">saturate(<em>%</em>)</td>
<td>转换图像饱和度。值定义转换的比例。值为0%则是完全不饱和，值为100%则图像无变化。其他值，则是效果的线性乘子。超过100%的值是允许的，则有更高的饱和度。 若值未设置，值默认是1。</td>
</tr>
<tr>
<td align="center">sepia(<em>%</em>)</td>
<td>将图像转换为深褐色。值定义转换的比例。值为100%则完全是深褐色的，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0；</td>
</tr>
<tr>
<td align="center">url()</td>
<td>URL函数接受一个XML文件，该文件设置了 一个SVG滤镜，且可以包含一个锚点来指定一个具体的滤镜元素。例如：<code>filter: url(svg-url#element-id)</code></td>
</tr>
<tr>
<td align="center">initial</td>
<td>设置属性为默认值</td>
</tr>
<tr>
<td align="center">inherit</td>
<td>从父元素继承该属性</td>
</tr>
</tbody></table>
<h6 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h6><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">img &#123;</span><br><span class="line">    width: 33%;</span><br><span class="line">    height: auto;</span><br><span class="line">    float: left; </span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="comment">/*模糊*/</span></span></span><br><span class="line"><span class="css"><span class="selector-class">.blur</span> &#123;<span class="attribute">-webkit-filter</span>: <span class="built_in">blur</span>(<span class="number">4px</span>);<span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="number">4px</span>);&#125;</span></span><br><span class="line"><span class="css"><span class="comment">/*亮度*/</span></span></span><br><span class="line"><span class="css"><span class="selector-class">.brightness</span> &#123;<span class="attribute">-webkit-filter</span>: <span class="built_in">brightness</span>(<span class="number">0.30</span>);<span class="attribute">filter</span>: <span class="built_in">brightness</span>(<span class="number">0.30</span>);&#125;</span></span><br><span class="line"><span class="css"><span class="comment">/*对比度*/</span></span></span><br><span class="line"><span class="css"><span class="selector-class">.contrast</span> &#123;<span class="attribute">-webkit-filter</span>: <span class="built_in">contrast</span>(<span class="number">180%</span>);<span class="attribute">filter</span>: <span class="built_in">contrast</span>(<span class="number">180%</span>);&#125;</span></span><br><span class="line"><span class="css"><span class="comment">/*灰度*/</span></span></span><br><span class="line"><span class="css"><span class="selector-class">.grayscale</span> &#123;<span class="attribute">-webkit-filter</span>: <span class="built_in">grayscale</span>(<span class="number">100%</span>);<span class="attribute">filter</span>: <span class="built_in">grayscale</span>(<span class="number">100%</span>);&#125;</span></span><br><span class="line"><span class="css"><span class="comment">/*色相旋转*/</span></span></span><br><span class="line"><span class="css"><span class="selector-class">.huerotate</span> &#123;<span class="attribute">-webkit-filter</span>: <span class="built_in">hue-rotate</span>(<span class="number">180deg</span>);<span class="attribute">filter</span>: <span class="built_in">hue-rotate</span>(<span class="number">180deg</span>);&#125;</span></span><br><span class="line"><span class="css"><span class="comment">/*反色*/</span></span></span><br><span class="line"><span class="css"><span class="selector-class">.invert</span> &#123;<span class="attribute">-webkit-filter</span>: <span class="built_in">invert</span>(<span class="number">100%</span>);<span class="attribute">filter</span>: <span class="built_in">invert</span>(<span class="number">100%</span>);&#125;</span></span><br><span class="line"><span class="css"><span class="comment">/*透明度*/</span></span></span><br><span class="line"><span class="css"><span class="selector-class">.opacity</span> &#123;<span class="attribute">-webkit-filter</span>: <span class="built_in">opacity</span>(<span class="number">50%</span>);<span class="attribute">filter</span>: <span class="built_in">opacity</span>(<span class="number">50%</span>);&#125;</span></span><br><span class="line"><span class="css"><span class="comment">/*饱和度*/</span></span></span><br><span class="line"><span class="css"><span class="selector-class">.saturate</span> &#123;<span class="attribute">-webkit-filter</span>: <span class="built_in">saturate</span>(<span class="number">7</span>); <span class="attribute">filter</span>: <span class="built_in">saturate</span>(<span class="number">7</span>);&#125;</span></span><br><span class="line"><span class="css"><span class="comment">/*深褐色*/</span></span></span><br><span class="line"><span class="css"><span class="selector-class">.sepia</span> &#123;<span class="attribute">-webkit-filter</span>: <span class="built_in">sepia</span>(<span class="number">100%</span>);<span class="attribute">filter</span>: <span class="built_in">sepia</span>(<span class="number">100%</span>);&#125;</span></span><br><span class="line"><span class="css"><span class="comment">/*阴影*/</span></span></span><br><span class="line"><span class="css"><span class="selector-class">.shadow</span> &#123;<span class="attribute">-webkit-filter</span>: <span class="built_in">drop-shadow</span>(<span class="number">8px</span> <span class="number">8px</span> <span class="number">10px</span> green);<span class="attribute">filter</span>: <span class="built_in">drop-shadow</span>(<span class="number">8px</span> <span class="number">8px</span> <span class="number">10px</span> green);&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>注意：<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> Internet Explorer 不支持 filter 属性。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;pineapple.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Pineapple&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;blur&quot;</span> <span class="attr">src</span>=<span class="string">&quot;pineapple.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Pineapple&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;brightness&quot;</span> <span class="attr">src</span>=<span class="string">&quot;pineapple.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Pineapple&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;contrast&quot;</span> <span class="attr">src</span>=<span class="string">&quot;pineapple.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Pineapple&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;grayscale&quot;</span> <span class="attr">src</span>=<span class="string">&quot;pineapple.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Pineapple&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;huerotate&quot;</span> <span class="attr">src</span>=<span class="string">&quot;pineapple.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Pineapple&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;invert&quot;</span> <span class="attr">src</span>=<span class="string">&quot;pineapple.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Pineapple&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;opacity&quot;</span> <span class="attr">src</span>=<span class="string">&quot;pineapple.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Pineapple&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;saturate&quot;</span> <span class="attr">src</span>=<span class="string">&quot;pineapple.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Pineapple&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;sepia&quot;</span> <span class="attr">src</span>=<span class="string">&quot;pineapple.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Pineapple&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;shadow&quot;</span> <span class="attr">src</span>=<span class="string">&quot;pineapple.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Pineapple&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker容器</title>
    <url>/2020/05/13/11/30/Docker%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>Docker容器的简单了解，以CentOS系统为基础。<a id="more"></a></p>
<h5 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h5><p><strong>镜像(Image)：</strong>Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</p>
<p><strong>容器(Container)：</strong>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p><strong>仓库(Repository)：</strong>仓库可看着一个代码控制中心，用来保存镜像。</p>
<p>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。</p>
<p>Docker 容器通过 Docker 镜像来创建。</p>
<p><img src="/2020/05/13/11/30/Docker%E5%AE%B9%E5%99%A8/docker.png" alt></p>
<table>
<thead>
<tr>
<th align="center">概念</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Docker 镜像(Images)</td>
<td align="center">Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。</td>
</tr>
<tr>
<td align="center">Docker 容器(Container)</td>
<td align="center">容器是独立运行的一个或一组应用，是镜像运行时的实体。</td>
</tr>
<tr>
<td align="center">Docker 客户端(Client)</td>
<td align="center">Docker 客户端通过命令行或者其他工具使用 Docker SDK 与 Docker 的守护进程通信。</td>
</tr>
<tr>
<td align="center">Docker 主机(Host)</td>
<td align="center">一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td>
</tr>
<tr>
<td align="center">Docker Registry</td>
<td align="center">Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <strong>latest</strong> 作为默认标签。</td>
</tr>
<tr>
<td align="center">Docker Machine</td>
<td align="center">Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。</td>
</tr>
</tbody></table>
<h5 id="Docker卸载旧版本"><a href="#Docker卸载旧版本" class="headerlink" title="Docker卸载旧版本"></a>Docker卸载旧版本</h5><p>必须切换成root才可以卸载旧版本，然后执行下列命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine</span><br></pre></td></tr></table></figure>

<h5 id="安装Docker-Engine-Community"><a href="#安装Docker-Engine-Community" class="headerlink" title="安装Docker Engine-Community"></a>安装Docker Engine-Community</h5><p>在安装之前，需要设置Docker仓库。之后可以进行安装和更新Docker。</p>
<h6 id="安装所需要的安装包"><a href="#安装所需要的安装包" class="headerlink" title="安装所需要的安装包"></a>安装所需要的安装包</h6><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">yum install -<span class="symbol">y</span> yum-utils device-mapper-<span class="symbol">persistent</span>-data lvm2</span><br></pre></td></tr></table></figure>

<h6 id="设置稳定的仓库"><a href="#设置稳定的仓库" class="headerlink" title="设置稳定的仓库"></a>设置稳定的仓库</h6><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo https:<span class="regexp">//</span>download.docker.com<span class="regexp">/linux/</span>centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<p>安装最新版本的 Docker Engine-Community 和 containerd，或者转到下一步安装特定版本如果没有安装成功，选择<code>--nobest</code>安装非最新版，以下类似。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">yum install docker-<span class="keyword">ce</span> docker-<span class="keyword">ce</span>-cli containerd.io</span><br></pre></td></tr></table></figure>

<p>Docker 安装完默认未启动。并且已经创建好 docker 用户组，但该用户组下没有用户。</p>
<p>列出并排序您存储库中可用的版本。此示例按版本号（从高到低）对结果进行排序。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">yum <span class="keyword">list</span> docker-<span class="keyword">ce</span> --showduplicates | <span class="keyword">sort</span> -r</span><br></pre></td></tr></table></figure>

<p>通过其完整的软件包名称安装特定版本，该软件包名称是软件包名称（docker-ce）加上版本字符串（第二列），从第一个冒号（:）一直到第一个连字符，并用连字符（-）分隔。例如：docker-ce-18.09.1。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">yum install docker-<span class="keyword">ce</span>-<span class="symbol">&lt;VERSION_STRING&gt;</span> docker-<span class="keyword">ce</span>-cli-<span class="symbol">&lt;VERSION_STRING&gt;</span> contain</span><br></pre></td></tr></table></figure>

<h6 id="启动Docker"><a href="#启动Docker" class="headerlink" title="启动Docker"></a>启动Docker</h6><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> docker</span><br></pre></td></tr></table></figure>

<p>通过运行 hello-world 映像来验证是否正确安装了 Docker Engine-Community 。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> hello-world</span></span><br></pre></td></tr></table></figure>

<h5 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h5><p>推荐使用阿里云容器镜像加速服务，地址：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors。按照文档要求修改`/etc/docker`目录下的`daemon.json`，修改为自己专属的地址。">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors。按照文档要求修改`/etc/docker`目录下的`daemon.json`，修改为自己专属的地址。</a></p>
<h5 id="Docker容器使用"><a href="#Docker容器使用" class="headerlink" title="Docker容器使用"></a>Docker容器使用</h5><h6 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h6><p>如果我们本地没有 ubuntu 镜像，我们可以使用 docker pull 命令来载入 ubuntu 镜像：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker pull ubuntu</span></span><br></pre></td></tr></table></figure>

<h6 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h6><p>以下命令使用 ubuntu 镜像启动一个容器，参数为以命令行模式进入该容器：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">run</span> -<span class="keyword">it</span> ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><strong>-i</strong>: 交互式操作。</li>
<li><strong>-t</strong>: 终端。</li>
<li><strong>ubuntu</strong>: ubuntu 镜像。</li>
<li><strong>/bin/bash</strong>：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。</li>
</ul>
<p>要退出终端，直接输入 <strong>exit</strong>:</p>
<h6 id="启动已停止运行的容器"><a href="#启动已停止运行的容器" class="headerlink" title="启动已停止运行的容器"></a>启动已停止运行的容器</h6><p>查看所有的容器命令</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker ps -a</span></span><br></pre></td></tr></table></figure>

<p>启动一个已停止的容器</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">start</span> 容器<span class="keyword">ID</span></span><br></pre></td></tr></table></figure>

<h6 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h6><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">run</span> -itd <span class="comment">--name ubuntu-test ubuntu /bin/bash</span></span><br></pre></td></tr></table></figure>

<p>使用<code>-d</code>参数，容器启动后会进入后台，默认不会进入容器，想要进入容器需要使用指令<code>docker exec</code>。</p>
<h6 id="停止一个容器"><a href="#停止一个容器" class="headerlink" title="停止一个容器"></a>停止一个容器</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">stop</span> 容器<span class="keyword">ID</span></span><br></pre></td></tr></table></figure>

<p>停止的容器重启</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">restart</span> 容器ID</span><br></pre></td></tr></table></figure>

<h6 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h6><ul>
<li><p>docker attach：从此容器中退出，会导致容器的停止。</p>
</li>
<li><p>docker exec：使用此命令，退出容器终端，不会导致容器的停止。</p>
</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">attach</span> 容器ID</span><br></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器ID <span class="regexp">/bin/</span>bash</span><br></pre></td></tr></table></figure>

<h6 id="导入和导出容器"><a href="#导入和导出容器" class="headerlink" title="导入和导出容器"></a>导入和导出容器</h6><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="title">docker</span> ex<span class="keyword">port</span> 容器ID &gt; ubuntu.tar</span><br></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cat docker<span class="regexp">/ubuntu.tar | docker import - test/u</span>buntu:v1</span><br></pre></td></tr></table></figure>

<p>ubuntu.tar为导出文件，test/ubuntu:v1为镜像。</p>
<h6 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h6><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> <span class="operator">-f</span> 容器ID</span><br><span class="line"><span class="comment"># 清除掉所有处于终止状态的容器</span></span><br><span class="line">docker container prune</span><br></pre></td></tr></table></figure>

<h6 id="运行一个web应用"><a href="#运行一个web应用" class="headerlink" title="运行一个web应用"></a>运行一个web应用</h6><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 载入镜像</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">pull training/webapp</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">run -d -P training/webapp python app.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看进程</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">top 容器名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#检查应用</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">inspect 容器名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#停止web应用容器</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">stop 容器名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#移除web应用容器，删除时容器必须停止，否则会报错</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">rm</span></span><br></pre></td></tr></table></figure>

<p><code>-P</code>将容器内部使用的网络端口映射到我们使用的主机上。</p>
<p><code>-p</code>设置端口，可以指定映射的端口号<code>8080:8080</code></p>
<h6 id="查看web应用程序日志"><a href="#查看web应用程序日志" class="headerlink" title="查看web应用程序日志"></a>查看web应用程序日志</h6><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span> logs -f 容器ID</span><br></pre></td></tr></table></figure>

<p><code>-f</code>：让<code>docker logs</code>像使用<code>tail -f</code>一样来输出容器内部的标准输出，</p>
<h5 id="Docker镜像使用"><a href="#Docker镜像使用" class="headerlink" title="Docker镜像使用"></a>Docker镜像使用</h5><h6 id="镜像列表"><a href="#镜像列表" class="headerlink" title="镜像列表"></a>镜像列表</h6><p><code>docker images</code>可以列出本地主机上的镜像。</p>
<p>各个选项说明:</p>
<ul>
<li><strong>REPOSITORY：</strong>表示镜像的仓库源</li>
<li><strong>TAG：</strong>镜像的标签</li>
<li><strong>IMAGE ID：</strong>镜像ID</li>
<li><strong>CREATED：</strong>镜像创建时间</li>
<li><strong>SIZE：</strong>镜像大小</li>
</ul>
<p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</p>
<h6 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h6><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">search</span> 镜像仓库源名称</span><br></pre></td></tr></table></figure>

<ul>
<li><p>NAME: 镜像仓库源的名称</p>
</li>
<li><p>DESCRIPTION: 镜像的描述</p>
</li>
<li><p>OFFICIAL: 是否 docker 官方发布</p>
</li>
<li><p>stars: 类似 Github 里面的 star，表示点赞、喜欢的意思。</p>
</li>
<li><p>AUTOMATED: 自动构建。</p>
</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载镜像</span></span><br><span class="line">docker pull 镜像仓库名称</span><br><span class="line"><span class="comment"># 使用镜像</span></span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> 镜像仓库源名称</span></span><br></pre></td></tr></table></figure>

<h6 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h6><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span> rmi 镜像名称</span><br></pre></td></tr></table></figure>

<h6 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h6><p>我们使用命令 <code>docker build</code> ， 从零开始来创建一个新的镜像。为此，我们需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ cat Dockerfile </span><br><span class="line"><span class="keyword">FROM</span>    centos:<span class="number">6.7</span></span><br><span class="line"><span class="keyword">MAINTAINER</span>      Fisher <span class="string">&quot;fisher@sudops.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">     /bin/<span class="built_in">echo</span> <span class="string">&#x27;root:123456&#x27;</span> |chpasswd</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">     useradd runoob</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">     /bin/<span class="built_in">echo</span> <span class="string">&#x27;runoob:123456&#x27;</span> |chpasswd</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">     /bin/<span class="built_in">echo</span> -e <span class="string">&quot;LANG=\&quot;en_US.UTF-8\&quot;&quot;</span> &gt;/etc/default/<span class="built_in">local</span></span></span><br><span class="line"><span class="keyword">EXPOSE</span>  <span class="number">22</span></span><br><span class="line"><span class="keyword">EXPOSE</span>  <span class="number">80</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash">     /usr/sbin/sshd -D</span></span><br></pre></td></tr></table></figure>

<p>每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。</p>
<p>FROM指定使用哪个镜像源；</p>
<p>RUN 指令告诉docker 在镜像内执行命令，安装了什么。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker build -t runoob/centos:6.7 .</span><br><span class="line">Sending build context <span class="keyword">to</span> Docker daemon 17.92 kB</span><br><span class="line"><span class="keyword">Step</span> 1 : <span class="keyword">FROM</span> centos:6.7</span><br><span class="line"> ---&amp;gt; d95b5ca17cc3</span><br><span class="line"><span class="keyword">Step</span> 2 : MAINTAINER Fisher <span class="string">&quot;fisher@sudops.com&quot;</span></span><br><span class="line"> ---&amp;gt; Using cache</span><br><span class="line"> ---&amp;gt; 0c92299c6f03</span><br><span class="line"><span class="keyword">Step</span> 3 : <span class="builtin-name">RUN</span> /bin/echo <span class="string">&#x27;root:123456&#x27;</span> |chpasswd</span><br><span class="line"> ---&amp;gt; Using cache</span><br><span class="line"> ---&amp;gt; 0397ce2fbd0a</span><br><span class="line"><span class="keyword">Step</span> 4 : <span class="builtin-name">RUN</span> useradd runoob</span><br><span class="line">······</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><strong>-t</strong> ：指定要创建的目标镜像名</li>
<li><strong>.</strong> ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径</li>
</ul>
<p>使用新的镜像来创建容器</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span> run -t -i runoob/centos:<span class="number">6</span>.<span class="number">7</span>  /bin/bash</span><br></pre></td></tr></table></figure>

<h6 id="设置镜像标签"><a href="#设置镜像标签" class="headerlink" title="设置镜像标签"></a>设置镜像标签</h6><p>使用 <code>docker tag</code> 命令，为镜像添加一个新的标签。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span> tag <span class="number">860</span>c<span class="number">279</span>d<span class="number">2</span>fec runoob/centos:dev</span><br></pre></td></tr></table></figure>

<h5 id="容器连接"><a href="#容器连接" class="headerlink" title="容器连接"></a>容器连接</h5><h6 id="网络端口映射"><a href="#网络端口映射" class="headerlink" title="网络端口映射"></a>网络端口映射</h6><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -d -P training/webapp python app.py</span></span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">docker run -d -p <span class="number">5000</span>:<span class="number">5000</span> training/webapp python app.py</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"># 查看镜像进程</span><br><span class="line">docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND           ...           PORTS                     NAMES</span><br><span class="line"><span class="number">33e4523</span>d30aa        training/webapp     <span class="string">&quot;python app.py&quot;</span>   ...   <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">5000</span>-&gt;<span class="number">5000</span>/tcp    berserk_bartik</span><br><span class="line">fce072cc88ce        training/webapp     <span class="string">&quot;python app.py&quot;</span>   ...   <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">32768</span>-&gt;<span class="number">5000</span>/tcp   grave_hopper</span><br></pre></td></tr></table></figure>

<p>两种方式的区别是:</p>
<ul>
<li><strong>-P :</strong>是容器内部端口<strong>随机</strong>映射到主机的高端口。</li>
<li><strong>-p :</strong> 是容器内部端口绑定到<strong>指定</strong>的主机端口。</li>
</ul>
<p>另外，我们可以指定容器绑定的网络地址，比如绑定 127.0.0.1，可以通过访问 127.0.0.1:5001 来访问容器的 5000 端口。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">docker run -d -p <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5001</span>:<span class="number">5000</span> training/webapp python app.py</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">CONTAINER ID        IMAGE               COMMAND           ...     PORTS                                NAMES</span><br><span class="line"><span class="number">95</span>c6ceef88ca        training/webapp     <span class="string">&quot;python app.py&quot;</span>   ...  <span class="number">5000</span>/tcp, <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5001</span>-&gt;<span class="number">5000</span>/tcp   adoring_stonebraker</span><br></pre></td></tr></table></figure>

<h6 id="容器命名"><a href="#容器命名" class="headerlink" title="容器命名"></a>容器命名</h6><p>当我们创建一个容器的时候，docker 会自动对它进行命名。另外，我们也可以使用 <code>--name</code> 标识来命名容器。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">run</span> -d -P <span class="comment">--name runoob training/webapp python app.py</span></span><br></pre></td></tr></table></figure>

<h5 id="Docker容器互联"><a href="#Docker容器互联" class="headerlink" title="Docker容器互联"></a>Docker容器互联</h5><p>端口映射并不是唯一把 docker 连接到另一个容器的方法。</p>
<p>docker 有一个连接系统允许将多个容器连接在一起，共享连接信息。</p>
<p>docker 连接会创建一个父子关系，其中父容器可以看到子容器的信息。</p>
<h6 id="新建网络"><a href="#新建网络" class="headerlink" title="新建网络"></a>新建网络</h6><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">docker<span class="built_in"> network </span>create -d<span class="built_in"> bridge </span>test-net</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<p><strong>-d</strong>：参数指定 Docker 网络类型，有 bridge、overlay。</p>
<h6 id="连接容器"><a href="#连接容器" class="headerlink" title="连接容器"></a>连接容器</h6><p>运行一个容器并连接到新建的 test-net 网络:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -itd --name test1 --network <span class="built_in">test</span>-net ubuntu /bin/bash</span></span><br></pre></td></tr></table></figure>

<p>打开新的终端，再运行一个容器并加入到 test-net 网络:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -itd --name test2 --network <span class="built_in">test</span>-net ubuntu /bin/bash</span></span><br></pre></td></tr></table></figure>

<p>可以通过ping命令来证明test1容器和test2容器建立了互联关系。</p>
<h5 id="配置DNS"><a href="#配置DNS" class="headerlink" title="配置DNS"></a>配置DNS</h5><p>可以在宿主机的 /etc/docker/daemon.json 文件中增加以下内容来设置全部容器的 DNS：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;dns&quot;</span> : [</span><br><span class="line">    <span class="string">&quot;114.114.114.114&quot;</span>,</span><br><span class="line">    <span class="string">&quot;8.8.8.8&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置后，启动容器的 DNS 会自动配置为 114.114.114.114 和 8.8.8.8。</p>
<p>配置完，需要重启 docker 才能生效。</p>
<p>查看容器的 DNS 是否生效可以使用以下命令，它会输出容器的 DNS 信息：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span> -it --<span class="keyword">rm</span> ubuntu  <span class="keyword">cat</span> etc/resolv.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure>

<h5 id="Docker-Dockerfile"><a href="#Docker-Dockerfile" class="headerlink" title="Docker Dockerfile"></a>Docker Dockerfile</h5><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p>
<h6 id="FROM-和-RUN-指令的作用"><a href="#FROM-和-RUN-指令的作用" class="headerlink" title="FROM 和 RUN 指令的作用"></a>FROM 和 RUN 指令的作用</h6><p><strong>FROM</strong>：定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。</p>
<p><strong>RUN</strong>：用于执行后面跟着的命令行命令。有以下俩种格式：</p>
<p>shell 格式：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> &lt;命令行命令&gt;</span></span><br><span class="line"><span class="comment"># &lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。</span></span><br></pre></td></tr></table></figure>

<p>exec 格式：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span> [<span class="string">&quot;可执行文件&quot;</span>, <span class="string">&quot;参数1&quot;</span>, <span class="string">&quot;参数2&quot;</span>]</span><br><span class="line"># 例如：</span><br><span class="line"># <span class="keyword">RUN</span> [<span class="string">&quot;./test.php&quot;</span>, <span class="string">&quot;dev&quot;</span>, <span class="string">&quot;offline&quot;</span>] 等价于 <span class="keyword">RUN</span> ./<span class="keyword">test</span>.php dev offline</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN yum install wget</span><br><span class="line">RUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span><br><span class="line">RUN tar -xvf redis.tar.gz</span><br></pre></td></tr></table></figure>

<p>以上执行会创建 3 层镜像。可简化为以下格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN yum install wget \</span><br><span class="line">  &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot; \</span><br><span class="line">  &amp;&amp; tar -xvf redis.tar.gz</span><br></pre></td></tr></table></figure>

<p>如上，以 <strong>&amp;&amp;</strong> 符号连接命令，这样执行后，只会创建 1 层镜像。</p>
<h6 id="开始构建镜像"><a href="#开始构建镜像" class="headerlink" title="开始构建镜像"></a>开始构建镜像</h6><p>以下示例，通过目录下的 Dockerfile 构建一个 nginx:test（镜像名称:镜像标签）。</p>
<p><strong>注</strong>：最后的 <strong>.</strong> 代表本次执行的上下文路径.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t nginx:<span class="built_in">test</span> .</span><br></pre></td></tr></table></figure>

<p>使用<code>docker images</code>查看镜像是否建立成功。</p>
<h6 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h6><ol>
<li><p>COPY: 复制指令<code>COPY 原路径 目标路径</code></p>
</li>
<li><p>ADD: 同COPY，如果源文件是tar压缩文件，则会自动复制解压到目标路径。</p>
</li>
<li><p>CMD: 类似于RUN，但CMD是在docker run时运行，RUN是在docker build。<code>CMD shell命令</code></p>
</li>
<li><p>ENTRYPOINT: 类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。<code>ENTRYPOINT 可执行命令 参数1...</code></p>
</li>
<li><p>ENV: 设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</p>
</li>
<li><p>ARG: 构建参数，与 ENV 作用一至。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p>
</li>
<li><p>VOLUME: 定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。<code>VOLUME &lt;路径&gt;</code></p>
<p> 作用：</p>
<ul>
<li><p>避免重要的数据，因容器重启而丢失，这是非常致命的。</p>
</li>
<li><p>避免容器不断变大。</p>
</li>
</ul>
</li>
<li><p>EXPOSE: 声明端口。<code>EXPOSE 端口1...</code></p>
</li>
<li><p>WORKDIR: 指定工作目录。<code>WORKDIR &lt;工作目录路径&gt;</code></p>
</li>
<li><p>USER:  用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。<code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p>
</li>
<li><p>HEALTHCHECK: 用于指定某个程序或者指令来监控 docker 容器服务的运行状态。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令</span><br><span class="line">HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</span><br><span class="line"></span><br><span class="line">HEALTHCHECK [选项] CMD &lt;命令&gt; : 这边 CMD 后面跟随的命令使用，可以参考 CMD 的用法。</span><br></pre></td></tr></table></figure>
</li>
<li><p>ONBUILD: 用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这是执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。<code>ONBUILD &lt;其它指令&gt;</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>ETL</title>
    <url>/2020/08/08/22/54/ETL/</url>
    <content><![CDATA[<p>ETL的概念及使用场景<a id="more"></a></p>
<h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>ETL 是三个单词的缩写：</p>
<ul>
<li>Extraction：抽取、提取；就是把数据从数据库里面取出来；</li>
<li>Transformation：转换；包括但不限于：数据筛选校验、数据关联、数据内容及结构的修改、运算、统计等等；</li>
<li>Loading：加载；将处理后的数据保存到目标数据库。</li>
</ul>
<p>从这三个单词基本可以了解 ETL 的作用：将各个业务系统的数据，通过抽取、清洗、转换之后，将加工后的数据落地到数据库中（数据仓库）；在这个过程中，ETL 可以将分散、零乱、标准不统一的数据整合到一起。</p>
<p><img src="/2020/08/08/22/54/ETL/ETL.webp.jpg" alt></p>
<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><h6 id="报表、BI系统"><a href="#报表、BI系统" class="headerlink" title="报表、BI系统"></a>报表、BI系统</h6><p>在公司建设的初期，业务比较少，系统也比较少，一台数据库就搞定了；随着公司业务的增加，业务系统被拆成很多系统；随着数据量的继续增加，单个系统的数据增加到一定程度的时候，也做了分库分表；</p>
<p>这时候领导、业务人员在用数据做分析的时候，数据来源可能是多个系统的多张表，这时候企图通过一个复杂的 SQL 跑出来结果就很困难了；通常公司会建立一个数据仓库，通过ETL工具把数据抽取到数据仓库中，再做数据的拟合和展示。</p>
<h6 id="跨系统的数据加工或查询"><a href="#跨系统的数据加工或查询" class="headerlink" title="跨系统的数据加工或查询"></a>跨系统的数据加工或查询</h6><p>业务系统有几百个，由于业务流程比较复杂，前端系统在做业务操作的时候，在正式提交交易之前，有很多业务校验；</p>
<p>比如要查询客户在 X 系统的交易历史，在 Y 系统的交易历史，在 Z 系统的交易历史；那么就需要分别调用 X、Y、Z 系统的接口，这个对前端系统很不友好，那么通常的解决方案是什么？</p>
<ul>
<li>A 方案：做一个中间服务，中间服务去调用 X、Y、Z 系统的接口，客户端直接调用这个中间服务；这种方案只是把前端要做的事情，转移到了中间服务；</li>
<li>B 方案：整合 X、Y、Z 三个系统，建服务中台；这种方法很好，但是极为难，对于很多公司来说，别说把 X、Y、Z 三个系统整合成一个中台系统，就是其中一个系统本身进行重构，都是非常困难的；</li>
<li>C 方案：把 X、Y、Z 三个系统中需要的数据，通过 ETL 抽取加工到一个数据仓库中，对外提供服务；这个系统最大的好处是在不改造 X、Y、Z 三个系统的前提下，又可以实现跨系统的查询。</li>
</ul>
<p>我们在 C 方案的基础上又往前做了一步，就是将落地后的数据又做了一次加工，将需要跨表关联的数据，提前关联好存入 MongoDB 中，对外提供查询服务；这样可以将多表关联查询，变成了单表查询。</p>
<p><img src="/2020/08/08/22/54/ETL/ETL2.webp.jpg" alt></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建博客</title>
    <url>/2019/11/22/10/52/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p> Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 </p>
<a id="more"></a>

<p>Hexo官方文档 <a href="https://hexo.io/docs/index.html">https://hexo.io/docs/index.html</a> 。</p>
<p>使用Hexo搭建自己的博客首先需要下列应用程序：</p>
<ul>
<li><a href="http://nodejs.org/">Node.js</a> (建议使用 Node.js 10.0 及以上版本，现在最新稳定版13.1)</li>
<li><a href="http://git-scm.com/">Git</a></li>
</ul>
<p>所有必备的应用程序安装完成后，就可以利用npm安装Hexo。</p>
<h5 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h5><p>利用命令提示符输入以下命令安装Hexo：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g hexo</span><br></pre></td></tr></table></figure>

<p>新建一个文件夹用来部署你的博客项目，进入文件夹右键Git Bash Here打开git bush命令界面，输入下列命令初始化文件夹(以便后面部署到GitHub上)：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo init</span></span><br></pre></td></tr></table></figure>

<p>在文件夹中安装npm:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span></span><br></pre></td></tr></table></figure>

<p>安装git部署插件:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span><br></pre></td></tr></table></figure>

<h5 id="服务器端运行"><a href="#服务器端运行" class="headerlink" title="服务器端运行"></a>服务器端运行</h5><p>可以通过下面的命令在本地服务器运行，在浏览器中输入 <a href="http://localhost:4000">http://localhost:4000</a> 即可，但是需要一直保持连接不断开:</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">server</span></span><br></pre></td></tr></table></figure>

<p>也可以利用SSH上传博客项目到GitHub的repository仓库上，就可以用网络直接访问仓库名即可打开博客。</p>
<h6 id="创建GitHub账号"><a href="#创建GitHub账号" class="headerlink" title="创建GitHub账号"></a>创建GitHub账号</h6><p>在 <a href="https://github.com/">https://github.com/</a> 上注册账号，完成后，在 <a href="https://github.com">https://github.com</a> 页面点击右上角”+”的”new repository”创建自己的项目仓库，仓库名称是”自己的github名称.github.io”，例如我的github账号名称Isdear，仓库名即为”Isdear.github.io”。</p>
<h6 id="关联本地仓库"><a href="#关联本地仓库" class="headerlink" title="关联本地仓库"></a>关联本地仓库</h6><p>右键点击Git Bash Here进入命令界面，通过命令绑定账户。</p>
<p>配置用户名</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global user.name <span class="string">&quot;yourname&quot;</span></span><br></pre></td></tr></table></figure>

<p>配置GitHub账户邮箱</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global user.email <span class="string">&quot;youremail@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>输入命令生成SSH key:</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">ssh-keygen -<span class="built_in">t</span> rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>命令界面会显示生成的位置，例如我的是在”c/users/dell/.ssh/id_rsa.pub”。打开id_rsa.pub文件，里面的内容全部复制。在网页中点击GitHub账户头像选择”Settings”，再点击”SSH and GPG keys”，点击SSH右边的”new SSH key”，Title可以随便输入，Key中就将刚刚复制的密钥粘贴过去，点击”Add SSH key”，之后就会生成的16进制的SSH 密令。打开GitHub上的仓库，复制SSH地址链接，</p>
<p>Git Bash中输入关联GitHub账户:</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ssh</span> git<span class="variable">@github</span>.com</span><br></pre></td></tr></table></figure>

<p>在你的博客项目文件夹中打开”_config.yml”文件，直接拉到最下面配置项目部署环境。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repository</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:Isdear/Isdear.github.io.git</span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure>

<h6 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h6><p>在Git Bash界面输入下面的命令，生成博客项目的静态文件</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">generate</span></span><br></pre></td></tr></table></figure>

<p>部署到GitHub上:</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo deploy</span></span><br></pre></td></tr></table></figure>

<p>接下来就可以直接浏览器的地址栏输入你的GitHub仓库名即可访问博客。</p>
<h5 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h5><p>Hexo可以在 <a href="https://hexo.io/themes/">https://hexo.io/themes/</a> 选择博客的主题，点击主题的名称，进入到主题的GitHub仓库，下载ZIP压缩包，解压后把文件夹放入到博客项目的themes目录下(文件夹名字有点长，可以重命名一下)。在博客项目主目录下打开”_config.yml”文件，修改theme属性，默认是”landscape”，你把它修改成你下载的主题的文件夹名称就可以了，重新执行生成和部署命令，就可以看到博客的新主题了。</p>
<h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><p>这里只是提出一些常用的命令，更多命令还是到官方文档查看。</p>
<h6 id="初始化本地文件夹为网站的根目录"><a href="#初始化本地文件夹为网站的根目录" class="headerlink" title="初始化本地文件夹为网站的根目录"></a>初始化本地文件夹为网站的根目录</h6><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo init</span></span><br></pre></td></tr></table></figure>

<h6 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h6><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> [layout] <span class="built_in">title</span></span><br></pre></td></tr></table></figure>

<h6 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h6><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">generate</span></span><br><span class="line">可以简写为</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<h6 id="启动本地服务器"><a href="#启动本地服务器" class="headerlink" title="启动本地服务器"></a>启动本地服务器</h6><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">hexo server</span><br><span class="line">可以简写为</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<h6 id="部署网站"><a href="#部署网站" class="headerlink" title="部署网站"></a>部署网站</h6><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">hexo</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">可以简写为</span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">d</span></span><br></pre></td></tr></table></figure>

<p>指定生成后部署</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo g -d</span> </span><br></pre></td></tr></table></figure>

<h6 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h6><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo clean</span></span><br></pre></td></tr></table></figure>

<h5 id="撰写文章"><a href="#撰写文章" class="headerlink" title="撰写文章"></a>撰写文章</h5><p>因为Hexo是使用Markdown解析文章的，所以推荐使用Typora工具来编写文章 <a href="https://www.typora.io">https://www.typora.io</a> 。</p>
<p>使用hexo new title命令可以在source/_posts目录下生成一个md格式的文档，使用Typora打开，开始写我们的博客。在工具内你可以右键添加图片、代码块、公式块、链接、表格、脚注、分割线、段落等，这里不再一一说明，只说明一些右键没有说明的设置。</p>
<h6 id="文章头部设置"><a href="#文章头部设置" class="headerlink" title="文章头部设置"></a>文章头部设置</h6><p>创建文章之后，文章里的头部来自模板，默认是scaffolds目录下的post.md，你可以修改模板来对文章进行说明。</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">title: Title </span><br><span class="line">date: YYYY-MM-DD HH:MM:SS </span><br><span class="line"><span class="keyword">tags:</span> [tag1, tag2, ...] </span><br><span class="line">categories: category </span><br></pre></td></tr></table></figure>

<p>属性与属性值中间必须要有一个空格，否则会解析错误。</p>
<h6 id="首页显示"><a href="#首页显示" class="headerlink" title="首页显示"></a>首页显示</h6><p>Hexo框架搭建的博客网站中，首页显示的文章默认是显示全部内容，这样很不方便。使用<code>&lt;!--more--&gt;</code>标志，即可隐藏标志前面的内容。</p>
<h6 id="部署发布"><a href="#部署发布" class="headerlink" title="部署发布"></a>部署发布</h6><p>每次写完文章或者修改配置后都要输入命令</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo g -d</span></span><br></pre></td></tr></table></figure>

<p>重新生成静态文件重新部署。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA代码行数统计插件-Statistic</title>
    <url>/2020/01/13/15/15/IDEA%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0%E7%BB%9F%E8%AE%A1%E6%8F%92%E4%BB%B6-Statistic/</url>
    <content><![CDATA[<p>Statistic是IDEA用来统计代码行数的插件<a id="more"></a></p>
<blockquote>
<p>Shows project statistic. This plugin shows files sorted by their extension along with size, line count LOC etc. User can select (Project/Module/Package/File) scope using the ‘Refresh on selection’ button. (This plugin requires Java 1.8)</p>
</blockquote>
<p>&emsp;&emsp;显示项目统计数量。这个插件显示的是按照文件扩展名排序的文件，以及大小、行数、LOC等。使用者能够选择（项目/模块/包/文件）范围使用”Refresh”按钮。（该插件需要java1.8）</p>
<h5 id="Statistic安装"><a href="#Statistic安装" class="headerlink" title="Statistic安装"></a>Statistic安装</h5><p>&emsp;&emsp;进入IDEA插件File-&gt;Settings-&gt;Plugins，点击上方的Marketplace，搜索Statistic，点击Install。下载安装完之后重启IDEA。<img src="/2020/01/13/15/15/IDEA%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0%E7%BB%9F%E8%AE%A1%E6%8F%92%E4%BB%B6-Statistic/s1.jpg" alt="install"></p>
<h5 id="项目统计"><a href="#项目统计" class="headerlink" title="项目统计"></a>项目统计</h5><p>&emsp;&emsp;打开任意一个项目开始进行统计。在顶部的菜单栏找到插件，View-&gt;Tool Windows-&gt;Statistic。也可以查看IDEA底部的功能栏，点击Statistic，点击Refresh开始统计项目的代码行数。Overview是统计所有文件的数量count和行数lines，以及不同文件类型行数的和大小的最大值、最小值和平均值。可以选择右边查看需要的后缀名文件代码行数。具体某种文件类型（如：java），可以统计总行数Total Lines，有效代码行数Source Code Lines，注释行数Comment Lines，以及有效代码比重。<img src="/2020/01/13/15/15/IDEA%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0%E7%BB%9F%E8%AE%A1%E6%8F%92%E4%BB%B6-Statistic/s2.jpg" alt="result"></p>
]]></content>
      <categories>
        <category>插件</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA连接数据库设置时区问题</title>
    <url>/2020/05/24/10/25/IDEA%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E7%BD%AE%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>Server returns invalid timezone. Go to ‘Advanced’ tab and set ‘serverTimezone’ property manually<a id="more"></a></p>
<h6 id="错误详情"><a href="#错误详情" class="headerlink" title="错误详情"></a>错误详情</h6><p>出现上述提示是因为MySQL没有设置时区导致的，而我们在安装的时候默认使用系统的时区，这里只需更改设置成当地的时区就解决了。</p>
<h6 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h6><ol>
<li><p>在设置时区前，先检查MySQL的环境变量是否配置正确。</p>
<p> 在<strong>Path</strong>中加入MySQL的<strong>bin路径地址</strong>。</p>
<p> <img src="/2020/05/24/10/25/IDEA%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E7%BD%AE%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98/bin%E8%B7%AF%E5%BE%84.png" alt></p>
</li>
<li><p>连接MySQL，设置时区。</p>
<p> 通过命令提示符窗口连接MySQL，<code>mysql -hlocalhost -uroot -p</code>，回车，输入密码。</p>
<p> 输入<code>show variables like&#39;%time_zone&#39;;</code>，查看MySQL的时区设置。默认使用系统时区，如图所示。</p>
</li>
</ol>
<p><img src="/2020/05/24/10/25/IDEA%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E7%BD%AE%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98/systemzone.png" alt></p>
<p>输入<code>set time_zone = &#39;+8:00&#39;;</code>，设置当地的时区。成功之后如下图所示。</p>
<p><img src="/2020/05/24/10/25/IDEA%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E7%BD%AE%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98/nativezone.png" alt></p>
<ol start="3">
<li>IDEA中MySQL驱动设置，下图中的第一个MySQL是自己配置的，一定要与自己所使用的MySQL版本一致。</li>
</ol>
<p><img src="/2020/05/24/10/25/IDEA%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E7%BD%AE%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98/idea.png" alt></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>JWT授权验证</title>
    <url>/2020/06/14/20/53/JWT%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<p>Jwt(Json web token)网络令牌<a id="more"></a></p>
<h5 id="传统的session验证"><a href="#传统的session验证" class="headerlink" title="传统的session验证"></a>传统的session验证</h5><p>传统的基于session验证将用户信息保存为cookie存到服务器中，每次用户发起的请求都会验证cookie中的用户信息，这样服务器才能判断请求来自哪个用户。随着不同客户端用户的增加，独立的服务器无法承载更多的用户。</p>
<p>用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上，这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。</p>
<p>因为是基于cookie来进行用户识别的，cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p>
<h5 id="基于token的鉴权机制"><a href="#基于token的鉴权机制" class="headerlink" title="基于token的鉴权机制"></a>基于token的鉴权机制</h5><p>基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。</p>
<p>流程上是这样的：</p>
<ul>
<li><p>用户使用用户名密码来请求服务器</p>
</li>
<li><p>服务器进行验证用户的信息</p>
</li>
<li><p>服务器通过验证发送给用户一个token</p>
</li>
<li><p>客户端存储token，并在每次请求时附送上这个token值</p>
</li>
<li><p>服务端验证token值，并返回数据</p>
</li>
</ul>
<p>这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持<code>CORS(跨来源资源共享)</code>策略，一般我们在服务端这么做就可以了<code>Access-Control-Allow-Origin: *</code>。</p>
<h5 id="JWT的构成"><a href="#JWT的构成" class="headerlink" title="JWT的构成"></a>JWT的构成</h5><p>JWT是由三段信息构成的，将这三段信息文本用<code>.</code>链接一起就构成了Jwt字符串。就像这样:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span>.eyJzdWIiOiIxMjM<span class="number">0</span>NTY<span class="number">3</span>ODkwIiwibmFtZSI<span class="number">6</span>IkpvaG<span class="number">4</span>gRG<span class="number">9</span>lIiwiYWRtaW<span class="number">4</span>iOnRydWV<span class="number">9</span>.TJVA<span class="number">95</span>OrM<span class="number">7</span>E<span class="number">2</span>cBab<span class="number">30</span>RMHrHDcEfxjoYZgeFONFh<span class="number">7</span>HgQ</span><br></pre></td></tr></table></figure>

<p>第一部分我们称它为头部（header)，第二部分我们称其为载荷（payload，类似于飞机上承载的物品)，第三部分是签证（signature)。</p>
<h6 id="header"><a href="#header" class="headerlink" title="header"></a>header</h6><p>jwt的头部承载两部分信息：</p>
<ul>
<li><p>声明类型，这里是jwt</p>
</li>
<li><p>声明加密的算法，通常直接使用HMAC SHA256</p>
</li>
</ul>
<p>完整的头部就像是下面这样的JSON</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&#x27;typ&#x27;: &#x27;JWT&#x27;,</span><br><span class="line">	&#x27;alg&#x27;: &#x27;HS256&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将头部进行base64加密，构成第一部分<code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</code>。</p>
<h6 id="playload"><a href="#playload" class="headerlink" title="playload"></a>playload</h6><p>载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分</p>
<ul>
<li>标准中注册的声明</li>
<li>公共的声明</li>
<li>私有的声明</li>
</ul>
<p>标准中注册的声明 (建议但不强制使用) ：</p>
<ul>
<li>iss: jwt签发者</li>
<li>sub: jwt所面向的用户</li>
<li>aud: 接收jwt的一方</li>
<li>exp: jwt的过期时间，这个过期时间必须要大于签发时间</li>
<li>nbf: 定义在什么时间之前，该jwt都是不可用的.</li>
<li>iat: jwt的签发时间</li>
<li>jti: jwt的唯一身份标识，主要用来作为一次性token，从而回避重放攻击。</li>
</ul>
<p>公共的声明 ：<br> 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息。但不建议添加敏感信息，因为该部分在客户端可解密。</p>
<p>私有的声明 ：<br> 私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。</p>
<p>定义一个payload:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;sub&quot;</span>: <span class="string">&quot;1234567890&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;admin&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将其进行base64加密，得到Jwt的第二部分<code>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</code>。</p>
<h6 id="signature"><a href="#signature" class="headerlink" title="signature"></a>signature</h6><p>jwt的第三部分是一个签证信息，这个签证信息由三部分组成：</p>
<ul>
<li>header (base64后的)</li>
<li>payload (base64后的)</li>
<li>secret</li>
</ul>
<p>这个部分需要base64加密后的header和base64加密后的payload使用<code>.</code>连接组成的字符串，然后通过header中声明的加密方式进行加盐<code>secret</code>组合加密，然后就构成了jwt的第三部分。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// javascript</span></span><br><span class="line"><span class="keyword">var</span> encodedString = base64UrlEncode(header) + <span class="string">&#x27;.&#x27;</span> + base64UrlEncode(payload);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> signature = HMACSHA256(encodedString, <span class="string">&#x27;secret&#x27;</span>); </span><br><span class="line"><span class="comment">// TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span></span><br></pre></td></tr></table></figure>

<p>将这三部分用<code>.</code>连接成一个完整的字符串，构成了最终的jwt:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span>.eyJzdWIiOiIxMjM<span class="number">0</span>NTY<span class="number">3</span>ODkwIiwibmFtZSI<span class="number">6</span>IkpvaG<span class="number">4</span>gRG<span class="number">9</span>lIiwiYWRtaW<span class="number">4</span>iOnRydWV<span class="number">9</span>.TJVA<span class="number">95</span>OrM<span class="number">7</span>E<span class="number">2</span>cBab<span class="number">30</span>RMHrHDcEfxjoYZgeFONFh<span class="number">7</span>HgQ</span><br></pre></td></tr></table></figure>

<p>注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret，那就意味着客户端是可以自我签发jwt了。</p>
<h5 id="JWT应用"><a href="#JWT应用" class="headerlink" title="JWT应用"></a>JWT应用</h5><p>一般是在请求头里加入<code>Authorization</code>，并加上<code>Bearer</code>标注：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">fetch</span>(<span class="string">&#x27;api/user/1&#x27;</span>, &#123;</span><br><span class="line">  <span class="attribute">headers</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">&#x27;Bearer &#x27;</span> + token</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>服务端会验证token，如果验证通过就会返回相应的资源。整个流程就是这样的:</p>
<p><img src="/2020/06/14/20/53/JWT%E6%8E%88%E6%9D%83%E9%AA%8C%E8%AF%81/jwt.png" alt></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><ul>
<li><p>因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。</p>
</li>
<li><p>因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。</p>
</li>
<li><p>便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。</p>
</li>
<li><p>它不需要在服务端保存会话信息, 所以它易于应用的扩展。</p>
</li>
</ul>
<h6 id="安全部分"><a href="#安全部分" class="headerlink" title="安全部分"></a>安全部分</h6><ul>
<li>不应该在jwt的payload部分存放敏感信息，因为该部分是客户端可解密的部分。</li>
<li>保护好secret私钥，该私钥非常重要。</li>
<li>如果可以，请使用https协议。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java小知识</title>
    <url>/2020/04/26/16/27/Java%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>java面试题中的一些知识点<a id="more"></a></p>
<ol>
<li><p>方法重载，参数列表不相同，返回值类型可以不同；方法重写，遵循两同-两小-一大规则。两同：方法名和参数列表相同；两小：子类返回值类型小于等于父类的，异常抛出小于等于父类；一大：访问权限修饰符大于等于父类。</p>
</li>
<li><p>HashMap可以用null值和空字符串作为Key,不过只能有一个。</p>
</li>
<li><p>字面量”+”拼接是在编译期间进行的，拼接后的字符串存放在字符串池中；而字符串引用的”+”拼接运算是在运行时进行的，新创建的字符串存放在堆中。</p>
</li>
<li><p>数组是一种引用数据类型，长度固定。那么它肯定是继承Object类的，所以里面有equals() 方法。但是没有被重写过，所以它并不是比较数组内的内容，Arrays.equals()才是比较两个数组中的内容。</p>
</li>
<li><p>Integer，Float，Double等都继承自Number类。</p>
</li>
<li><p>处理异常常用的两种方式：<br> 1、try…catch(捕获处理机制)；<br> 2、throws(冒泡处理机制).<br> 注意细节：使用try…catch块捕获时可以没有catch块,但当没有catch块的时候必须得有finally块。</p>
</li>
<li><p>构造方法是一种特殊的方法，具有以下特点。</p>
<p> （1）构造方法的方法名必须与类名相同。</p>
<p> （2）构造方法没有返回类型，也不能定义为void，在方法名前面不声明方法类型。</p>
<p> （3）构造方法的主要作用是完成对象的初始化工作，它能够把定义对象时的参数传给对象的域。</p>
<p> （4）一个类可以定义多个构造方法，如果在定义类时没有定义构造方法，则编译系统会自动插入一个无参数的默认构造器，这个构造器不执行任何代码。</p>
<p> （5）构造方法可以重载，以参数的个数，类型，顺序。</p>
</li>
<li><table>
<thead>
<tr>
<th align="center"><strong>修饰符</strong></th>
<th align="center"><strong>类</strong></th>
<th align="center">成员方法</th>
<th align="center"><strong>构造方法</strong></th>
<th align="center"><strong>成员变量</strong></th>
<th align="center"><strong>局部变量</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">abstract（抽象的）</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">－</td>
<td align="center">－</td>
<td align="center">－</td>
</tr>
<tr>
<td align="center">static （静态的）</td>
<td align="center">－</td>
<td align="center">√</td>
<td align="center">－</td>
<td align="center">√</td>
<td align="center">－</td>
</tr>
<tr>
<td align="center">public（公共的）</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">－</td>
</tr>
<tr>
<td align="center">protected（受保护的）</td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">－</td>
</tr>
<tr>
<td align="center">private（私有的）</td>
<td align="center">－</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">－</td>
</tr>
<tr>
<td align="center">synchronized（同步的）</td>
<td align="center">－</td>
<td align="center">√</td>
<td align="center">－</td>
<td align="center">－</td>
<td align="center">－</td>
</tr>
<tr>
<td align="center">native（本地的）</td>
<td align="center">－</td>
<td align="center">√</td>
<td align="center">－</td>
<td align="center">－</td>
<td align="center">－</td>
</tr>
<tr>
<td align="center">transient（暂时的）</td>
<td align="center">－</td>
<td align="center">－</td>
<td align="center">－</td>
<td align="center">√</td>
<td align="center">－</td>
</tr>
<tr>
<td align="center">volatie（易失的）</td>
<td align="center">－</td>
<td align="center">－</td>
<td align="center">－</td>
<td align="center">√</td>
<td align="center">－</td>
</tr>
<tr>
<td align="center">final（不要改变的）</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">－</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
</tbody></table>
</li>
<li><p><img src="/2020/04/26/16/27/Java%E5%B0%8F%E7%9F%A5%E8%AF%86/modifer.png" alt></p>
</li>
<li><p>接口与抽象类的区别：</p>
<ul>
<li><p>抽象类可以有构造方法，接口中不能有构造方法。 </p>
</li>
<li><p>抽象类中可以有普通成员变量，接口中没有普通成员变量 </p>
</li>
<li><p>抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。 </p>
</li>
<li><p>抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然<br>  eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。 </p>
</li>
<li><p>抽象类中可以包含静态方法，接口中不能包含静态方法 </p>
</li>
<li><p>抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。 </p>
</li>
<li><p>一个类可以实现多个接口，但只能继承一个抽象类。 </p>
</li>
</ul>
</li>
<li><p>线程安全(Thread-safe)的集合对象：</p>
<ul>
<li>Vector 线程安全</li>
<li>HashTable 线程安全</li>
<li>StringBuffer 线程安全</li>
</ul>
<p>非线程安全的集合对象：</p>
<ul>
<li>ArrayList </li>
<li>LinkedList</li>
<li>HashMap</li>
<li>HashSet</li>
<li>TreeMap</li>
<li>TreeSet</li>
<li>StringBulider</li>
</ul>
</li>
<li><p>Java有5种方式来创建对象：</p>
<ol>
<li><p>使用 new 关键字（最常用）： <code>ObjectName obj = new ObjectName();</code></p>
</li>
<li><p>使用反射的Class类的newInstance()方法：</p>
<p><code>ObjectName obj = ObjectName.class.newInstance();</code></p>
</li>
<li><p>使用反射的Constructor类的newInstance()方法： </p>
<p><code>ObjectName obj = ObjectName.class.getConstructor.newInstance();</code></p>
</li>
<li><p>使用对象克隆clone()方法： <code>ObjectName obj = obj.clone();</code></p>
</li>
<li><p>使用反序列化（ObjectInputStream）的readObject()方法： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(FILE_NAME))) &#123; </span><br><span class="line">	ObjectName obj = ois.readObject(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面经三</title>
    <url>/2020/05/02/16/35/Java%E9%9D%A2%E7%BB%8F%E4%B8%89/</url>
    <content><![CDATA[<p>Java面试总结三<a id="more"></a></p>
<h6 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h6><p>Collection是集合类的上级接口，List、Set继承此接口，Map没有继承。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素，使用iterator()来区分重复与否，List是线性结构的容器，适用于按数值索引访问元素的情形。</p>
<p>Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</p>
<h6 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h6><p>HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：</p>
<ul>
<li><p>HashMap允许键和值是null，而Hashtable不允许键或者值是null。</p>
</li>
<li><p>Hashtable是同步的，而HashMap不是。</p>
</li>
</ul>
<p>因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。</p>
<p>HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。 一般认为Hashtable是一个遗留的类。</p>
<h6 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h6><p>红黑树是一棵自平衡的排序二叉树，这样就可以保证当需要快速检索指定节点。</p>
<p>红黑树的插入、删除、遍历时间复杂度都为O(lgN)，所以性能上低于哈希表。但是哈希表无法提供键值对的有序输出，红黑树因为是排序插入的，可以按照键的值的大小有序输出。</p>
<p>红黑树性质：</p>
<p>1：每个节点要么是红色，要么是黑色。</p>
<p>2：根节点永远是黑色的。</p>
<p>3：所有的叶节点都是空节点(即 null)，并且是黑色的。</p>
<p>4：每个红色节点的两个子节点都是黑色。(从每个叶子到根的路径上不会有两个连续的红色节点)</p>
<p>5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</p>
<h6 id="HashMap具体是如何实现的"><a href="#HashMap具体是如何实现的" class="headerlink" title="HashMap具体是如何实现的"></a>HashMap具体是如何实现的</h6><p>Hashmap基于数组实现的，通过对key的 hashcode 和数组的长度得到在数组中位置。如当前数组有元素，则数组当前元素next指向要插入的元素，这样来解决hash冲突的，形成了拉链式的结构。</p>
<p>put时在多线程情况下，会形成环从而导致死循环。数组长度一般是2n，从0开始编号，所以hashcode &amp; （2n-1），（2n-1）每一位都是1，这样会让散列均匀。</p>
<p>需要注意的是，HashMap在JDK1.8的版本中引入了红黑树结构做优化，当链表元素个数大于等于8时，链表转换成树结构；若桶中链表元素个数小于等于6时，树结构还原成链表。因为红黑树的平均查找长度是log(n)，长度为8的时候，平均查找长度为3，如果继续使用链表，平均查找长度为8/2=4，这才有转换为树的必要。链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。还有选择6和8，中间有个差值7可以有效防止链表和树频繁转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。</p>
<h6 id="线程的基本状态以及状态之间的关系"><a href="#线程的基本状态以及状态之间的关系" class="headerlink" title="线程的基本状态以及状态之间的关系"></a>线程的基本状态以及状态之间的关系</h6><p>Running表示运行状态，Runnable表示就绪状态（万事俱备，只欠CPU），Blocked表示阻塞状态，阻塞状态又有多种情况，可能是因为调用wait()方法进入等待池，也可能是执行同步方法或同步代码块进入等锁池，或者是调用了sleep()方法或join()方法等待休眠或其他线程结束，或是因为发生了I/O中断。</p>
<h6 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h6><p>在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。</p>
<p>Java 5+中的Executor接口定义一个执行线程的工具。它的子类型即线程池接口是ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类Executors面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：</p>
<ul>
<li>newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li>
<li>newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li>
<li>newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</li>
<li>newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</li>
<li>newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</li>
</ul>
<h6 id="sleep-和yield-方法区别"><a href="#sleep-和yield-方法区别" class="headerlink" title="sleep()和yield()方法区别"></a>sleep()和yield()方法区别</h6><p>①sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；</p>
<p>② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；</p>
<p>③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；</p>
<p>④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。</p>
<h6 id="使用内部类实现线程设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1"><a href="#使用内部类实现线程设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1" class="headerlink" title="使用内部类实现线程设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1"></a>使用内部类实现线程设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        ThreadTest1 tt = <span class="keyword">new</span> ThreadTest1();</span><br><span class="line">        Inc inc = tt.<span class="function">new <span class="title">Inc</span><span class="params">()</span></span>;</span><br><span class="line">        Dec dec = tt.<span class="function">new <span class="title">Dec</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(inc);</span><br><span class="line">            t.start();</span><br><span class="line">            t = <span class="keyword">new</span> Thread(dec);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        j++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-inc:&quot;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        j--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-dec:&quot;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inc</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                inc();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Dec</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                dec();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="线程从建立到死亡的几种状态"><a href="#线程从建立到死亡的几种状态" class="headerlink" title="线程从建立到死亡的几种状态"></a>线程从建立到死亡的几种状态</h6><ol>
<li><p>新建( new )：新创建了一个线程对象。</p>
</li>
<li><p>可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。</p>
</li>
<li><p>运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。</p>
</li>
<li><p>阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种：</p>
<ul>
<li><p>等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。</p>
</li>
<li><p>同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。</p>
</li>
<li><p>其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。 当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。</p>
</li>
</ul>
</li>
<li><p>死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p>
</li>
</ol>
<h6 id="线程池的运行流程，使用参数以及方法策略"><a href="#线程池的运行流程，使用参数以及方法策略" class="headerlink" title="线程池的运行流程，使用参数以及方法策略"></a>线程池的运行流程，使用参数以及方法策略</h6><p>线程池主要就是指定线程池核心线程数大小，最大线程数，存储的队列，拒绝策略，空闲线程存活时长。当需要任务大于核心线程数时候，就开始把任务往存储任务的队列里，当存储队列满了的话，就开始增加线程池创建的线程数量，如果当线程数量也达到了最大，就开始执行拒绝策略，比如说记录日志，直接丢弃，或者丢弃最老的任务。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面经二</title>
    <url>/2020/05/01/08/14/Java%E9%9D%A2%E7%BB%8F%E4%BA%8C/</url>
    <content><![CDATA[<p>Java面试总结二<a id="more"></a></p>
<h6 id="Java的值传递和引用传递"><a href="#Java的值传递和引用传递" class="headerlink" title="Java的值传递和引用传递"></a>Java的值传递和引用传递</h6><p>当一个对象呗当做参数传递给一个方法后，此方法可改变这个对象的属性，并返回变化后的结果，那么这里的是值传递。</p>
<p>Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。</p>
<h6 id="static-nested-class和inner-class的不同"><a href="#static-nested-class和inner-class的不同" class="headerlink" title="static nested class和inner class的不同"></a>static nested class和inner class的不同</h6><p>Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。</p>
<p>Static-Nested Class 的成员, 既可以定义为静态的(static), 也可以定义为动态的(instance)。Nested Class的静态成员(Method)只能对外部类的静态成员(static memebr)进行操作(ACCESS), 而不能Access Outer Class的动态成员(instance member)。而 Nested Class的动态成员(instance method) 却可以 Access Outer Class的所有成员, 这个概念很重要, 许多人对这个概念模糊. 有一个普通的原则, 因为静态方法(static method) 总是跟 CLASS 相关联(bind CLASS), 而动态方法( (instance method) 总是跟 instance object 相关联, 所以,静态方法(static method)永远不可以Access跟 object 相关的动态成员(instance member),反过来就可以, 一个CLASS的 instance object 可以 Access 这个 Class 的任何成员, 包括静态成员(static member)。</p>
<h6 id="abstract-class和interface的区别"><a href="#abstract-class和interface的区别" class="headerlink" title="abstract class和interface的区别"></a>abstract class和interface的区别</h6><p>声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。</p>
<p>接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。</p>
<h6 id="Java特征"><a href="#Java特征" class="headerlink" title="Java特征"></a>Java特征</h6><p>(1)抽象：抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。</p>
<p>(2)继承：继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。</p>
<p>(3)封装：封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。</p>
<p>(4) 多态性：多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。</p>
<h6 id="JAVA泛型"><a href="#JAVA泛型" class="headerlink" title="JAVA泛型"></a>JAVA泛型</h6><p>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          List list = new ArrayList();</span></span><br><span class="line"><span class="comment">          list.add(&quot;qqyumidi&quot;);</span></span><br><span class="line"><span class="comment">          list.add(&quot;corn&quot;);</span></span><br><span class="line"><span class="comment">          list.add(100);</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">  </span><br><span class="line">         List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">         list.add(<span class="string">&quot;qqyumidi&quot;</span>);</span><br><span class="line">         list.add(<span class="string">&quot;corn&quot;</span>);</span><br><span class="line">         <span class="comment">//list.add(100);   // 1  提示编译错误</span></span><br><span class="line">  </span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">             String name = list.get(i); <span class="comment">// 2</span></span><br><span class="line">             System.out.println(<span class="string">&quot;name:&quot;</span> + name);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>采用泛型写法后，在//1处想加入一个Integer类型的对象时会出现编译错误，通过List<String>，直接限定了list集合中只能含有String类型的元素，从而在//2处无须进行强制类型转换，因为此时，集合能够记住元素的类型信息，编译器已经能够确认它是String类型了。</String></p>
<h6 id="Java的反射机制"><a href="#Java的反射机制" class="headerlink" title="Java的反射机制"></a>Java的反射机制</h6><p>反射的含义：</p>
<ol>
<li>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；</li>
<li>对于任意一个对象，都能够调用它的任意方法和属性；</li>
<li>这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</li>
</ol>
<p>反射机制的作用：</p>
<ol>
<li>反编译：.class -&gt; .java</li>
<li>通过反射机制访问java对象的属性、方法、狗仔方法等；</li>
</ol>
<p>具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> num, String name)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">protected</span> String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Class c = Student.class;</span><br><span class="line">		Constructor[] ct = c.getConstructors();</span><br><span class="line">		<span class="keyword">for</span>(Constructor constructor : ct) &#123;</span><br><span class="line">			System.out.println(constructor);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取类中的属性及方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Class c = Student.class;</span><br><span class="line">		Field[] fs = c.getDeclaredFields();</span><br><span class="line">		<span class="keyword">for</span>(Field field : fs) &#123;</span><br><span class="line">			System.out.println(field);</span><br><span class="line">		&#125;</span><br><span class="line">        Method[] ms = c.getMethods();</span><br><span class="line">		<span class="keyword">for</span> (Method method : ms) &#123;</span><br><span class="line">			System.out.println(method);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="类加载机制、双亲委派模型"><a href="#类加载机制、双亲委派模型" class="headerlink" title="类加载机制、双亲委派模型"></a>类加载机制、双亲委派模型</h6><p>某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</p>
<p>使用双亲委派模型的好处在于：Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。因此，如果开发者尝试编写一个与rt.jar类库中重名的Java类，可以正常编译，但是永远无法被加载运行。</p>
<h6 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h6><p>Java不可以覆盖(override)一个private或者static的方法，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关。</p>
<h6 id="Object类方法"><a href="#Object类方法" class="headerlink" title="Object类方法"></a>Object类方法</h6><p>Object()默认构造方法。</p>
<p>clone() 创建并返回此对象的一个副本。</p>
<p>equals(Object obj) 指示某个其他对象是否与此对象“相等”。</p>
<p>finalize()当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。</p>
<p>getClass()返回一个对象的运行时类。</p>
<p>hashCode()返回该对象的哈希码值。 </p>
<p>notify()唤醒在此对象监视器上等待的单个线程。 </p>
<p>notifyAll()唤醒在此对象监视器上等待的所有线程。</p>
<p>toString()返回该对象的字符串表示。</p>
<p>wait()导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。</p>
<p>wait(long timeout)导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。</p>
<p>wait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。</p>
<h6 id="List、Map、Set三个接口存取元素特点"><a href="#List、Map、Set三个接口存取元素特点" class="headerlink" title="List、Map、Set三个接口存取元素特点"></a>List、Map、Set三个接口存取元素特点</h6><ul>
<li><p>List以特定索引来存取元素，可以有重复元素。</p>
</li>
<li><p>Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。</p>
</li>
<li><p>Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。</p>
</li>
</ul>
<p>Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面经五</title>
    <url>/2020/05/04/21/51/Java%E9%9D%A2%E7%BB%8F%E4%BA%94/</url>
    <content><![CDATA[<p>Java面试总结五<a id="more"></a></p>
<h6 id="Spring中BeanFactory和ApplicationContext的区别是什么？"><a href="#Spring中BeanFactory和ApplicationContext的区别是什么？" class="headerlink" title="Spring中BeanFactory和ApplicationContext的区别是什么？"></a>Spring中BeanFactory和ApplicationContext的区别是什么？</h6><p><strong>BeanFactory</strong>：</p>
<p>BeanFactory是spring中比较原始，比较古老的Factory。因为比较古老，所以BeanFactory无法支持spring插件，例如：AOP、Web应用等功能。</p>
<p><strong>ApplicationContext</strong>：</p>
<p>ApplicationContext是BeanFactory的子类，因为古老的BeanFactory无法满足不断更新的spring的需求，于是ApplicationContext就基本上代替了BeanFactory的工作，以一种更面向框架的工作方式以及对上下文进行分层和实现继承，并在这个基础上对功能进行扩展：</p>
<ul>
<li>MessageSource, 提供国际化的消息访问</li>
<li>资源访问（如URL和文件）</li>
<li>事件传递</li>
<li>Bean的自动装配</li>
<li>各种不同应用层的Context实现</li>
</ul>
<p>区别：</p>
<ol>
<li>如果使用ApplicationContext，如果配置的bean是singleton，那么不管你有没有或想不想用它，它都会被实例化。好处是可以预先加载，坏处是浪费内存。</li>
<li>BeanFactory，当使用BeanFactory实例化对象时，配置的bean不会马上被实例化，而是等到你使用该bean的时候（getBean）才会被实例化。好处是节约内存，坏处是速度比较慢。多用于移动设备的开发。</li>
<li>没有特殊要求的情况下，应该使用ApplicationContext完成。因为BeanFactory能完成的事情，ApplicationContext都能完成，并且提供了更多接近现在开发的功能。</li>
</ol>
<h6 id="Spring中Bean的作用域有哪些？"><a href="#Spring中Bean的作用域有哪些？" class="headerlink" title="Spring中Bean的作用域有哪些？"></a>Spring中Bean的作用域有哪些？</h6><p>在Spring的早期版本中，仅有两个作用域：<strong>singleton</strong>和<strong>prototype</strong>，前者表示Bean以单例的方式存在；后者表示每次从容器中调用Bean时，都会返回一个新的实例，prototype通常翻译为原型。</p>
<p>设计模式中的创建型模式中也有一个原型模式，原型模式也是一个常用的模式，例如做一个室内设计软件，所有的素材都在工具箱中，而每次从工具箱中取出的都是素材对象的一个原型，可以通过对象克隆来实现原型模式。Spring 2.x中针对WebApplicationContext新增了3个作用域，分别是：<strong>request</strong>（每次HTTP请求都会创建一个新的Bean）、<strong>session</strong>（同一个HttpSession共享同一个Bean，不同的HttpSession使用不同的Bean）和<strong>globalSession</strong>（同一个全局Session共享一个Bean）。</p>
<p>单例模式和原型模式都是重要的设计模式。一般情况下，无状态或状态不可变的类适合使用单例模式。在传统开发中，由于DAO持有Connection这个非线程安全对象因而没有使用单例模式；但在Spring环境下，所有DAO类对可以采用单例模式，因为Spring利用AOP和Java API中的ThreadLocal对非线程安全的对象进行了特殊处理。</p>
<h6 id="依赖注入的方式"><a href="#依赖注入的方式" class="headerlink" title="依赖注入的方式"></a>依赖注入的方式</h6><p>1、Setter注入 2、构造器(Construct)注入 3、接口注入</p>
<h6 id="Autowired和Resource的区别"><a href="#Autowired和Resource的区别" class="headerlink" title="Autowired和Resource的区别"></a>Autowired和Resource的区别</h6><p>1.共同点</p>
<p>两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。</p>
<p>2、不同点</p>
<p>（1）@Autowired</p>
<p>@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</p>
<p>@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。</p>
<p>（2）@Resource</p>
<p>@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</p>
<h6 id="Spring支持的事务管理类型有哪些？"><a href="#Spring支持的事务管理类型有哪些？" class="headerlink" title="Spring支持的事务管理类型有哪些？"></a>Spring支持的事务管理类型有哪些？</h6><p>Spring支持编程式事务管理和声明式事务管理。许多Spring框架的用户选择声明式事务管理，因为这种方式和应用程序的关联较少，因此更加符合轻量级容器的概念。声明式事务管理要优于编程式事务管理，尽管在灵活性方面它弱于编程式事务管理，因为编程式事务允许你通过代码控制业务。</p>
<p>事务分为全局事务和局部事务。全局事务由应用服务器管理，需要底层服务器JTA支持（如WebLogic、WildFly等）。局部事务和底层采用的持久化方案有关，例如使用JDBC进行持久化时，需要使用Connection对象来操作事务；而采用Hibernate进行持久化时，需要使用Session对象来操作事务。</p>
<p>这些事务的父接口都是PlatformTransactionManager。Spring的事务管理机制是一种典型的策略模式，PlatformTransactionManager代表事务管理接口，该接口定义了三个方法，该接口并不知道底层如何管理事务，但是它的实现类必须提供getTransaction()方法（开启事务）、commit()方法（提交事务）、rollback()方法（回滚事务）的多态实现，这样就可以用不同的实现类代表不同的事务管理策略。使用JTA全局事务策略时，需要底层应用服务器支持，而不同的应用服务器所提供的JTA全局事务可能存在细节上的差异，因此实际配置全局事务管理器是可能需要使用JtaTransactionManager的子类，如：WebLogicJtaTransactionManager（Oracle的WebLogic服务器提供）、UowJtaTransactionManager（IBM的WebSphere服务器提供）等。</p>
<h6 id="你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？"><a href="#你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？" class="headerlink" title="你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？"></a>你如何理解AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？</h6><p>a. 连接点（Joinpoint）：程序执行的某个特定位置（如：某个方法调用前、调用后，方法抛出异常后）。一个类或一段程序代码拥有一些具有边界性质的特定点，这些代码中的特定点就是连接点。Spring仅支持方法的连接点。</p>
<p>b. 切点（Pointcut）：如果连接点相当于数据中的记录，那么切点相当于查询条件，一个切点可以匹配多个连接点。Spring AOP的规则解析引擎负责解析切点所设定的查询条件，找到对应的连接点。</p>
<p>c. 增强（Advice）：增强是织入到目标类连接点上的一段程序代码。Spring提供的增强接口都是带方位名的，如：BeforeAdvice、AfterReturningAdvice、ThrowsAdvice等。</p>
<p>d. 引介（Introduction）：引介是一种特殊的增强，它为类添加一些属性和方法。这样，即使一个业务类原本没有实现某个接口，通过引介功能，可以动态的为该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类。</p>
<p>e. 织入（Weaving）：织入是将增强添加到目标类具体连接点上的过程，AOP有三种织入方式：①编译期织入：需要特殊的Java编译期（例如AspectJ的ajc）；②装载期织入：要求使用特殊的类加载器，在装载类的时候对类进行增强；③运行时织入：在运行时为目标类生成代理实现增强。Spring采用了动态代理的方式实现了运行时织入，而AspectJ采用了编译期织入和装载期织入的方式。</p>
<p>f. 切面（Aspect）：切面是由切点和增强（引介）组成的，它包括了对横切关注功能的定义，也包括了对连接点的定义。</p>
<h6 id="AOP的原理"><a href="#AOP的原理" class="headerlink" title="AOP的原理"></a>AOP的原理</h6><p>AOP（Aspect Orient Programming），指面向方面（切面）编程，作为面向对象的一种补充，用于处理系统中分布于各个模块的横切关注点，比如事务管理、日志、缓存等等。AOP实现的关键在于AOP框架自动创建的AOP代理，AOP代理主要分为静态代理和动态代理，静态代理的代表为AspectJ；而动态代理则以Spring AOP为代表。通常使用AspectJ的编译时增强实现AOP，AspectJ是静态代理的增强，所谓的静态代理就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强。</p>
<p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理。JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。</p>
<p>如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</p>
<h6 id="AOP的应用场景"><a href="#AOP的应用场景" class="headerlink" title="AOP的应用场景"></a>AOP的应用场景</h6><p>Authentication 权限 ，Caching 缓存 ，Context passing 内容传递 ，Error handling 错误处理 ，Lazy loading 懒加载 ，Debugging 调试 ，logging, tracing, profiling and monitoring 记录跟踪　优化　校准，Performance optimization 性能优化 ，Persistence 持久化 ，Resource pooling 资源池 ，Synchronization 同步，Transactions 事务。</p>
<h6 id="Spring框架的优点"><a href="#Spring框架的优点" class="headerlink" title="Spring框架的优点"></a>Spring框架的优点</h6><p>Spring是一个轻量级的DI和AOP容器框架，在项目的中的使用越来越广泛，它的优点主要有以下几点：</p>
<p>Spring是一个非侵入式框架，其目标是使应用程序代码对框架的依赖最小化，应用代码可以在没有Spring或者其他容器的情况运行。</p>
<p>Spring提供了一个一致的编程模型，使应用直接使用POJO开发，从而可以使运行环境隔离开来。</p>
<p>Spring推动应用的设计风格向面向对象及面向接口编程转变，提高了代码的重用性和可测试性。</p>
<p>Spring改进了结构体系的选择，虽然作为应用平台，Spring可以帮助我们选择不同的技术实现，比如从Hibernate切换到其他的ORM工具，从Struts切换到Spring MVC,尽管我们通常不会这么做，但是我们在技术方案上选择使用Spring作为应用平台，Spring至少为我们提供了这种可能性的选择，从而降低了平台锁定风险。</p>
<h6 id="请问持久层设计要考虑的问题有哪些？请谈一下你用过的持久层框架都有哪些？"><a href="#请问持久层设计要考虑的问题有哪些？请谈一下你用过的持久层框架都有哪些？" class="headerlink" title="请问持久层设计要考虑的问题有哪些？请谈一下你用过的持久层框架都有哪些？"></a>请问持久层设计要考虑的问题有哪些？请谈一下你用过的持久层框架都有哪些？</h6><p>所谓”持久”就是将数据保存到可掉电式存储设备中以便今后使用，简单的说，就是将内存中的数据保存到关系型数据库、文件系统、消息队列等提供持久化支持的设备中。持久层就是系统中专注于实现数据持久化的相对独立的层面。</p>
<p>持久层设计的目标包括：<br>- 数据存储逻辑的分离，提供抽象化的数据访问接口。<br>- 数据访问底层实现的分离，可以在不修改代码的情况下切换底层实现。<br>- 资源管理和调度的分离，在数据访问层实现统一的资源调度（如缓存机制）。<br>- 数据抽象，提供更面向对象的数据操作。</p>
<p>持久层框架有：<br>- Hibernate<br>- MyBatis<br>- TopLink<br>- Guzz<br>- jOOQ<br>- Spring Data<br>- ActiveJDBC</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面经八</title>
    <url>/2020/05/07/12/41/Java%E9%9D%A2%E7%BB%8F%E5%85%AB/</url>
    <content><![CDATA[<p>Java面试总结八<a id="more"></a></p>
<h6 id="数据库的隔离级别"><a href="#数据库的隔离级别" class="headerlink" title="数据库的隔离级别"></a>数据库的隔离级别</h6><table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读（Dirty Read）</th>
<th align="center">不可重复读（NonRepeatable Read）</th>
<th align="center">幻读（Phantom Read）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">未提交读（Read uncommitted）</td>
<td align="center">可能</td>
<td align="center">可能</td>
<td align="center">可能</td>
</tr>
<tr>
<td align="center">已提交读（Read committed）</td>
<td align="center">不可能</td>
<td align="center">可能</td>
<td align="center">可能</td>
</tr>
<tr>
<td align="center">可重复读（Repeatable read）</td>
<td align="center">不可能</td>
<td align="center">不可能</td>
<td align="center">可能</td>
</tr>
<tr>
<td align="center">可串行化（Serializable ）</td>
<td align="center">不可能</td>
<td align="center">不可能</td>
<td align="center">不可能</td>
</tr>
</tbody></table>
<p>未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据。</p>
<p>提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)。</p>
<p>可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读。</p>
<p>串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。</p>
<h6 id="数据库索引底层是怎么实现的？哪些情况下索引会失效？"><a href="#数据库索引底层是怎么实现的？哪些情况下索引会失效？" class="headerlink" title="数据库索引底层是怎么实现的？哪些情况下索引会失效？"></a>数据库索引底层是怎么实现的？哪些情况下索引会失效？</h6><p>B+树实现的。</p>
<p>没有遵循最左匹配原则。</p>
<p>一些关键字会导致索引失效，例如 or， ！= ， not in，is null ,is not unll</p>
<p>like查询是以%开头</p>
<p>隐式转换会导致索引失效。</p>
<p>对索引应用内部函数，索引字段进行了运算。</p>
<h6 id="数据库的两种引擎使用方法"><a href="#数据库的两种引擎使用方法" class="headerlink" title="数据库的两种引擎使用方法"></a>数据库的两种引擎使用方法</h6><p>InnoDB是聚集索引，支持事务，支持行级锁，主要面向在线事务处理（OLTP）的应用；</p>
<p>MyISAM是非聚集索引，不支持事务，只支持表级锁，主要面向一些OLAP的应用。</p>
<p>联机事务处理OLTP（on-line transaction processing）、联机分析处理OLAP（On-Line Analytical Processing）。OLTP是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。 </p>
<p><strong>OLTP</strong> 系统强调数据库内存效率，强调内存各种指标的命令率，强调绑定变量，强调并发操作；</p>
<p><strong>OLAP</strong> 系统则强调数据分析，强调SQL执行市场，强调磁盘I/O，强调分区等。 </p>
<h6 id="数据库水平切分与垂直切分"><a href="#数据库水平切分与垂直切分" class="headerlink" title="数据库水平切分与垂直切分"></a>数据库水平切分与垂直切分</h6><p>垂直拆分就是要把表按模块划分到不同数据库表中（当然原则还是不破坏第三范式）。说得简单就是要把原来强耦合的系统拆分成多个弱耦合的服务，通过服务间的调用来满足业务需求看，因此表拆出来后要通过服务的形式暴露出去，而不是直接调用不同模块的表，也非常有利于进行局部的优化和治理，保障核心模块的稳定性。</p>
<p>水平拆分，上面谈到垂直切分只是把表按模块划分到不同数据库，但没有解决单表大数据量的问题，而水平切分就是要把一个表按照某种规则把数据划分到不同表或数据库里。</p>
<p>通俗理解：水平拆分行，行数据拆分到不同表中， 垂直拆分列，表数据拆分到不同表中。</p>
<h6 id="JDBC中如何进行事务处理"><a href="#JDBC中如何进行事务处理" class="headerlink" title="JDBC中如何进行事务处理"></a>JDBC中如何进行事务处理</h6><p>Connection提供了事务处理的方法，通过调用setAutoCommit(false)可以设置手动提交事务；当事务完成后用commit()显式提交事务；如果在事务处理过程中发生异常则通过rollback()进行事务回滚。除此之外，从JDBC 3.0中还引入了Savepoint（保存点）的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。</p>
<h6 id="数据库的事物特性"><a href="#数据库的事物特性" class="headerlink" title="数据库的事物特性"></a>数据库的事物特性</h6><ul>
<li><p>原子性(Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败； </p>
</li>
<li><p>一致性(Consistent)：事务结束后系统状态是一致的； </p>
</li>
<li><p>隔离性(Isolated)：并发执行的事务彼此无法看到对方的中间状态； </p>
</li>
<li><p>持久性(Durable)：事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。</p>
</li>
</ul>
<h6 id="使用JDBC操作数据库时，经常遇到性能问题，请你说明一下如何提升读取数据的性能，以及更新数据的性能？"><a href="#使用JDBC操作数据库时，经常遇到性能问题，请你说明一下如何提升读取数据的性能，以及更新数据的性能？" class="headerlink" title="使用JDBC操作数据库时，经常遇到性能问题，请你说明一下如何提升读取数据的性能，以及更新数据的性能？"></a>使用JDBC操作数据库时，经常遇到性能问题，请你说明一下如何提升读取数据的性能，以及更新数据的性能？</h6><p>要提升读取数据的性能，可以指定通过结果集（ResultSet）对象的setFetchSize()方法指定每次抓取的记录数（典型的空间换时间策略）；要提升更新数据的性能可以使用PreparedStatement语句构建批处理，将若干SQL语句置于一个批处理中执行。</p>
<h6 id="JDBC的反射及作用"><a href="#JDBC的反射及作用" class="headerlink" title="JDBC的反射及作用"></a>JDBC的反射及作用</h6><p>通过反射com.mysql.jdbc.Driver类，实例化该类的时候会执行该类内部的静态代码块，该代码块会在Java实现的DriverManager类中注册自己，DriverManager管理所有已经注册的驱动类，当调用DriverManager.geConnection方法时会遍历这些驱动类，并尝试去连接数据库，只要有一个能连接成功，就返回Connection对象，否则异常。</p>
<h6 id="Java规范中和-与Web-Service相关的规范有哪些？"><a href="#Java规范中和-与Web-Service相关的规范有哪些？" class="headerlink" title="Java规范中和 与Web Service相关的规范有哪些？"></a>Java规范中和 与Web Service相关的规范有哪些？</h6><p>Java规范中和Web Service相关的有三个：</p>
<ul>
<li><p>JAX-WS(JSR 224)：这个规范是早期的基于SOAP的Web Service规范JAX-RPC的替代版本，它并不提供向下兼容性，因为RPC样式的WSDL以及相关的API已经在Java EE5中被移除了。WS-MetaData是JAX-WS的依赖规范，提供了基于注解配置Web Service和SOAP消息的相关API。</p>
</li>
<li><p>JAXM(JSR 67)：定义了发送和接收消息所需的API,相当于Web Service的服务器端。</p>
</li>
<li><p>JAX-RS(JSR 311 &amp; JSR 339 &amp; JSR 370)：是Java针对REST（Representation State Transfer）架构风格制定的一套Web Service规范。</p>
</li>
</ul>
<p>REST是一种软件架构模式，是一种风格，它不像SOAP那样本身承载着一种消息协议， (两种风格的Web Service均采用了HTTP做传输协议，因为HTTP协议能穿越防火墙，Java的远程方法调用（RMI）等是重量级协议，通常不能穿越防火墙），因此可以将REST视为基于HTTP协议的软件架构。REST中最重要的两个概念是资源定位和资源操作，而HTTP协议恰好完整的提供了这两个点。HTTP协议中的URI可以完成资源定位，而GET、POST、OPTION、DELETE方法可以完成资源操作。因此REST完全依赖HTTP协议就可以完成Web Service，而不像SOAP协议那样只利用了HTTP的传输特性，定位和操作都是由SOAP协议自身完成的，也正是由于SOAP消息的存在使得基于SOAP的Web Service显得笨重而逐渐被淘汰。</p>
<h6 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h6><p>定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。优点：单例类只有一个实例、共享资源，全局使用节省创建时间，提高性能。可以用静态内部实现，保证是懒加载就行了，就是使用才会创建实例对象。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面经六</title>
    <url>/2020/05/05/14/55/Java%E9%9D%A2%E7%BB%8F%E5%85%AD/</url>
    <content><![CDATA[<p>Java面试总结六<a id="more"></a></p>
<h6 id="MyBatis中命名空间-namespace-的作用"><a href="#MyBatis中命名空间-namespace-的作用" class="headerlink" title="MyBatis中命名空间(namespace)的作用"></a>MyBatis中命名空间(namespace)的作用</h6><p>在大型项目中，可能存在大量的SQL语句，这时候为每个SQL语句起一个唯一的标识（ID）就变得并不容易了。为了解决这个问题，在MyBatis中，可以为每个映射文件起一个唯一的命名空间，这样定义在这个映射文件中的每个SQL语句就成了定义在这个命名空间中的一个ID。只要我们能够保证每个命名空间中这个ID是唯一的，即使在不同映射文件中的语句ID相同，也不会再产生冲突了。</p>
<h6 id="SpringMVC的工作原理"><a href="#SpringMVC的工作原理" class="headerlink" title="SpringMVC的工作原理"></a>SpringMVC的工作原理</h6><p>①客户端的所有请求都交给前端控制器DispatcherServlet来处理，它会负责调用系统的其他模块来真正处理用户的请求。</p>
<p>② DispatcherServlet收到请求后，将根据请求的信息（包括URL、HTTP协议方法、请求头、请求参数、Cookie等）以及HandlerMapping的配置找到处理该请求的Handler（任何一个对象都可以作为请求的Handler）。</p>
<p>③在这个地方Spring会通过HandlerAdapter对该处理器进行封装。</p>
<p>④ HandlerAdapter是一个适配器，它用统一的接口对各种Handler中的方法进行调用。</p>
<p>⑤ Handler完成对用户请求的处理后，会返回一个ModelAndView对象给DispatcherServlet，ModelAndView顾名思义，包含了数据模型以及相应的视图的信息。</p>
<p>⑥ ModelAndView的视图是逻辑视图，DispatcherServlet还要借助ViewResolver完成从逻辑视图到真实视图对象的解析工作。</p>
<p>⑦ 当得到真正的视图对象后，DispatcherServlet会利用视图对象对模型数据进行渲染。</p>
<p>⑧ 客户端得到响应，可能是一个普通的HTML页面，也可以是XML或JSON字符串，还可以是一张图片或者一个PDF文件。</p>
<h6 id="Mybatis和Hibernate的区别"><a href="#Mybatis和Hibernate的区别" class="headerlink" title="Mybatis和Hibernate的区别"></a>Mybatis和Hibernate的区别</h6><p>1、简介</p>
<p>Hibernate：Hibernate是当前最流行的ORM框架之一，对JDBC提供了较为完整的封装。Hibernate的O/R Mapping实现了POJO 和数据库表之间的映射，以及SQL的自动生成和执行。</p>
<p>Mybatis：Mybatis同样也是非常流行的ORM框架，主要着力点在于 POJO 与 SQL 之间的映射关系。然后通过映射配置文件，将SQL所需的参数，以及返回的结果字段映射到指定 POJO 。相对Hibernate“O/R”而言，Mybatis 是一种“Sql Mapping”的ORM实现。</p>
<p>2、缓存机制对比</p>
<p>相同点</p>
<p>Hibernate和Mybatis的二级缓存除了采用系统默认的缓存机制外，都可以通过实现你自己的缓存或为其他第三方缓存方案，创建适配器来完全覆盖缓存行为。</p>
<p>不同点</p>
<p>Hibernate的二级缓存配置在SessionFactory生成的配置文件中进行详细配置，然后再在具体的表-对象映射中配置是那种缓存。</p>
<p>MyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。</p>
<p>两者比较</p>
<p>因为Hibernate对查询对象有着良好的管理机制，用户无需关心SQL。所以在使用二级缓存时如果出现脏数据，系统会报出错误并提示。而MyBatis在这一方面，使用二级缓存时需要特别小心。如果不能完全确定数据更新操作的波及范围，避免Cache的盲目使用。否则，脏数据的出现会给系统的正常运行带来很大的隐患。</p>
<p>Mybatis：小巧、方便、高效、简单、直接、半自动化。</p>
<p>Hibernate：强大、方便、高效、复杂、间接、全自动化。</p>
<h6 id="1分钟之内只能处理1000个请求，你怎么实现？"><a href="#1分钟之内只能处理1000个请求，你怎么实现？" class="headerlink" title="1分钟之内只能处理1000个请求，你怎么实现？"></a>1分钟之内只能处理1000个请求，你怎么实现？</h6><p>限流的几种放大：计数器，滑动窗口漏桶法，令牌桶</p>
<h6 id="JSP的静态包含和动态包含的区别"><a href="#JSP的静态包含和动态包含的区别" class="headerlink" title="JSP的静态包含和动态包含的区别"></a>JSP的静态包含和动态包含的区别</h6><p>静态包含是通过JSP的<code>&lt;%@include file=&quot;···&quot;&gt;</code> 指令包含页面，动态包含是通过JSP标准动作<code>&lt;jsp:include page=&quot;···&quot; flush=&quot;true&quot;&gt;</code>包含页面。</p>
<p>静态包含是编译时包含，如果包含的页面不存在则会产生编译错误，而且两个页面的”contentType”属性应保持一致，因为两个页面会合二为一，只产生一个class文件，因此被包含页面发生的变动再包含它的页面更新前不会得到更新。</p>
<p>动态包含是运行时包含，可以向被包含的页面传递参数，包含页面和被包含页面是独立的，会编译出两个class文件，如果被包含的页面不存在，不会产生编译错误，也不影响页面其他部分的执行。</p>
<p>静态包含<br><code>&lt;%@ include file=&quot;...&quot; %&gt;</code></p>
<p>动态包含</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;jsp:include page=<span class="string">&quot;...&quot;</span>&gt;</span><br><span class="line">&lt;jsp:param name=<span class="string">&quot;...&quot;</span> value=<span class="string">&quot;...&quot;</span> /&gt;</span><br><span class="line">&lt;/jsp:include&gt; </span><br></pre></td></tr></table></figure>

<h6 id="Request对象的主要方法"><a href="#Request对象的主要方法" class="headerlink" title="Request对象的主要方法"></a>Request对象的主要方法</h6><p>setAttribute(String name,Object)：设置名字为name的request的参数值</p>
<p>getAttribute(String name)：返回由name指定的属性值</p>
<p>getAttributeNames()：返回request对象所有属性的名字集合，结果是一个枚举的实例</p>
<p>getCookies()：返回客户端的所有Cookie对象，结果是一个Cookie数组</p>
<p>getCharacterEncoding()：返回请求中的字符编码方式</p>
<p>getContentLength()：返回请求的Body的长度</p>
<p>getHeader(String name)：获得HTTP协议定义的文件头信息</p>
<p>getHeaders(String name)：返回指定名字的request Header的所有值，结果是一个枚举的实例</p>
<p>getHeaderNames()：返回所以request Header的名字，结果是一个枚举的实例</p>
<p>getInputStream()：返回请求的输入流，用于获得请求中的数据</p>
<p>getMethod()：获得客户端向服务器端传送数据的方法</p>
<p>getParameter(String name)：获得客户端传送给服务器端的有name指定的参数值</p>
<p>getParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例</p>
<p>getParameterValues(String name)：获得有name指定的参数的所有值</p>
<p>getProtocol()：获取客户端向服务器端传送数据所依据的协议名称</p>
<p>getQueryString()：获得查询字符串</p>
<p>getRequestURI()：获取发出请求字符串的客户端地址</p>
<p>getRemoteAddr()：获取客户端的IP地址</p>
<p>getRemoteHost()：获取客户端的名字</p>
<p>getSession([Boolean create])：返回和请求相关Session</p>
<p>getServerName()：获取服务器的名字</p>
<p>getServletPath()：获取客户端所请求的脚本文件的路径</p>
<p>getServerPort()：获取服务器的端口号</p>
<p>removeAttribute(String name)：删除请求中的一个属性</p>
<h6 id="四种会话跟踪技术"><a href="#四种会话跟踪技术" class="headerlink" title="四种会话跟踪技术"></a>四种会话跟踪技术</h6><p>会话跟踪是一种灵活、轻便的机制，它使Web上的状态编程变为可能。</p>
<p>HTTP是一种无状态协议，每当用户发出请求时，服务器就会做出响应，客户端与服务器之间的联系是离散的、非连续的。</p>
<p>当用户在同一网站的多个页面之间转换时，根本无法确定是否是同一个客户，会话跟踪技术就可以解决这个问题。当一个客户在多个页面间切换时，服务器会保存该用户的信息。有四种方法可以实现会话跟踪技术：URL重写、隐藏表单域、Cookie、Session。</p>
<p>1）隐藏表单域：<input type="hidden">，非常适合步需要大量数据存储的会话应用。</p>
<p>2）URL 重写:URL 可以在后面附加参数，和服务器的请求一起发送，这些参数为名字/值对。</p>
<p>3）Cookie:一个 Cookie 是一个小的，已命名数据元素。服务器使用 SET-Cookie 头标将它作为 HTTP响应的一部分传送到客户端，客户端被请求保存 Cookie 值，在对同一服务器的后续请求使用一个Cookie 头标将之返回到服务器。与其它技术比较，Cookie 的一个优点是在浏览器会话结束后，甚至在客户端计算机重启后它仍可以保留其值。</p>
<p>4）Session：使用 setAttribute(String str,Object obj)方法将对象捆绑到一个会话</p>
<h6 id="web-xml文件中可以配置哪些内容？"><a href="#web-xml文件中可以配置哪些内容？" class="headerlink" title="web.xml文件中可以配置哪些内容？"></a>web.xml文件中可以配置哪些内容？</h6><p>web.xml用于配置Web应用的相关信息，如：监听器（listener）、过滤器（filter）、 Servlet、相关参数、会话超时时间、安全验证方式、错误页面等，下面是一些开发中常见的配置：</p>
<p>①配置Spring上下文加载监听器加载Spring配置文件并创建IoC容器：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">org.springframework.web.context.ContextLoaderListener</span><br><span class="line"><span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>②配置Spring的OpenSessionInView过滤器来解决延迟加载和Hibernate会话关闭的矛盾：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>openSessionInView<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span></span><br><span class="line">org.springframework.orm.hibernate3.support.OpenSessionInViewFilter</span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>openSessionInView<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>③配置会话超时时间为10分钟：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>10<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>④配置404和Exception的错误页面：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">location</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exception-type</span>&gt;</span>java.lang.Exception<span class="tag">&lt;/<span class="name">exception-type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">location</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>⑤配置安全认证方式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">security-constraint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-resource-collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-resource-name</span>&gt;</span>ProtectedArea<span class="tag">&lt;/<span class="name">web-resource-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/admin/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http-method</span>&gt;</span>GET<span class="tag">&lt;/<span class="name">http-method</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http-method</span>&gt;</span>POST<span class="tag">&lt;/<span class="name">http-method</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-resource-collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">auth-constraint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role-name</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">role-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">auth-constraint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">security-constraint</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">login-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">auth-method</span>&gt;</span>BASIC<span class="tag">&lt;/<span class="name">auth-method</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">login-config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">security-role</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role-name</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">role-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">security-role</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="Javaweb开发中的监听器的理解"><a href="#Javaweb开发中的监听器的理解" class="headerlink" title="Javaweb开发中的监听器的理解"></a>Javaweb开发中的监听器的理解</h6><p>Java Web开发中的监听器（listener）就是application、session、request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件，如下所示：</p>
<p>①ServletContextListener：对Servlet上下文的创建和销毁进行监听。</p>
<p>②ServletContextAttributeListener：监听Servlet上下文属性的添加、删除和替换。</p>
<p>③HttpSessionListener：对Session的创建和销毁进行监听。</p>
<p>session的销毁有两种情况：</p>
<p>1). session超时（可以在web.xml中通过<code>&lt;session-config&gt;/&lt;session-timeout&gt;</code>标签配置超时时间）；</p>
<p>2). 通过调用session对象的invalidate()方法使session失效。</p>
<p>④HttpSessionAttributeListener：对Session对象中属性的添加、删除和替换进行监听。</p>
<p>⑤ServletRequestListener：对请求对象的初始化和销毁进行监听。</p>
<p>⑥ServletRequestAttributeListener：对请求对象属性的添加、删除和替换进行监听。</p>
<h6 id="请问过滤器有哪些作用？以及过滤器的用法又是什么呢"><a href="#请问过滤器有哪些作用？以及过滤器的用法又是什么呢" class="headerlink" title="请问过滤器有哪些作用？以及过滤器的用法又是什么呢?"></a>请问过滤器有哪些作用？以及过滤器的用法又是什么呢?</h6><p>Java Web开发中的过滤器（filter）是从Servlet 2.3规范开始增加的功能，并在Servlet 2.4规范中得到增强。对Web应用来说，过滤器是一个驻留在服务器端的Web组件，它可以截取客户端和服务器之间的请求与响应信息，并对这些信息进行过滤。当Web容器接受到一个对资源的请求时，它将判断是否有过滤器与这个资源相关联。如果有，那么容器将把请求交给过滤器进行处理。在过滤器中，你可以改变请求的内容，或者重新设置请求的报头信息，然后再将请求发送给目标资源。当目标资源对请求作出响应时候，容器同样会将响应先转发给过滤器，在过滤器中你可以对响应的内容进行转换，然后再将响应发送到客户端。</p>
<p>常见的过滤器用途主要包括：对用户请求进行统一认证、对用户的访问请求进行记录和审核、对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求或响应进行加解密处理、触发资源访问事件、对XML的输出应用XSLT等。<br>和过滤器相关的接口主要有：Filter、FilterConfig和FilterChain。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面经四</title>
    <url>/2020/05/03/08/21/Java%E9%9D%A2%E7%BB%8F%E5%9B%9B/</url>
    <content><![CDATA[<p>Java面试总结四<a id="more"></a></p>
<h6 id="synchronized和java-util-concurrent-locks-lock的区别"><a href="#synchronized和java-util-concurrent-locks-lock的区别" class="headerlink" title="synchronized和java.util.concurrent.locks.lock的区别"></a>synchronized和java.util.concurrent.locks.lock的区别</h6><p>主要相同点：Lock能完成Synchronized所实现的所有功能。</p>
<p>主要不同点：Lock有比Synchronized更精确的线程予以和更好的性能。Synchronized会自动释放锁，但是Lock一定要求程序员手工释放，并且必须在finally从句中释放。</p>
<p>synchronized 修饰方法时，表示同一个对象在不同的线程中表现为同步队列。</p>
<h6 id="如何确保N个线程可以访问N个资源，但同时又不导致死锁？"><a href="#如何确保N个线程可以访问N个资源，但同时又不导致死锁？" class="headerlink" title="如何确保N个线程可以访问N个资源，但同时又不导致死锁？"></a>如何确保N个线程可以访问N个资源，但同时又不导致死锁？</h6><p>使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。</p>
<p>预防死锁，预先破坏产生死锁的四个条件。互斥不可能破坏，所以有如下三种方法：</p>
<p>1.破坏请求和保持条件，进程必须等所有要请求的资源都空闲时才能申请资源，这种方法会使资源浪费严重(有些资源可能仅在运行初期或结束时才使用，甚至根本不使用)。允许进程获取初期所需资源后，便开始运行，运行过程中再逐步释放自己占有的资源，比如有一个进程的任务是把数据复制到磁盘中再打印，前期只需获得磁盘资源而不需要获得打印机资源，待复制完毕后再释放掉磁盘资源。这种方法比第一种方法好，会使资源利用率上升。</p>
<p>2.破坏不可抢占条件，这种方法代价大，实现复杂。</p>
<p>3.破坏循坏等待条件，对各进程请求资源的顺序做一个规定，避免相互等待。这种方法对资源的利用率比前两种都高，但是前期要为设备指定序号，新设备加入会有一个问题，其次对用户编程也有限制。</p>
<h6 id="锁和同步的区别"><a href="#锁和同步的区别" class="headerlink" title="锁和同步的区别"></a>锁和同步的区别</h6><ol>
<li><p>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现，synchronized是在JVM层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，JVM会自动释放锁定，但是使用Lock则不行，lock是通过代码实现的，要保证锁定一定会被释放，就必须将 unLock()放到finally{} 中；</p>
</li>
<li><p>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</p>
</li>
<li><p>Lock可以让等待锁的线程响应中断，线程可以中断去干别的事务，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</p>
</li>
<li><p>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到;</p>
</li>
<li><p>Lock可以提高多个线程进行读操作的效率。</p>
<p> 在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p>
</li>
</ol>
<h6 id="jdk和jre的区别"><a href="#jdk和jre的区别" class="headerlink" title="jdk和jre的区别"></a>jdk和jre的区别</h6><p>Java运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。</p>
<h6 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h6><p>Java内存模型(简称JMM)，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。</p>
<p>本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。其关系模型图如下图所示：</p>
<p><img src="/2020/05/03/08/21/Java%E9%9D%A2%E7%BB%8F%E5%9B%9B/jvm.png" alt></p>
<h6 id="JVM分区"><a href="#JVM分区" class="headerlink" title="JVM分区"></a>JVM分区</h6><p>java内存通常被划分为5个区域：程序计数器（Program Count Register）、本地方法栈（Native Stack）、方法区（Methon Area）、栈（Stack）、堆（Heap）。</p>
<p><img src="/2020/05/03/08/21/Java%E9%9D%A2%E7%BB%8F%E5%9B%9B/JVM%E5%88%86%E5%8C%BA.png" alt></p>
<h6 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h6><p>如下图所示，JVM类加载机制分为五个部分：加载，验证，准备，解析，初始化，下面我们就分别来看一下这五个过程。</p>
<p><img src="/2020/05/03/08/21/Java%E9%9D%A2%E7%BB%8F%E5%9B%9B/loading.png" alt></p>
<p><strong>加载</strong></p>
<p>加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个Class文件获取，这里既可以从ZIP包中读取（比如从jar包和war包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将JSP文件转换成对应的Class类）。</p>
<p><strong>验证</strong></p>
<p>这一阶段的主要目的是为了确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p><strong>准备</strong></p>
<p>准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为： <code>public static int v = 8080;</code>实际上变量v在准备阶段过后的初始值为0而不是8080，将v赋值为8080的putstatic指令是程序被编译后，存放于类构造器<client>方法之中。但是注意如果声明为：<code>public static final int v = 8080;</code>在编译阶段会为v生成ConstantValue属性，在准备阶段虚拟机会根据ConstantValue属性将v赋值为8080。</client></p>
<p><strong>解析</strong></p>
<p>解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是class文件中的：<code>CONSTANT_Class_info</code>、<code>CONSTANT_Field_info</code>、<code>CONSTANT_Method_info</code>等类型的常量。</p>
<p><strong>初始化</strong></p>
<p>初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由JVM主导。到了初始阶段，才开始真正执行类中定义的Java程序代码。</p>
<p>初始化阶段是执行类构造器<client>方法的过程。<client>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证<client>方法执行之前，父类的<client>方法已经执行完毕。p.s: 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<client>()方法。</client></client></client></client></client></p>
<p>注意以下几种情况不会执行类初始化：</p>
<ul>
<li><p>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。</p>
</li>
<li><p>定义对象数组，不会触发该类的初始化。</p>
</li>
<li><p>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。</p>
</li>
<li><p>通过类名获取Class对象，不会触发类的初始化。</p>
</li>
<li><p>通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。</p>
</li>
<li><p>通过ClassLoader默认的loadClass方法，也不会触发初始化动作。</p>
</li>
</ul>
<h6 id="Spring生命周期流程图"><a href="#Spring生命周期流程图" class="headerlink" title="Spring生命周期流程图"></a>Spring生命周期流程图</h6><p><img src="/2020/05/03/08/21/Java%E9%9D%A2%E7%BB%8F%E5%9B%9B/spring.png" alt></p>
<h6 id="什么是IoC和DI？简要说明一下DI是如何实现的？"><a href="#什么是IoC和DI？简要说明一下DI是如何实现的？" class="headerlink" title="什么是IoC和DI？简要说明一下DI是如何实现的？"></a>什么是IoC和DI？简要说明一下DI是如何实现的？</h6><p>IoC叫控制反转，是Inversion of Control的缩写，DI（Dependency Injection）叫依赖注入，是对IoC更简单的诠释。控制反转是把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的”控制反转”就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。IoC体现了好莱坞原则 - “Don’t call me, we will call you”。依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成。DI是对IoC更准确的描述，即组件之间的依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。</p>
<p>一个类A需要用到接口B中的方法，那么就需要为类A和接口B建立关联或依赖关系，最原始的方法是在类A中创建一个接口B的实现类C的实例，但这种方法需要开发人员自行维护二者的依赖关系，也就是说当依赖关系发生变动的时候需要修改代码并重新构建整个系统。如果通过一个容器来管理这些对象以及对象的依赖关系，则只需要在类A中定义好用于关联接口B的方法（构造器或setter方法），将类A和接口B的实现类C放入容器中，通过对容器的配置来实现二者的关联。<br>依赖注入可以通过setter方法注入（设值注入）、构造器注入和接口注入三种方式来实现，Spring支持setter注入和构造器注入，通常使用构造器注入来注入必须的依赖关系，对于可选的依赖关系，则setter注入是更好的选择，setter注入需要类提供无参构造器或者无参的静态工厂方法来创建对象。</p>
<h6 id="Spring中自动装配的方式有哪些？"><a href="#Spring中自动装配的方式有哪些？" class="headerlink" title="Spring中自动装配的方式有哪些？"></a>Spring中自动装配的方式有哪些？</h6><ul>
<li>no：不进行自动装配，手动设置Bean的依赖关系；</li>
<li>byName：根据Bean的名字进行自动装配；</li>
<li>byType：根据Bean的类型进行自动装配；</li>
<li>constructor：类似于byType，不过是应用于构造器的参数，如果正好有一个Bean与构造器的参数类型相同则可以自动装配，否则会导致错误；</li>
<li>autodetect：如果有默认的构造器，则通过constructor的方式进行自动装配，否则使用byType的方式进行自动装配；</li>
</ul>
<p>自动装配没有自定义装配方式那么精确，而且不能自动装配简单属性（基本类型、字符串等），在使用时应注意。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux程序自启动</title>
    <url>/2019/11/22/09/39/Linux%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<p>在Linux系统如何让程序开机时自动启动<a id="more"></a></p>
<p><img src="/2019/11/22/09/39/Linux%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%90%AF%E5%8A%A8/linuxicon.jpg" alt></p>
<h5 id="修改启动配置文件"><a href="#修改启动配置文件" class="headerlink" title="修改启动配置文件"></a>修改启动配置文件</h5><p>新建一个sh后缀的脚本文件（例如:stratup.sh），把你所要启动的命令编写进去。然后再编辑“<strong>/etc/rc.local</strong>”启动配置文件，把<strong>脚本文件所在位置的全路径</strong>输入进去即可。</p>
<h5 id="计划定时启动"><a href="#计划定时启动" class="headerlink" title="计划定时启动"></a>计划定时启动</h5><p>通过crontab可以设定程序的执行时间表， 例如让程序在每天的9点，或者每个星期一的9点执行一次。 </p>
<p>crontab -l 列出时间表；<br>crontab -e编辑时间表；<br>crontab -d删除时间表；</p>
<p>“-l”查看时间表；<br>“-e”是编辑（其实就是用vim编辑一个特定文件）；<br>“-d”删除，把该用户所有的时间表都删除，一般都是用“-e”编辑把不要了的时间表逐行删除；</p>
<p>crontab文件的格式是：M H D m d CMD。<br>一个6个字段，其中最后一个CMD就是所要执行的程序，如haha.sh。<br>M：分钟（0-59）<br>H：小时（0-23）<br>D：日期（1-31）<br>m：月份（1-12）<br>d：一个星期中的某天（0-6，0代表周日）</p>
<p>这5个时间字段用空格隔开，其值可以是一个数字，也可以用逗号隔开的多个数字（或其他） ，如果不需设置，则默认为“*”。</p>
<p>例如，每天的9点0分执行startup.sh，就是“0 9 * * * /home/programs/./startup.sh”。</p>
<h5 id="注册系统服务"><a href="#注册系统服务" class="headerlink" title="注册系统服务"></a>注册系统服务</h5><p>操作系统自带的服务，如ssh，ftp等等，开机都是自动启动的，我们也可以通过这种方式让自己开发的程序伪装成系统服务。</p>
<p>比如我想把某个程序添加为系统服务，可以执行以下命令：</p>
<p>chkconfig –add 程序名称(首先，添加为系统服务，<strong>注意add前面是两个横杠</strong>)</p>
<p>chkconfig -leve 启动级别 服务名 on     </p>
<p>（说明，3级别代表在命令行模式启动，5级别代表在图形界面启动，on表示开启）</p>
<p>chkconfig -leve 启动级别 服务名 off（说明，off表示关闭自启动）</p>
<p>例如：chkconfig -level 3 mysql on  (说明：让mysql服务在命令行模式，随系统启动)</p>
<p>也可以使用  chkconfig –del 服务名称  来删除系统服务</p>
<p>如果要查看哪些服务被添加为系统服务可以使用命令 ：</p>
<p>  ntsysv 或者chkconfig –list</p>
<p>如果要查看哪些程序被添加为自启动，可以使用命令 ：</p>
<p>cat  /etc/rc.local（查看这个文件中添加了哪些程序路径）</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统下MongoDB的安装与配置</title>
    <url>/2019/11/29/20/27/Linux%E7%B3%BB%E7%BB%9F%E4%B8%8BMongoDB%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>最简便的安装教程<a id="more"></a></p>
<h5 id="一键安装MongoDB数据库"><a href="#一键安装MongoDB数据库" class="headerlink" title="一键安装MongoDB数据库"></a>一键安装MongoDB数据库</h5><p>使用wget命令在线一键安装MongoDB数据库，并配置密码123456。</p>
<p><code>注意：不要在 / 目录下运行</code></p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">wget -c http:<span class="string">//mirrors.linuxeye.com/oneinstack-full.tar.gz</span> &amp;&amp; tar xzf oneinstack-full.tar.gz &amp;&amp; <span class="string">./oneinstack/install.sh</span> <span class="params">--db_option</span> 15 <span class="params">--dbinstallmethod</span> 1 <span class="params">--dbrootpwd</span> 123456 <span class="params">--reboot</span></span><br></pre></td></tr></table></figure>

<p>安装时间较长，请耐心等待。</p>
<p>如果没有找到wget命令，就使用下列命令安装wget:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">yum -y <span class="keyword">install</span> wget</span><br></pre></td></tr></table></figure>

<h5 id="验证超级管理员账户"><a href="#验证超级管理员账户" class="headerlink" title="验证超级管理员账户"></a>验证超级管理员账户</h5><p>重新进入服务器后，在窗口中输入 <em>mongo</em> ，进入数据库。</p>
<p>输入 <em>db</em> ，默认是在test数据库下，输入 <em>use admin</em> ，进入 <em>admin</em> 数据库。然后再输入<em>db.auth(‘root’,’123456’)</em>，返回1表示验证成功。注意：这个账户密码就是刚刚安装数据库时设置的。</p>
<h5 id="创建新数据库并配置"><a href="#创建新数据库并配置" class="headerlink" title="创建新数据库并配置"></a>创建新数据库并配置</h5><p>输入<em>use newDatabase</em>，进入新的数据库，然后输入</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.createUser</span>(&#123;<span class="attribute">user</span>: <span class="string">&quot;username&quot;</span>, <span class="attribute">pwd</span>: <span class="string">&quot;password&quot;</span>, <span class="attribute">roles</span>: [&#123; <span class="attribute">role</span>: <span class="string">&quot;dbOwner&quot;</span>, <span class="attribute">db</span>: <span class="string">&quot;newDatabase&quot;</span> &#125;]&#125;)</span><br></pre></td></tr></table></figure>

<p>username和password分别对应自己设定的账户和密码，db后的集合名一定要和use的名称一致。每创建一个数据库都要进行授权，否则无法访问。</p>
<h5 id="MongoDB参数配置"><a href="#MongoDB参数配置" class="headerlink" title="MongoDB参数配置"></a>MongoDB参数配置</h5><p>进入到/usr/local/mongodb文件夹，创建data、log目录和mongo.conf文件，用来存储数据及日志文件，其中log目录下创建mongodb.log文件。mongodb.conf文件内用vim写入下列命令：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">port</span>=<span class="number">27017</span> <span class="comment">#端口</span></span><br><span class="line"><span class="attr">dbpath</span>= /programs/mongodb/data <span class="comment">#数据库存文件存放目录</span></span><br><span class="line"><span class="attr">logpath</span>= /programs/mongodb/log/mongodb.log <span class="comment">#日志文件存放路径</span></span><br><span class="line"><span class="attr">logappend</span>=<span class="literal">true</span> <span class="comment">#使用追加的方式写日志</span></span><br><span class="line"><span class="attr">fork</span>=<span class="literal">true</span> <span class="comment">#以守护进程的方式运行，创建服务器进程</span></span><br><span class="line"><span class="attr">maxConns</span>=<span class="number">100</span> <span class="comment">#最大同时连接数</span></span><br><span class="line"><span class="attr">auth</span>=<span class="literal">true</span> <span class="comment">#启用验证</span></span><br><span class="line"><span class="attr">journal</span>=<span class="literal">true</span> <span class="comment">#每次写入会记录一条操作日志（通过journal可以重新构造出写入的数据）。</span></span><br><span class="line"><span class="comment">#即使宕机，启动时wiredtiger会先将数据恢复到最近一次的checkpoint点，然后重放后续的journal日志来恢复。</span></span><br><span class="line"><span class="attr">storageEngine</span>=wiredTiger  <span class="comment">#存储引擎有mmapv1、wiretiger、mongorocks</span></span><br><span class="line"><span class="attr">bind_ip</span> = <span class="number">0.0</span>.<span class="number">0.0</span>  <span class="comment">#这样就可外部访问了，例如从win10中去连虚拟机中的MongoDB</span></span><br></pre></td></tr></table></figure>

<h5 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h5><p>输入下列命令便可以直接在/etc/rc.local文件中写入mongodb services用于开机自启动：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">echo <span class="string">&quot;/usr/local/mongodb/bin/mongod --dbpath=/usr/local/mongodb/data -logpath=/usr/local/mongodb/log -logappend --auth --port=27017&quot;</span> &gt;&gt; <span class="regexp">/etc/</span>rc.local</span><br></pre></td></tr></table></figure>

<p>配置参数含义</p>
<table>
<thead>
<tr>
<th>–quiet</th>
<th align="left">安静输出</th>
</tr>
</thead>
<tbody><tr>
<td>–port arg</td>
<td align="left">指定服务端口号，默认端口27017</td>
</tr>
<tr>
<td>–bind_ip arg</td>
<td align="left">绑定服务IP，若绑定127.0.0.1，则只能本机访问，不指定默认本地所有IP</td>
</tr>
<tr>
<td>–logpath arg</td>
<td align="left">指定MongoDB日志文件，注意是指定文件不是目录</td>
</tr>
<tr>
<td>–logappend</td>
<td align="left">使用追加的方式写日志</td>
</tr>
<tr>
<td>–pidfilepath arg</td>
<td align="left">PID File 的完整路径，如果没有设置，则没有PID文件</td>
</tr>
<tr>
<td>–keyFile arg</td>
<td align="left">集群的私钥的完整路径，只对于Replica Set 架构有效</td>
</tr>
<tr>
<td>–unixSocketPrefix arg</td>
<td align="left">UNIX域套接字替代目录,(默认为 /tmp)</td>
</tr>
<tr>
<td>–fork</td>
<td align="left">以守护进程的方式运行MongoDB，创建服务器进程</td>
</tr>
<tr>
<td>–auth</td>
<td align="left">启用验证</td>
</tr>
<tr>
<td>–cpu</td>
<td align="left">定期显示CPU的CPU利用率和iowait</td>
</tr>
<tr>
<td>–dbpath arg</td>
<td align="left">指定数据库路径</td>
</tr>
<tr>
<td>–diaglog arg</td>
<td align="left">diaglog选项 0=off 1=W 2=R 3=both 7=W+some reads</td>
</tr>
<tr>
<td>–directoryperdb</td>
<td align="left">设置每个数据库将被保存在一个单独的目录</td>
</tr>
<tr>
<td>–journal</td>
<td align="left">启用日志选项，MongoDB的数据操作将会写入到journal文件夹的文件里</td>
</tr>
<tr>
<td>–journalOptions arg</td>
<td align="left">启用日志诊断选项</td>
</tr>
<tr>
<td>–ipv6</td>
<td align="left">启用IPv6选项</td>
</tr>
<tr>
<td>–jsonp</td>
<td align="left">允许JSONP形式通过HTTP访问（有安全影响）</td>
</tr>
<tr>
<td>–maxConns arg</td>
<td align="left">最大同时连接数 默认2000</td>
</tr>
<tr>
<td>–noauth</td>
<td align="left">不启用验证</td>
</tr>
<tr>
<td>–nohttpinterface</td>
<td align="left">关闭http接口，默认关闭27018端口访问</td>
</tr>
<tr>
<td>–noprealloc</td>
<td align="left">禁用数据文件预分配(往往影响性能)</td>
</tr>
<tr>
<td>–noscripting</td>
<td align="left">禁用脚本引擎</td>
</tr>
<tr>
<td>–notablescan</td>
<td align="left">不允许表扫描</td>
</tr>
<tr>
<td>–nounixsocket</td>
<td align="left">禁用Unix套接字监听</td>
</tr>
<tr>
<td>–nssize arg (=16)</td>
<td align="left">设置信数据库.ns文件大小(MB)</td>
</tr>
<tr>
<td>–objcheck</td>
<td align="left">在收到客户数据,检查的有效性，</td>
</tr>
<tr>
<td>–profile arg</td>
<td align="left">档案参数 0=off 1=slow, 2=all</td>
</tr>
<tr>
<td>–quota</td>
<td align="left">限制每个数据库的文件数，设置默认为8</td>
</tr>
<tr>
<td>–quotaFiles arg</td>
<td align="left">number of files allower per db, requires –quota</td>
</tr>
<tr>
<td>–rest</td>
<td align="left">开启简单的rest API</td>
</tr>
<tr>
<td>–repair</td>
<td align="left">修复所有数据库run repair on all dbs</td>
</tr>
<tr>
<td>–repairpath arg</td>
<td align="left">修复库生成的文件的目录,默认为目录名称dbpath</td>
</tr>
<tr>
<td>–slowms arg (=100)</td>
<td align="left">value of slow for profile and console log</td>
</tr>
<tr>
<td>–smallfiles</td>
<td align="left">使用较小的默认文件</td>
</tr>
<tr>
<td>–syncdelay arg (=60)</td>
<td align="left">数据写入磁盘的时间秒数(0=never,不推荐)</td>
</tr>
<tr>
<td>–sysinfo</td>
<td align="left">打印一些诊断系统信息</td>
</tr>
<tr>
<td>–upgrade</td>
<td align="left">如果需要升级数据库</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统防火墙指令</title>
    <url>/2020/01/16/08/51/Linux%E7%B3%BB%E7%BB%9F%E9%98%B2%E7%81%AB%E5%A2%99%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>本文以CentOS 7为例。<a id="more"></a></p>
<h5 id="防火墙常用操作"><a href="#防火墙常用操作" class="headerlink" title="防火墙常用操作"></a>防火墙常用操作</h5><p>开启防火墙</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> firewalld.service</span><br></pre></td></tr></table></figure>

<p>关闭防火墙</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">stop</span> firewalld.service</span><br></pre></td></tr></table></figure>

<p>开机自启动</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">systemctl <span class="builtin-name">enable</span> firewalld.service</span><br></pre></td></tr></table></figure>

<p>关闭开机自启动</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">systemctl</span> <span class="selector-tag">disabel</span> <span class="selector-tag">firewalld</span><span class="selector-class">.service</span></span><br></pre></td></tr></table></figure>

<p>查看开放的端口</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">firewall-<span class="keyword">cmd</span><span class="bash"> --list-all</span></span><br><span class="line">or</span><br><span class="line">firewall-<span class="keyword">cmd</span><span class="bash"> --list-ports</span></span><br></pre></td></tr></table></figure>

<p>添加永久开放端口</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">firewall-cmd <span class="attribute">--zone</span>=public <span class="attribute">--add-port</span>=3306/tcp --permanent</span><br></pre></td></tr></table></figure>

<p>移除开放端口</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">firewall</span><span class="literal">-</span><span class="comment">cmd</span> --<span class="comment">remove</span><span class="literal">-</span><span class="comment">port=3306/tcp</span> --<span class="comment">permanent</span></span><br></pre></td></tr></table></figure>

<p>重启防火墙生效</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">firewall-<span class="keyword">cmd</span><span class="bash"> --reload</span></span><br></pre></td></tr></table></figure>

<p>查看规则</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">iptables -L -n</span></span><br></pre></td></tr></table></figure>

<p>查看开放的服务</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">firewall-<span class="keyword">cmd</span><span class="bash"> --list-services</span></span><br></pre></td></tr></table></figure>

<p>查看防火墙状态</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">firewall-<span class="keyword">cmd</span><span class="bash"> --state</span></span><br></pre></td></tr></table></figure>

<h5 id="伪装IP"><a href="#伪装IP" class="headerlink" title="伪装IP"></a>伪装IP</h5><p>检查是否允许伪装IP</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">firewall-<span class="keyword">cmd</span><span class="bash"> --query-masquerade</span></span><br></pre></td></tr></table></figure>

<p>允许防火墙伪装IP</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">firewall-<span class="keyword">cmd</span><span class="bash"> --add-masquerade</span></span><br></pre></td></tr></table></figure>

<p>禁止防火墙伪装IP</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">firewall-<span class="keyword">cmd</span><span class="bash"> --remove-masquerade</span></span><br></pre></td></tr></table></figure>

<h5 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h5><p>转发的目的不指定 IP 的话就默认为本机，如果指定了 IP 却没指定端口，则默认使用来源端口。如果配置好端口转发之后不能用，可以检查以下两个方面的问题：</p>
<ol>
<li>比如我将 80 端口转发至 8080 端口，首先检查本地的 80 端口和目标的 8080 端口是否开放监听了（也就是监听程序是否运行了）；</li>
<li>检查是否允许伪装 IP，没允许的话要开启伪装 IP。</li>
</ol>
<p>添加映射</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-forward-port=proto=<span class="number">80</span>:proto=tcp:toaddr=<span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>:toport=<span class="number">8080</span></span><br></pre></td></tr></table></figure>

<p>删除映射</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">firewall-cmd --remove-forward-port=proto=<span class="number">80</span>:proto=tcp:toaddr=<span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>:toport=<span class="number">8080</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MQTT的回调类</title>
    <url>/2019/11/21/09/42/MQTT%E7%9A%84%E5%9B%9E%E8%B0%83%E7%B1%BB/</url>
    <content><![CDATA[<p>关于MQTT的回调类的实现<a id="more"></a></p>
<h5 id="在使用回调方式前，先通过MQTT获取回调链接"><a href="#在使用回调方式前，先通过MQTT获取回调链接" class="headerlink" title="在使用回调方式前，先通过MQTT获取回调链接"></a>在使用回调方式前，先通过MQTT获取回调链接</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MQTT mqtt = <span class="keyword">new</span> MQTT();</span><br><span class="line"></span><br><span class="line"><span class="comment">//此处省略设置MQTT的属性</span></span><br><span class="line"></span><br><span class="line">CallbackConnection connection = mqtt.callbackConnection();</span><br></pre></td></tr></table></figure>

<h5 id="调用CallbackConnection的方法实现业务逻辑"><a href="#调用CallbackConnection的方法实现业务逻辑" class="headerlink" title="调用CallbackConnection的方法实现业务逻辑"></a>调用CallbackConnection的方法实现业务逻辑</h5><h6 id="connect-连接方法-："><a href="#connect-连接方法-：" class="headerlink" title="connect(连接方法)："></a>connect(连接方法)：</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">connection.connect(<span class="keyword">new</span> Callback&lt;Void&gt;() &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Void arg0)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//进入该方法表示连接成功连接成功</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable value)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//进入该方法表示连接失败</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>一般可以在connect的onSuccess方法中发布(publish)和订阅(subscribe)相应的主题(topic)，在其onError方法中作相应的断开连接等操作。</p>
<h6 id="listener-监听方法"><a href="#listener-监听方法" class="headerlink" title="listener(监听方法):"></a>listener(监听方法):</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">connection.listener(<span class="keyword">new</span> Listener() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPublish</span><span class="params">(UTF8Buffer topicmsg, Buffer msg, Runnable ack)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//utf-8 is used for dealing with the garbled</span></span><br><span class="line">		<span class="comment">//String topic = topicmsg.utf8().toString();</span></span><br><span class="line">		<span class="comment">//String payload = msg.utf8().toString();</span></span><br><span class="line">		<span class="comment">//表示监听成功</span></span><br><span class="line">		ack.run();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable value)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//表示监听失败</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//execute only once when connection is ended</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDisconnected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		/表示监听到断开连接</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//execute only once when connecting started</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConnected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//表示监听到连接成功</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>onpublish表示发布成功，可以获取到订阅的主题(topic)和订阅的内容(UTF8Buffer topicmsg 表示订阅的主题,Buffer msg表示订阅的内容)，一般的可以在这个方法中获取订阅的主题和内容然后进行相应的判断和其他业务逻辑操作；</p>
<p>onConneted表示监听到连接建立，该方法只在建立连接成功时执行一次，表示连接成功建立，如果有必要可以在该方法中进行相应的订阅操作； </p>
<p> onDisconnected表示监听到连接断开，该方法只在断开连接时执行一次，如有必要可以进行相应的资源回收操作。 </p>
<h6 id="subscirbe-订阅方法"><a href="#subscirbe-订阅方法" class="headerlink" title="subscirbe(订阅方法):"></a>subscirbe(订阅方法):</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">connection.subscribe(topics, <span class="keyword">new</span> Callback&lt;<span class="keyword">byte</span>[]&gt;() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">byte</span>[] qoses)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//主题订阅成功</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable value)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//状态主题订阅失败</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p> onSuccess方法表示订阅成功，onError方法表示订阅失败；方法中Topic[] topics表示定于的主题数组，注意只有在改方法订阅的主题时，才能够在监听方法中接收到。 </p>
<h6 id="publish-发布主题-topic-方法"><a href="#publish-发布主题-topic-方法" class="headerlink" title="publish(发布主题(topic)方法):"></a>publish(发布主题(topic)方法):</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">connection.publish(topic, payload.getBytes(), qos, retain, <span class="keyword">new</span> Callback&lt;Void&gt;() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Void arg0)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//表示发布主题成功</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//表示发布主题失败</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p> publish方法用于发布响应的主题，以便订阅者订阅；onSuccess表示发布成功，onError表示发布失败。 </p>
<h6 id="disconnect-断开连接方法"><a href="#disconnect-断开连接方法" class="headerlink" title="disconnect(断开连接方法):"></a>disconnect(断开连接方法):</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">connection.disconnect(<span class="keyword">new</span> Callback&lt;Void&gt;() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Void arg0)</span> </span>&#123;</span><br><span class="line">			<span class="comment">//与服务器断开连接成功</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable arg0)</span> </span>&#123;</span><br><span class="line">			<span class="comment">//与服务器断开连接失败</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p> disconnect表示断开与代理服务器的连接，调用该方法后只是表示断开连接但是实际的connect依然存在并没有为null，再次调用connect方法又能够连接成功。 </p>
<p>注意：</p>
<p>1、在上面的五个方法中一般先调用connect和listener方法</p>
<p>2、回调将执行与连接相关联的调度队列，以便可以安全使用从回调的连接，但你绝不能在回调中执行任何阻塞操作，否则会改变执行的顺序，这样可能出错。如果可能存在阻塞时，最好是在连接的调度队列中执行另外一个线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">connection.getDispatchQueue().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//在这里进行相应的订阅、发布、停止连接等等操作			</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="http://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/152377/156838966242265_zh-CN.png" alt="MQTT应用场景" title="MQTT应用场景"></p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql数据库优化的八种方法</title>
    <url>/2020/05/22/19/44/MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E7%9A%84%E5%85%AB%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>新建数据库的时候考虑优化问题就能解决很多不必要的麻烦。<a id="more"></a></p>
<h5 id="选取最适用的字段属性"><a href="#选取最适用的字段属性" class="headerlink" title="选取最适用的字段属性"></a>选取最适用的字段属性</h5><p>MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。</p>
<p>例如，在定义邮政编码这个字段时，如果将其设置为CHAR(255),显然给数据库增加了不必要的空间，甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段。</p>
<p>另外一个提高效率的方法是在可能的情况下，应该尽量把字段设置为<strong>NOT NULL</strong>，这样在将来执行查询的时候，数据库不用去比较NULL值。</p>
<p>对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。</p>
<h5 id="使用连接-JOIN-来代替子查询-Sub-Queries"><a href="#使用连接-JOIN-来代替子查询-Sub-Queries" class="headerlink" title="使用连接(JOIN)来代替子查询(Sub-Queries)"></a>使用连接(JOIN)来代替子查询(Sub-Queries)</h5><p>MySQL从4.1开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。例如，我们要将客户基本信息表中没有任何订单的客户删除掉，就可以利用子查询先从销售信息表中将所有发出订单的客户ID取出来，然后将结果传递给主查询，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM customerinfo</span><br><span class="line"></span><br><span class="line">WHERE CustomerID NOT in (SELECT customerid FROM salesinfo)</span><br></pre></td></tr></table></figure>

<p>使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接（JOIN）替代。例如，我们要将所有没有订单记录的用户取出来，可以用下面这个查询完成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM customerinfo</span><br><span class="line"></span><br><span class="line">WHERE customerid NOT IN (SELECT customerid FROM salesinfo)</span><br></pre></td></tr></table></figure>

<p>如果使用连接（JOIN）来完成这个查询工作，速度将会快很多。尤其是当salesinfo表中对CustomerID建有索引的话，性能将会更好，查询如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM customerinfo LEFT JOIN salesinfo </span><br><span class="line"></span><br><span class="line">ON customerinfo.customerid &#x3D; salesinfo.customerid</span><br><span class="line"></span><br><span class="line">WHERE salesinfo.customerid IS NULL</span><br></pre></td></tr></table></figure>

<p>连接（JOIN）之所以更有效率一些，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。</p>
<h5 id="使用联合-UNION-来代替手动创建的临时表"><a href="#使用联合-UNION-来代替手动创建的临时表" class="headerlink" title="使用联合(UNION)来代替手动创建的临时表"></a>使用联合(UNION)来代替手动创建的临时表</h5><p>MySQL从4.0的版本开始支持union查询，它可以把需要使用临时表的两条或更多的select查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。使用union来创建查询的时候，我们只需要用<strong>UNION</strong>作为关键字把多个select语句连接起来就可以了，要注意的是<strong>所有select语句中的字段数目要相同</strong>。下面的例子就演示了一个使用UNION的查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT name,phone FROM client UNION</span><br><span class="line"></span><br><span class="line">SELECT name,birthdate FROM author UNION</span><br><span class="line"></span><br><span class="line">SELECT name,supplier FROM product</span><br></pre></td></tr></table></figure>

<h5 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h5><p>尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样的查询，但不是所有的数据库操作都可以只用一条或少数几条SQL语句就可以完成的，更多的时候是需要用到一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来。设想一下，要把某个数据同时插入两个相关联的表中，可能会出现这样的情况：第一个表中成功更新后，数据库突然出现意外状况，造成第二个表中的操作没有完成，这样，就会造成数据的不完整，甚至会破坏数据库中的数据。要避免这种情况，就应该使用事务，它的作用是：要么语句块中每条语句都操作成功，要么都失败。换句话说，就是可以保持数据库中数据的一致性和完整性。事物以<strong>BEGIN</strong>关键字开始，<strong>COMMIT</strong>关键字结束。在这之间的一条SQL操作失败，那么，<strong>ROLLBACK</strong>命令就可以把数据库恢复到BEGIN开始之前的状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">  INSERT INTO salesinfo SET customerid&#x3D;14;</span><br><span class="line">  UPDATE inventory SET quantity &#x3D;11 WHERE item&#x3D;&#39;book&#39;;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<p>事务的另一个重要作用是当多个用户同时使用相同的数据源时，它可以利用锁定数据库的方法来为用户提供一种安全的访问方式，这样可以保证用户的操作不被其它的用户所干扰。</p>
<h5 id="锁定表"><a href="#锁定表" class="headerlink" title="锁定表"></a>锁定表</h5><p>尽管事务是维护数据库完整性的一个非常好的方法，但却因为它的独占性，有时会影响数据库的性能，尤其是在很大的应用系统中。由于在事务执行的过程中，数据库将会被锁定，因此其它的用户请求只能暂时等待直到该事务结束。如果一个数据库系统只有少数几个用户来使用，事务造成的影响不会成为一个太大的问题；但假设有成千上万的用户同时访问一个数据库系统，例如访问一个电子商务网站，就会产生比较严重的响应延迟。</p>
<p>其实，有些情况下我们可以通过锁定表的方法来获得更好的性能。下面的例子就用锁定表的方法来完成前面一个例子中事务的功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOCK TABLE inventory WRITE SELECT quantity FROM inventory WHERE Item&#x3D;&#39;book&#39;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">UPDATE inventory SET Quantity&#x3D;11 WHERE Item&#x3D;&#39;book&#39;;UNLOCKTABLES</span><br></pre></td></tr></table></figure>

<p>这里，我们用一个select语句取出初始数据，通过一些计算，用update语句将新值更新到表中。包含有WRITE关键字的LOCKTABLE语句可以保证在UNLOCKTABLES命令被执行之前，不会有其它的访问来对inventory进行插入、更新或者删除的操作。</p>
<h5 id="使用外键"><a href="#使用外键" class="headerlink" title="使用外键"></a>使用外键</h5><p>锁定表的方法可以维护数据的完整性，但是它却不能保证数据的关联性。这个时候我们就可以使用外键。</p>
<p>例如，外键可以保证每一条销售记录都指向某一个存在的客户。在这里，外键可以把customerinfo表中的customerid映射到salesinfo表中customerid，任何一条没有合法customerid的记录都不会被更新或插入到salesinfo中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE customerinfo( customerid int primary key) engine &#x3D; innodb;</span><br><span class="line"></span><br><span class="line">CREATE TABLE salesinfo( salesid int not null,customerid int not null, primary key(customerid,salesid),foreign key(customerid) references  customerinfo(customerid) on delete cascade)engine &#x3D; innodb;</span><br></pre></td></tr></table></figure>

<p>注意例子中的参数“on delete cascade”。该参数保证当customerinfo表中的一条客户记录被删除的时候，salesinfo表中所有与该客户相关的记录也会被自动删除。<strong>如果要在MySQL中使用外键，一定要记住在创建表的时候将表的类型定义为事务安全表InnoDB类型</strong>。该类型不是MySQL表的默认类型。定义的方法是在CREATE TABLE语句中加上engine=INNODB。如例中所示。</p>
<h5 id="使用索引"><a href="#使用索引" class="headerlink" title="使用索引"></a>使用索引</h5><p>索引是提高数据库性能的常用方法，它可以令数据库服务器以比没有索引快得多的速度检索特定的行，尤其是在查询语句当中包含有MAX(),MIN()和ORDER BY这些命令的时候，性能提高更为明显。</p>
<p>一般说来，索引应建立在那些将用于JOIN,WHERE判断和ORDER BY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。对于一个ENUM类型的字段来说，出现大量重复值是很有可能的情况。</p>
<p>例如customerinfo中的“province”字段，在这样的字段上建立索引将不会有什么帮助；相反，还有可能降低数据库的性能。我们在创建表的时候可以同时创建合适的索引，也可以使用ALTER TABLE或CREATE INDEX在以后创建索引。此外，MySQL从版本3.23.23开始支持全文索引和搜索。全文索引在MySQL中是一个FULLTEXT类型索引，但仅能用于MyISAM类型的表。对于一个大的数据库，将数据装载到一个没有FULLTEXT索引的表中，然后再使用ALTER TABLE或CREATE INDEX创建索引，将是非常快的。但如果将数据装载到一个已经有FULLTEXT索引的表中，执行过程将会非常慢。</p>
<h5 id="优化的查询语句"><a href="#优化的查询语句" class="headerlink" title="优化的查询语句"></a>优化的查询语句</h5><p>绝大多数情况下，使用索引可以提高查询的速度，但如果SQL语句使用不恰当的话，索引将无法发挥它应有的作用。</p>
<p>下面是应该注意的几个方面。</p>
<h6 id="最好是在相同类型的字段间进行比较的操作"><a href="#最好是在相同类型的字段间进行比较的操作" class="headerlink" title="最好是在相同类型的字段间进行比较的操作"></a>最好是在相同类型的字段间进行比较的操作</h6><p>在MySQL3.23版之前，这甚至是一个必须的条件。例如不能将一个建有索引的INT字段和BIGINT字段进行比较；但是作为特殊的情况，在CHAR类型的字段和VARCHAR类型字段的字段大小相同的时候，可以将它们进行比较。</p>
<h6 id="在建有索引的字段上尽量不要使用函数进行操作"><a href="#在建有索引的字段上尽量不要使用函数进行操作" class="headerlink" title="在建有索引的字段上尽量不要使用函数进行操作"></a>在建有索引的字段上尽量不要使用函数进行操作</h6><p>例如，在一个DATE类型的字段上使用YEAE()函数时，将会使索引不能发挥应有的作用。所以，下面的两个查询虽然返回的结果一样，但后者要比前者快得多。</p>
<h6 id="在搜索字符型字段时，我们有时会使用LIKE关键字和通配符，这种做法虽然简单，但却也是以牺牲系统性能为代价的"><a href="#在搜索字符型字段时，我们有时会使用LIKE关键字和通配符，这种做法虽然简单，但却也是以牺牲系统性能为代价的" class="headerlink" title="在搜索字符型字段时，我们有时会使用LIKE关键字和通配符，这种做法虽然简单，但却也是以牺牲系统性能为代价的"></a>在搜索字符型字段时，我们有时会使用LIKE关键字和通配符，这种做法虽然简单，但却也是以牺牲系统性能为代价的</h6><p>例如下面的查询将会比较表中的每一条记录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM books WHERE name like &quot;MySQL%&quot;</span><br></pre></td></tr></table></figure>

<p>但是如果换用下面的查询，返回的结果一样，但速度就要快上很多：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM books WHERE name ＞&#x3D; &quot;MySQL&quot; and name ＜&quot;MySQM&quot;</span><br></pre></td></tr></table></figure>

<p>最后，应该注意避免在查询中让MySQL进行自动类型转换，因为转换过程也会使索引变得不起作用。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle中的COALESCER函数</title>
    <url>/2020/07/26/22/20/Oracle%E4%B8%AD%E7%9A%84COALESCER%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>coalesce函数的使用说明<a id="more"></a></p>
<h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><p>返回其参数中第一个非空表达式。</p>
<h6 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h6><p>coalesce ( 表达式1 ,…表达式n )</p>
<h6 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h6><p>返回数据类型优先级最高的表达式的数据类型，如果所有参数均为null，则coalesce返回null。</p>
<h5 id="等效的case函数"><a href="#等效的case函数" class="headerlink" title="等效的case函数"></a>等效的case函数</h5><h6 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CASE</span><br><span class="line"></span><br><span class="line">   WHEN (expression1 IS NOT NULL) THEN expression1</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   WHEN (expressionN IS NOT NULL) THEN expressionN</span><br><span class="line"></span><br><span class="line">   ELSE NULL</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>尽管 IS NULL 等效于 COALESCE，但它们的行为是不同的。包含具有非空参数的 IS NULL 的表达式将视为 NOT NULL，而包含具有非空参数的 COALESCE 的表达式将视为 NULL。</p>
<h6 id="SQL-Server的非空参数问题"><a href="#SQL-Server的非空参数问题" class="headerlink" title="SQL Server的非空参数问题"></a>SQL Server的非空参数问题</h6><p>在 SQL Server 中，若要对包含具有非空参数的 COALESCE 的表达式创建索引，可以使用 PERSISTED 列属性将计算列持久化，例如下面案例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE #CheckSumTest</span><br><span class="line"></span><br><span class="line">    (</span><br><span class="line"></span><br><span class="line">        ID int identity ,</span><br><span class="line"></span><br><span class="line">        Num int DEFAULT ( RAND() * 100 ) ,</span><br><span class="line"></span><br><span class="line">        RowCheckSum AS COALESCE( CHECKSUM( id , num ) , 0 ) PERSISTED PRIMARY KEY</span><br><span class="line"></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h6 id="COALESCE-使用示例"><a href="#COALESCE-使用示例" class="headerlink" title="COALESCE 使用示例"></a>COALESCE 使用示例</h6><p>在以下示例中，wages 表中包括以下三列有关雇员的年薪的信息：hourly wage、salary 和 commission。但是，每个雇员只能接受一种付款方式。若要确定支付给所有雇员的金额总数，请使用 COALESCE 函数，它只接受在 hourly_wage、salary 和 commission 中找到的非空值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET NOCOUNT ON;</span><br><span class="line"></span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line">USE master;</span><br><span class="line"></span><br><span class="line">IF EXISTS (SELECT name FROM sys.tables</span><br><span class="line"></span><br><span class="line">      WHERE name &#x3D; &#39;wages&#39;)</span><br><span class="line"></span><br><span class="line">   DROP TABLE wages;</span><br><span class="line"></span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line">CREATE TABLE wages</span><br><span class="line"></span><br><span class="line">(</span><br><span class="line"></span><br><span class="line">   emp_id      tinyint    identity,</span><br><span class="line"></span><br><span class="line">   hourly_wage   decimal   NULL,</span><br><span class="line"></span><br><span class="line">   salary      decimal    NULL,</span><br><span class="line"></span><br><span class="line">   commission   decimal   NULL,</span><br><span class="line"></span><br><span class="line">   num_sales   tinyint   NULL</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line">INSERT wages VALUES(10.00, NULL, NULL, NULL);</span><br><span class="line"></span><br><span class="line">INSERT wages VALUES(20.00, NULL, NULL, NULL);</span><br><span class="line"></span><br><span class="line">INSERT wages VALUES(30.00, NULL, NULL, NULL);</span><br><span class="line"></span><br><span class="line">INSERT wages VALUES(40.00, NULL, NULL, NULL);</span><br><span class="line"></span><br><span class="line">INSERT wages VALUES(NULL, 10000.00, NULL, NULL);</span><br><span class="line"></span><br><span class="line">INSERT wages VALUES(NULL, 20000.00, NULL, NULL);</span><br><span class="line"></span><br><span class="line">INSERT wages VALUES(NULL, 30000.00, NULL, NULL);</span><br><span class="line"></span><br><span class="line">INSERT wages VALUES(NULL, 40000.00, NULL, NULL);</span><br><span class="line"></span><br><span class="line">INSERT wages VALUES(NULL, NULL, 15000, 3);</span><br><span class="line"></span><br><span class="line">INSERT wages VALUES(NULL, NULL, 25000, 2);</span><br><span class="line"></span><br><span class="line">INSERT wages VALUES(NULL, NULL, 20000, 6);</span><br><span class="line"></span><br><span class="line">INSERT wages VALUES(NULL, NULL, 14000, 4);</span><br><span class="line"></span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line">SET NOCOUNT OFF;</span><br><span class="line"></span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line">SELECT CAST(COALESCE(hourly_wage * 40 * 52,</span><br><span class="line"></span><br><span class="line">   salary,</span><br><span class="line"></span><br><span class="line">   commission * num_sales) AS money) AS &#39;Total Salary&#39;</span><br><span class="line"></span><br><span class="line">FROM wages;</span><br><span class="line"></span><br><span class="line">GO</span><br></pre></td></tr></table></figure>

<p>结果集</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Total Salary</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line">20800.0000</span><br><span class="line"></span><br><span class="line">41600.0000</span><br><span class="line"></span><br><span class="line">62400.0000</span><br><span class="line"></span><br><span class="line">83200.0000</span><br><span class="line"></span><br><span class="line">10000.0000</span><br><span class="line"></span><br><span class="line">20000.0000</span><br><span class="line"></span><br><span class="line">30000.0000</span><br><span class="line"></span><br><span class="line">40000.0000</span><br><span class="line"></span><br><span class="line">45000.0000</span><br><span class="line"></span><br><span class="line">50000.0000</span><br><span class="line"></span><br><span class="line">120000.0000</span><br><span class="line"></span><br><span class="line">56000.0000</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">(12 row(s) affected)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3的正则表达式</title>
    <url>/2020/02/13/17/06/Python3%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>主要介绍 Python 中常用的正则表达式处理函数。<a id="more"></a></p>
<h6 id="正则表达式模式"><a href="#正则表达式模式" class="headerlink" title="正则表达式模式"></a>正则表达式模式</h6><p>&emsp;&emsp;字母和数字代表它们自身，标点符号只有被转义时才匹配自身，反斜杠本身需要使用反斜杠转义。</p>
<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">^</td>
<td align="center">匹配字符串的开头。</td>
</tr>
<tr>
<td align="center">$</td>
<td align="center">匹配字符串的末尾。</td>
</tr>
<tr>
<td align="center">.</td>
<td align="center">匹配任意字符，除了换行符。</td>
</tr>
<tr>
<td align="center">[…]</td>
<td align="center">用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’</td>
</tr>
<tr>
<td align="center">[^…]</td>
<td align="center">不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。</td>
</tr>
<tr>
<td align="center">re*</td>
<td align="center">匹配0个或多个的表达式。</td>
</tr>
<tr>
<td align="center">re+</td>
<td align="center">匹配1个或多个的表达式。</td>
</tr>
<tr>
<td align="center">re?</td>
<td align="center">匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式</td>
</tr>
<tr>
<td align="center">re{ n}</td>
<td align="center">匹配n个前面表达式。例如，”o{2}”不能匹配”Bob”中的”o”，但是能匹配”food”中的两个o。</td>
</tr>
<tr>
<td align="center">re{ n,}</td>
<td align="center">精确匹配n个前面表达式。例如，”o{2,}”不能匹配”Bob”中的”o”，但能匹配”foooood”中的所有o。”o{1,}”等价于”o+”。”o{0,}”则等价于”o*”。</td>
</tr>
<tr>
<td align="center">re{ n, m}</td>
<td align="center">匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式。</td>
</tr>
<tr>
<td align="center">a | b</td>
<td align="center">匹配a或b。</td>
</tr>
<tr>
<td align="center">(re)</td>
<td align="center">匹配括号内的表达式，也表示一个组。</td>
</tr>
<tr>
<td align="center">(?imx)</td>
<td align="center">正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。</td>
</tr>
<tr>
<td align="center">(?-imx)</td>
<td align="center">正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。</td>
</tr>
<tr>
<td align="center">(?: re)</td>
<td align="center">类似 (…), 但是不表示一个组。</td>
</tr>
<tr>
<td align="center">(?imx: re)</td>
<td align="center">在括号中使用i, m, 或 x 可选标志。</td>
</tr>
<tr>
<td align="center">(?-imx: re)</td>
<td align="center">在括号中不使用i, m, 或 x 可选标志。</td>
</tr>
<tr>
<td align="center">(?#…)</td>
<td align="center">注释。</td>
</tr>
<tr>
<td align="center">(?= re)</td>
<td align="center">前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。</td>
</tr>
<tr>
<td align="center">(?! re)</td>
<td align="center">前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功。</td>
</tr>
<tr>
<td align="center">(?&gt; re)</td>
<td align="center">匹配的独立模式，省去回溯。</td>
</tr>
<tr>
<td align="center">\w</td>
<td align="center">匹配数字字母下划线。</td>
</tr>
<tr>
<td align="center">\W</td>
<td align="center">匹配非数字字母下划线。等价于 [ ^A-Za-z0-9_ ]。</td>
</tr>
<tr>
<td align="center">\s</td>
<td align="center">匹配任意空白字符，等价于 [\t\n\r\f]。</td>
</tr>
<tr>
<td align="center">\S</td>
<td align="center">匹配任意非空字符。等价于 [ ^ \f\n\r\t\v ]。</td>
</tr>
<tr>
<td align="center">\d</td>
<td align="center">匹配任意数字，等价于 [0-9]。</td>
</tr>
<tr>
<td align="center">\D</td>
<td align="center">匹配任意非数字。等价于 [ ^0-9 ]。</td>
</tr>
<tr>
<td align="center">\A</td>
<td align="center">匹配字符串开始。</td>
</tr>
<tr>
<td align="center">\Z</td>
<td align="center">匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。</td>
</tr>
<tr>
<td align="center">\z</td>
<td align="center">匹配字符串结束。</td>
</tr>
<tr>
<td align="center">\G</td>
<td align="center">匹配最后匹配完成的位置。</td>
</tr>
<tr>
<td align="center">\b</td>
<td align="center">匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td>
</tr>
<tr>
<td align="center">\B</td>
<td align="center">匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td>
</tr>
<tr>
<td align="center">\n, \t, 等。</td>
<td align="center">匹配一个换行符。匹配一个制表符, 等。</td>
</tr>
<tr>
<td align="center">\1…\9</td>
<td align="center">匹配第n个分组的内容。</td>
</tr>
<tr>
<td align="center">\10</td>
<td align="center">匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。</td>
</tr>
</tbody></table>
<h6 id="正则表达式修饰符-可选标志"><a href="#正则表达式修饰符-可选标志" class="headerlink" title="正则表达式修饰符-可选标志"></a>正则表达式修饰符-可选标志</h6><p>多个标志可以用|来指定。</p>
<table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">re.I</td>
<td align="center">使匹配对大小写不敏感</td>
</tr>
<tr>
<td align="center">re.L</td>
<td align="center">做本地化识别（locale-aware）匹配</td>
</tr>
<tr>
<td align="center">re.M</td>
<td align="center">多行匹配，影响 ^ 和 $</td>
</tr>
<tr>
<td align="center">re.S</td>
<td align="center">使 . 匹配包括换行在内的所有字符</td>
</tr>
<tr>
<td align="center">re.U</td>
<td align="center">根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.</td>
</tr>
<tr>
<td align="center">re.X</td>
<td align="center">该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。</td>
</tr>
</tbody></table>
<h6 id="正则表达式对象"><a href="#正则表达式对象" class="headerlink" title="正则表达式对象"></a>正则表达式对象</h6><ol>
<li><p>re.RegexObject</p>
<p>re.compile()返回RegexObject对象。</p>
</li>
<li><p>re.MatchObject</p>
<p>group()返回被RE匹配的字符串</p>
<ul>
<li>start()返回匹配开始的位置</li>
<li>end()返回匹配结束的位置</li>
<li>span()返回一个元组包含匹配(开始，结束)的位置</li>
</ul>
</li>
</ol>
<h6 id="re-match函数"><a href="#re-match函数" class="headerlink" title="re.match函数"></a>re.match函数</h6><p>&emsp;&emsp;re.match尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.match(pattern, string, flag=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">pattern</td>
<td align="center">匹配的正则表达式</td>
</tr>
<tr>
<td align="center">string</td>
<td align="center">要匹配的字符串。</td>
</tr>
<tr>
<td align="center">flags</td>
<td align="center">标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">print(re.match(<span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>).span())  <span class="comment"># 在起始位置匹配</span></span><br><span class="line">print(re.match(<span class="string">&#x27;com&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>))         <span class="comment"># 不在起始位置匹配</span></span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">(<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line">None</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;使用group(num) 或 groups()可以匹配对象函数来获取匹配表达式</p>
<table>
<thead>
<tr>
<th align="center">匹配对象方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">group(num=0)</td>
<td align="center">匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。</td>
</tr>
<tr>
<td align="center">groups()</td>
<td align="center">返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"> </span><br><span class="line">line = <span class="string">&quot;Cats are smarter than dogs&quot;</span></span><br><span class="line"><span class="comment"># .* 表示任意匹配除换行符（\n、\r）之外的任何单个或多个字符</span></span><br><span class="line">matchObj = re.match( <span class="string">r&#x27;(.*) are (.*?) .*&#x27;</span>, line, re.M|re.I)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> matchObj:</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">&quot;matchObj.group() : &quot;</span>, matchObj.group())</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">&quot;matchObj.group(1) : &quot;</span>, matchObj.group(<span class="number">1</span>))</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">&quot;matchObj.group(2) : &quot;</span>, matchObj.group(<span class="number">2</span>))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">&quot;No match!!&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">matchObj.group() :  Cats are smarter than dogs</span><br><span class="line">matchObj.group(<span class="number">1</span>) :  Cats</span><br><span class="line">matchObj.group(<span class="number">2</span>) :  smarter</span><br></pre></td></tr></table></figure>

<h6 id="re-search方法"><a href="#re-search方法" class="headerlink" title="re.search方法"></a>re.search方法</h6><p>&emsp;&emsp;re.search扫描整个字符串并返回第一个成功的匹配，否则返回None。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.search(pattern, string, flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"> </span><br><span class="line">print(re.search(<span class="string">&#x27;www&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>).span())  <span class="comment"># 在起始位置匹配</span></span><br><span class="line">print(re.search(<span class="string">&#x27;com&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>).span())         <span class="comment"># 不在起始位置匹配</span></span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">11</span>, <span class="number">14</span>)</span><br></pre></td></tr></table></figure>

<h6 id="re-match与re-search的区别"><a href="#re-match与re-search的区别" class="headerlink" title="re.match与re.search的区别"></a>re.match与re.search的区别</h6><p>&emsp;&emsp;re.match 只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回 None，而 re.search 匹配整个字符串，直到找到一个匹配。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"> </span><br><span class="line">line = <span class="string">&quot;Cats are smarter than dogs&quot;</span></span><br><span class="line"> </span><br><span class="line">matchObj = re.match( <span class="string">r&#x27;dogs&#x27;</span>, line, re.M|re.I)</span><br><span class="line"><span class="keyword">if</span> matchObj:</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">&quot;match --&gt; matchObj.group() : &quot;</span>, matchObj.group())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">&quot;No match!!&quot;</span>)</span><br><span class="line"> </span><br><span class="line">matchObj = re.search( <span class="string">r&#x27;dogs&#x27;</span>, line, re.M|re.I)</span><br><span class="line"><span class="keyword">if</span> matchObj:</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">&quot;search --&gt; matchObj.group() : &quot;</span>, matchObj.group())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">&quot;No match!!&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight erlang-repl"><table><tr><td class="code"><pre><span class="line">No match!!</span><br><span class="line">search --&gt; matchObj.group() :  dogs</span><br></pre></td></tr></table></figure>

<h6 id="re-sub函数"><a href="#re-sub函数" class="headerlink" title="re.sub函数"></a>re.sub函数</h6><p>&emsp;&emsp;re.sub用于替换字符串中匹配项。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">re.sub(pattern, repl, string, <span class="attribute">count</span>=0, <span class="attribute">flags</span>=0)</span><br></pre></td></tr></table></figure>

<ul>
<li>pattern : 正则中的模式字符串。</li>
<li>repl : 替换的字符串，也可为一个函数。</li>
<li>string : 要被查找替换的原始字符串。</li>
<li>count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。</li>
<li>flags : 编译时用的匹配模式，数字形式。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"> </span><br><span class="line">phone = <span class="string">&quot;2004-959-559 # 这是一个电话号码&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 删除注释</span></span><br><span class="line">num = re.sub(<span class="string">r&#x27;#.*$&#x27;</span>, <span class="string">&quot;&quot;</span>, phone)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">&quot;电话号码 : &quot;</span>, num)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 移除非数字的内容</span></span><br><span class="line">num = re.sub(<span class="string">r&#x27;\D&#x27;</span>, <span class="string">&quot;&quot;</span>, phone)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">&quot;电话号码 : &quot;</span>, num)</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">电话号码 :  <span class="number">2004</span><span class="number">-959</span><span class="number">-559</span> </span><br><span class="line">电话号码 :  <span class="number">2004959559</span></span><br></pre></td></tr></table></figure>

<p>repl参数也可以是一个函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 将匹配的数字乘于 2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span>(<span class="params">matched</span>):</span></span><br><span class="line">    value = int(matched.group(<span class="string">&#x27;value&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> str(value * <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">s = <span class="string">&#x27;A23G4HFD567&#x27;</span></span><br><span class="line"><span class="comment"># ?P&lt;value&gt;的意思是命名一个名字为value的组，匹配规则符合后面的/d+</span></span><br><span class="line">print(re.sub(<span class="string">&#x27;(?P&lt;value&gt;\d+)&#x27;</span>, double, s))</span><br></pre></td></tr></table></figure>

<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">A<span class="number">46</span><span class="name">G8</span>HFD<span class="number">1134</span></span><br></pre></td></tr></table></figure>

<h6 id="complie函数"><a href="#complie函数" class="headerlink" title="complie函数"></a>complie函数</h6><p>&emsp;&emsp;compile 函数用于编译正则表达式，生成一个正则表达式 (Pattern) 对象，供 match() 和 search() 这两个函数使用。</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">re.compile(<span class="built_in">pattern</span>, flags)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>pattern : 一个字符串形式的正则表达式</p>
</li>
<li><p>flags 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为：</p>
</li>
<li><ul>
<li><p>re.I 忽略大小写</p>
</li>
<li><p>re.L 表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境</p>
</li>
<li><p>re.M 多行模式</p>
</li>
<li><p>re.S 即为’ . ‘并且包括换行符在内的任意字符（’ . ‘不包括换行符）</p>
</li>
<li><p>re.U 表示特殊字符集 \w, \W, \b, \B, \d, \D, \s, \S 依赖于 Unicode 字符属性数据库</p>
</li>
<li><p>re.X 为了增加可读性，忽略空格和’ # ‘后面的注释</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern = re.compile(<span class="string">r&#x27;\d+&#x27;</span>)                    <span class="comment"># 用于匹配至少一个数字</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = pattern.match(<span class="string">&#x27;one12twothree34four&#x27;</span>)        <span class="comment"># 查找头部，没有匹配</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print( m )</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = pattern.match(<span class="string">&#x27;one12twothree34four&#x27;</span>, <span class="number">2</span>, <span class="number">10</span>) <span class="comment"># 从&#x27;e&#x27;的位置开始匹配，没有匹配</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print( m )</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = pattern.match(<span class="string">&#x27;one12twothree34four&#x27;</span>, <span class="number">3</span>, <span class="number">10</span>) <span class="comment"># 从&#x27;1&#x27;的位置开始匹配，正好匹配</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print( m )                                        <span class="comment"># 返回一个 Match 对象</span></span><br><span class="line">&lt;_sre.SRE_Match object at <span class="number">0x10a42aac0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">0</span>)   <span class="comment"># 可省略 0</span></span><br><span class="line"><span class="string">&#x27;12&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.start(<span class="number">0</span>)   <span class="comment"># 可省略 0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.end(<span class="number">0</span>)     <span class="comment"># 可省略 0</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.span(<span class="number">0</span>)    <span class="comment"># 可省略 0</span></span><br><span class="line">(<span class="number">3</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<h6 id="re-findall"><a href="#re-findall" class="headerlink" title="re.findall"></a>re.findall</h6><p>&emsp;&emsp;在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">re.findall(<span class="built_in">string</span>, pos, endpos)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>string</strong> 待匹配的字符串。</li>
<li><strong>pos</strong> 可选参数，指定字符串的起始位置，默认为 0。</li>
<li><strong>endpos</strong> 可选参数，指定字符串的结束位置，默认为字符串的长度。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"> </span><br><span class="line">pattern = re.compile(<span class="string">r&#x27;\d+&#x27;</span>)   <span class="comment"># 查找数字</span></span><br><span class="line">result1 = pattern.findall(<span class="string">&#x27;runoob 123 google 456&#x27;</span>)</span><br><span class="line">result2 = pattern.findall(<span class="string">&#x27;run88oob123google456&#x27;</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"> </span><br><span class="line">print(result1)</span><br><span class="line">print(result2)</span><br></pre></td></tr></table></figure>

<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">[<span class="symbol">&#x27;123</span>&#x27;, <span class="symbol">&#x27;456</span>&#x27;]</span><br><span class="line">[<span class="symbol">&#x27;88</span>&#x27;, <span class="symbol">&#x27;12</span>&#x27;]</span><br></pre></td></tr></table></figure>

<h6 id="re-finditer"><a href="#re-finditer" class="headerlink" title="re.finditer"></a>re.finditer</h6><p>&emsp;&emsp;和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">re.finditer(pattern, <span class="built_in">string</span>, flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"> </span><br><span class="line">it = re.finditer(<span class="string">r&quot;\d+&quot;</span>,<span class="string">&quot;12a32bc43jf3&quot;</span>) </span><br><span class="line"><span class="keyword">for</span> match <span class="keyword">in</span> it: </span><br><span class="line">    <span class="keyword">print</span> (match.group() )</span><br></pre></td></tr></table></figure>

<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">12 </span></span><br><span class="line"><span class="symbol">32 </span></span><br><span class="line"><span class="symbol">43 </span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h6 id="re-split"><a href="#re-split" class="headerlink" title="re.split"></a>re.split</h6><p>&emsp;&emsp;split 方法按照能够匹配的子串将字符串分割后返回列表。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">re.split(pattern, string, <span class="attribute">maxsplit</span>=0, <span class="attribute">flags</span>=0)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">&#x27;\W+&#x27;</span>, <span class="string">&#x27;runoob, runoob, runoob.&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">&#x27;(\W+)&#x27;</span>, <span class="string">&#x27; runoob, runoob, runoob.&#x27;</span>) </span><br><span class="line">[<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;, &#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;, &#x27;</span>, <span class="string">&#x27;runoob&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">&#x27;\W+&#x27;</span>, <span class="string">&#x27; runoob, runoob, runoob.&#x27;</span>, <span class="number">1</span>) </span><br><span class="line">[<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;runoob, runoob, runoob.&#x27;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">&#x27;a*&#x27;</span>, <span class="string">&#x27;hello world&#x27;</span>)   <span class="comment"># 对于一个找不到匹配的字符串而言，split 不会对其作出分割</span></span><br><span class="line">[<span class="string">&#x27;hello world&#x27;</span>]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬取电影天堂新片精品</title>
    <url>/2020/02/12/16/02/Python%E7%88%AC%E5%8F%96%E7%94%B5%E5%BD%B1%E5%A4%A9%E5%A0%82%E6%96%B0%E7%89%87%E7%B2%BE%E5%93%81/</url>
    <content><![CDATA[<p>爬取最新电影，内容包括标题、年代、产地、类别、评分、片场、导演、主演、下载链接。<a id="more"></a></p>
<h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">base_domain = <span class="string">&quot;https://www.dytt8.net&quot;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 &quot;</span></span><br><span class="line">                  <span class="string">&quot;(KHTML, like Gecko) Chrome/80.0.3987.163 Safari/537.36 Edg/80.0.361.111&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail_url</span>(<span class="params">url</span>):</span></span><br><span class="line">    resp = requests.get(url, headers=headers)</span><br><span class="line">    <span class="comment"># 解码出现&quot;illegal multibyte sequence&quot;，其他编码无法解决，使用ignore</span></span><br><span class="line">    <span class="comment"># text = resp.content.decode(&quot;gbk&quot;, errors=&quot;ignore&quot;)</span></span><br><span class="line">    text = resp.text</span><br><span class="line">    html = etree.HTML(text)</span><br><span class="line">    detail_urls = html.xpath(<span class="string">&quot;//table[@class=&#x27;tbspan&#x27;]//a/@href&quot;</span>)</span><br><span class="line">    detail_urls = map(<span class="keyword">lambda</span> url: base_domain + url, detail_urls)</span><br><span class="line">    <span class="keyword">return</span> detail_urls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span>(<span class="params">url</span>):</span></span><br><span class="line">    resp = requests.get(url, headers=headers)</span><br><span class="line">    text = resp.content.decode(<span class="string">&quot;gbk&quot;</span>, errors=<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line">    html = etree.HTML(text)</span><br><span class="line">    <span class="keyword">return</span> html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_info</span>(<span class="params">info, rule</span>):</span></span><br><span class="line">    <span class="keyword">return</span> info.replace(rule, <span class="string">&quot;&quot;</span>).strip()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_detail_page</span>(<span class="params">url</span>):</span></span><br><span class="line">    movie = &#123;&#125;</span><br><span class="line">    html = get_html(url)</span><br><span class="line">    title = html.xpath(<span class="string">&quot;//div[@class=&#x27;title_all&#x27;]//font[@color=&#x27;#07519a&#x27;]/text()&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    movie[<span class="string">&quot;title&quot;</span>] = title</span><br><span class="line">    zooms = html.xpath(<span class="string">&quot;//div[@id=&#x27;Zoom&#x27;]&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    poster = zooms.xpath(<span class="string">&quot;.//img/@src&quot;</span>)</span><br><span class="line">    movie[<span class="string">&quot;poster&quot;</span>] = poster</span><br><span class="line"></span><br><span class="line">    infos = zooms.xpath(<span class="string">&quot;.//text()&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> index, info <span class="keyword">in</span> enumerate(infos):</span><br><span class="line">        <span class="keyword">if</span> info.startswith(<span class="string">&quot;◎年　　代&quot;</span>):</span><br><span class="line">            info = parse_info(info, <span class="string">&quot;◎年　　代&quot;</span>)</span><br><span class="line">            movie[<span class="string">&quot;year&quot;</span>] = info</span><br><span class="line">        <span class="keyword">elif</span> info.startswith(<span class="string">&quot;◎产　　地&quot;</span>):</span><br><span class="line">            info = parse_info(info, <span class="string">&quot;◎产　　地&quot;</span>)</span><br><span class="line">            movie[<span class="string">&quot;country&quot;</span>] = info</span><br><span class="line">        <span class="keyword">elif</span> info.startswith(<span class="string">&quot;◎类　　别&quot;</span>):</span><br><span class="line">            info = parse_info(info, <span class="string">&quot;◎类　　别&quot;</span>)</span><br><span class="line">            movie[<span class="string">&quot;category&quot;</span>] = info</span><br><span class="line">        <span class="keyword">elif</span> info.startswith(<span class="string">&quot;◎豆瓣评分&quot;</span>):</span><br><span class="line">            info = parse_info(info, <span class="string">&quot;◎豆瓣评分&quot;</span>)</span><br><span class="line">            movie[<span class="string">&quot;score&quot;</span>] = info</span><br><span class="line">        <span class="keyword">elif</span> info.startswith(<span class="string">&quot;◎片　　长&quot;</span>):</span><br><span class="line">            info = parse_info(info, <span class="string">&quot;◎片　　长&quot;</span>)</span><br><span class="line">            movie[<span class="string">&quot;timelength&quot;</span>] = info</span><br><span class="line">        <span class="keyword">elif</span> info.startswith(<span class="string">&quot;◎导　　演&quot;</span>):</span><br><span class="line">            info = parse_info(info, <span class="string">&quot;◎导　　演&quot;</span>)</span><br><span class="line">            movie[<span class="string">&quot;director&quot;</span>] = info</span><br><span class="line">        <span class="keyword">elif</span> info.startswith(<span class="string">&quot;◎主　　演&quot;</span>):</span><br><span class="line">            info = parse_info(info, <span class="string">&quot;◎主　　演&quot;</span>)</span><br><span class="line">            actors = [info]</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(index + <span class="number">1</span>, len(infos)):</span><br><span class="line">                actor = infos[x].strip()</span><br><span class="line">                <span class="keyword">if</span> actor.startswith(<span class="string">&quot;◎&quot;</span>):</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                actors.append(actor)</span><br><span class="line">            movie[<span class="string">&quot;actors&quot;</span>] = actors</span><br><span class="line">        <span class="keyword">elif</span> info.startswith(<span class="string">&quot;◎简　　介&quot;</span>):</span><br><span class="line">            info = parse_info(info, <span class="string">&quot;◎简　　介&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(index + <span class="number">1</span>, len(infos)):</span><br><span class="line">                profile = infos[x].strip()</span><br><span class="line">                <span class="keyword">if</span> profile.startswith(<span class="string">&quot;【&quot;</span>):</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            movie[<span class="string">&quot;profile&quot;</span>] = profile</span><br><span class="line"></span><br><span class="line">    down_url = zooms.xpath(<span class="string">&quot;.//table//a/@href&quot;</span>)</span><br><span class="line">    movie[<span class="string">&quot;down_url&quot;</span>] = down_url</span><br><span class="line">    <span class="keyword">return</span> movie</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spider</span>():</span></span><br><span class="line">    index_url = <span class="string">&quot;https://www.dytt8.net/html/gndy/dyzz/index.html&quot;</span></span><br><span class="line">    base_url = <span class="string">&quot;https://www.dytt8.net/html/gndy/dyzz/list_23_&#123;&#125;.html&quot;</span></span><br><span class="line">    html = get_html(index_url)</span><br><span class="line">    pages = html.xpath(<span class="string">&quot;//select[@name=&#x27;sldd&#x27;]/option&quot;</span>)</span><br><span class="line">    movies = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, len(pages) + <span class="number">1</span>):</span><br><span class="line">        url = base_url.format(x)</span><br><span class="line">        detail_urls = get_detail_url(url)</span><br><span class="line">        <span class="keyword">for</span> detail_url <span class="keyword">in</span> detail_urls:</span><br><span class="line">            <span class="comment"># 遍历每一页中的所有电影</span></span><br><span class="line">            movie = parse_detail_page(detail_url)</span><br><span class="line">            movies.append(movie)</span><br><span class="line">            print(movie)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    spider()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>实例</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>React的Ref属性</title>
    <url>/2020/07/25/11/01/React%E7%9A%84Ref%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>父与子组件使用ref通信<a id="more"></a></p>
<p>props属性传值与ref的区别：</p>
<p>输入框的value值拿到之后，还要把value值通过回调函数调用传回给外面的事件(父组件)，如果父组件想要清空输入框的话，就从父组件中传一个新的属性进来，进行重置，这样就不用与input标签进行交互，只要身上绑定一个ref，我就能拿到这个组件的任何东西，我能拿到他的状态，我就可以获取它里面<br>孩子的状态，同样的话，我还可以去修改他的状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; todolist</span><br><span class="line"></span><br><span class="line">import React, &#123; Component &#125; from &#39;react&#39;</span><br><span class="line"></span><br><span class="line">class Input extends Component&#123;</span><br><span class="line">  &#x2F;&#x2F; 5.定义状态</span><br><span class="line">    state &#x3D; &#123;</span><br><span class="line">        mytext:&quot;&quot;,</span><br><span class="line">        list: [&#39;111&#39;, &#39;222&#39;, &#39;333&#39;]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 10.定义kerwinreset方法，用来清空输入框的value值</span><br><span class="line">    kerwinreset&#x3D; ()&#x3D;&gt;&#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            list: [...this.state.list, this.state.mytext],</span><br><span class="line">            mytext:&quot;&quot;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleDel &#x3D; (index) &#x3D;&gt; &#123;</span><br><span class="line">      var newList &#x3D; [...this.state.list]</span><br><span class="line">      newList.splice(index, 1)</span><br><span class="line">      console.log(newList)</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        list: newList</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">          &lt;div&gt;</span><br><span class="line">              &#123;&#x2F;* 1.创建组件 *&#x2F;&#125;</span><br><span class="line">              &#123;&#x2F;* 7.绑定onChange事件 *&#x2F;&#125;</span><br><span class="line">              &lt;input type&#x3D;&quot;text&quot; style&#x3D;&#123;&#123;background:&quot;yellow&quot;&#125;&#125;</span><br><span class="line">                  value&#x3D;&#123;this.state.mytext&#125; onChange&#x3D;&#123;(e)&#x3D;&gt;&#123;</span><br><span class="line">                  this.setState(&#123;</span><br><span class="line">                      &#x2F;&#x2F; 8.一点击button按钮就把输入框当前的value同步给mytext状态</span><br><span class="line">                      mytext:e.target.value</span><br><span class="line">                  &#125;)</span><br><span class="line">              &#125;&#125;&#x2F;&gt;</span><br><span class="line">              &lt;ul style&#x3D;&#123;&#123; listStyle: &quot;none&quot; &#125;&#125;&gt;</span><br><span class="line">                &#123; this.state.list.map((item, index) &#x3D;&gt; </span><br><span class="line">                    &lt;li key&#x3D;&#123;item&#125;&gt;</span><br><span class="line">                      &#123; item &#125;</span><br><span class="line">                      &lt;button onClick&#x3D; &#123; this.handleDel.bind(this, index) &#125;&gt;删除&lt;&#x2F;button&gt;</span><br><span class="line">                    &lt;&#x2F;li&gt; </span><br><span class="line">                ) &#125;</span><br><span class="line">              &lt;&#x2F;ul&gt;</span><br><span class="line">          &lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default class App extends Component &#123;</span><br><span class="line">    state &#x3D; &#123;</span><br><span class="line">      datalist: []</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123;&#x2F;* 2.使用组件，通过ref拿到value值 *&#x2F;&#125;</span><br><span class="line">                &lt;Input ref&#x3D;&quot;myinput&quot;&#x2F;&gt;</span><br><span class="line">                &#123;&#x2F;* 3.绑定点击事件 *&#x2F;&#125;</span><br><span class="line">                &lt;button onClick&#x3D;&#123;this.handleClick&#125;&gt;添加&lt;&#x2F;button&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 4.点击事件</span><br><span class="line">    handleClick &#x3D; ()&#x3D;&gt;&#123;</span><br><span class="line">        &#x2F;&#x2F; 6.拿到input的结构(状态和方法都能拿到)</span><br><span class="line">        console.log(this.refs.myinput)</span><br><span class="line">        &#x2F;&#x2F; 9.拿到拿到输入框的value值</span><br><span class="line">        console.log(this.refs.myinput.state.mytext)</span><br><span class="line">        &#x2F;&#x2F; 11.拿到输入框的value之后，调用kerwinreset方法，来清空输入框</span><br><span class="line">        this.refs.myinput.kerwinreset()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React组件的生命周期</title>
    <url>/2020/07/02/22/38/React%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>组件的生命周期及处理函数<a id="more"></a></p>
<h5 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h5><p>组件的生命周期分成三个状态：</p>
<ul>
<li><p>Mounting：已插入真实DOM。</p>
</li>
<li><p>Updating：正在被重新渲染。</p>
</li>
<li><p>Unmounting：已移除真实DOM。</p>
</li>
</ul>
<p>React为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。</p>
<ul>
<li><p>componentWillMount()：在渲染前调用,在客户端也在服务端。</p>
</li>
<li><p>componentDidMount()：在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异部操作阻塞UI)。</p>
</li>
<li><p>componentWillUpdate(object nextProps, object nextState)：在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。</p>
</li>
<li><p>componentDidUpdate(object prevProps, object prevState)：在组件完成更新后立即调用。在初始化时不会被调用。</p>
</li>
<li><p>componentWillUnmount()：在组件从 DOM 中移除的时候立刻被调用。</p>
</li>
</ul>
<p>此外，React 还提供两种特殊状态的处理函数。</p>
<ul>
<li>componentWillReceiveProps(object nextProps)：在组件接收到一个新的prop时被调用。这个方法在初始化render时不会被调用。</li>
<li>shouldComponentUpdate(object nextProps, object nextState)：返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。<br>  可以在你确认不需要更新组件时使用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Hello &#x3D; React.createClass(&#123;</span><br><span class="line">  getInitialState: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      opacity: 1.0</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  componentDidMount: function () &#123;</span><br><span class="line">    this.timer &#x3D; setInterval(function () &#123;</span><br><span class="line">      var opacity &#x3D; this.state.opacity;</span><br><span class="line">      opacity -&#x3D; .05;</span><br><span class="line">      if (opacity &lt; 0.1) &#123;</span><br><span class="line">        opacity &#x3D; 1.0;</span><br><span class="line">      &#125;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        opacity: opacity</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;.bind(this), 100);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render: function () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div style&#x3D;&#123;&#123;opacity: this.state.opacity&#125;&#125;&gt;</span><br><span class="line">        Hello &#123;this.props.name&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">React.render(</span><br><span class="line">  &lt;Hello name&#x3D;&quot;world&quot;&#x2F;&gt;,</span><br><span class="line">  document.body</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码在hello组件加载以后，通过 componentDidMount 方法设置一个定时器，每隔100毫秒，就重新设置组件的透明度，从而引发重新渲染。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Button &#x3D; React.createClass(&#123;</span><br><span class="line">  getInitialState: function() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      data:0</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  setNewNumber: function() &#123;</span><br><span class="line">    this.setState(&#123;data: this.state.data + 1&#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  render: function () &#123;</span><br><span class="line">      return (</span><br><span class="line">         &lt;div&gt;</span><br><span class="line">            &lt;button onClick &#x3D; &#123;this.setNewNumber&#125;&gt;INCREMENT&lt;&#x2F;button&gt;</span><br><span class="line">            &lt;Content myNumber &#x3D; &#123;this.state.data&#125;&gt;&lt;&#x2F;Content&gt;</span><br><span class="line">         &lt;&#x2F;div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">var Content &#x3D; React.createClass(&#123;</span><br><span class="line">  componentWillMount:function() &#123;</span><br><span class="line">      console.log(&#39;Component WILL MOUNT!&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  componentDidMount:function() &#123;</span><br><span class="line">       console.log(&#39;Component DID MOUNT!&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  componentWillReceiveProps:function(newProps) &#123;</span><br><span class="line">        console.log(&#39;Component WILL RECIEVE PROPS!&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  shouldComponentUpdate:function(newProps, newState) &#123;</span><br><span class="line">        return true;</span><br><span class="line">  &#125;,</span><br><span class="line">  componentWillUpdate:function(nextProps, nextState) &#123;</span><br><span class="line">        console.log(&#39;Component WILL UPDATE!&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">  componentDidUpdate:function(prevProps, prevState) &#123;</span><br><span class="line">        console.log(&#39;Component DID UPDATE!&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line">  componentWillUnmount:function() &#123;</span><br><span class="line">         console.log(&#39;Component WILL UNMOUNT!&#39;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">    render: function () &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;h3&gt;&#123;this.props.myNumber&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">ReactDOM.render(</span><br><span class="line">   &lt;div&gt;</span><br><span class="line">      &lt;Button &#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;div&gt;,</span><br><span class="line">  document.getElementById(&#39;example&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>以上实例初始化 state ， setNewnumber 用于更新 state。所有生命周期在 Content 组件中。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>StreamTokenizer使用</title>
    <url>/2020/02/09/11/21/StreamTokenizer%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>StreamTokenizer的用法<a id="more"></a></p>
<p>Java联系解题一般使用Scanner类进行输入，但对时间要求严格的题目，用它可能会超时。使用StreamTokenizer类进行输入的效率比Scanner高一点。</p>
<p>StreamTokenizer的使用小结：</p>
<ol>
<li><p>类java.io.StreamTokenizer可以获取输入流并将其分析为Token，StreamTokenizer的nextToken方法读取下一个标记。</p>
</li>
<li><p>默认情况下，StreamTokenizer认为下列内容是Token：字母、数字、除C和C++注释符号以外的其他符号。如符号“/”(中文双引号)不是Token，注释后的内容也不是，而”/“(英文双引号)是Token。单引号和双引号以及其他的内容，只能算是一个Token。</p>
</li>
<li><p>为了提高效率，使用BufferedReader读取数据。如下，创建StreamTokenizer对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StreamTokenizer st = <span class="keyword">new</span> StreamTokenizer(<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)));</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了从数据流中获取标记，可以调用StreamTokenizer的nextToken()方法。调用nextToken()方法以后，如果标记是字符串，可以用String s = st.sval，如果是整数用int n = (int)st.nval得到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">st.nextToken();</span><br><span class="line"><span class="comment">//st.nval默认解析出的格式是double</span></span><br><span class="line"><span class="keyword">int</span> i = (<span class="keyword">int</span>)st.nval;</span><br><span class="line">st.nextToken();</span><br><span class="line"><span class="keyword">int</span> j = (<span class="keyword">int</span>)st.nval;</span><br><span class="line">st.nextToken();</span><br><span class="line">String s = st.sval;</span><br></pre></td></tr></table></figure>
</li>
<li><p>要统计文件的字符数，不能简单地统计Token数，因为字符数不等于Token，按照Token的规定，引号中的内容就算是10页也算是一个Token。如果希望引号和引号中的内容都算作Token，应该通过StreamTokenizer的ordinaryCha()方法将单引号和双引号当做普通字符处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接在程序中指定了文件输入路径：String fileName = &quot;d:/ceshi.txt&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> szu.edu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.StreamTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用StreamTokenizer来统计文件中的字符数</span></span><br><span class="line"><span class="comment"> * StreamTokenizer 类获取输入流并将其分析为“标记”，允许一次读取一个标记。</span></span><br><span class="line"><span class="comment"> * 分析过程由一个表和许多可以设置为各种状态的标志控制。</span></span><br><span class="line"><span class="comment"> * 该流的标记生成器可以识别标识符、数字、引用的字符串和各种注释样式。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  默认情况下，StreamTokenizer认为下列内容是Token: 字母、数字、除C和C++注释符号以外的其他符号。</span></span><br><span class="line"><span class="comment"> *  如符号&quot;/&quot;不是Token，注释后的内容也不是，而&quot;\&quot;是Token。单引号和双引号以及其中的内容，只能算是一个Token。</span></span><br><span class="line"><span class="comment"> *  统计文章字符数的程序，不是简单的统计Token数就万事大吉，因为字符数不等于Token。按照Token的规定，</span></span><br><span class="line"><span class="comment"> *  引号中的内容就算是10页也算一个Token。如果希望引号和引号中的内容都算作Token，应该调用下面的代码：</span></span><br><span class="line"><span class="comment"> *     st.ordinaryChar(&#x27;\&#x27;&#x27;);  //将单引号设为普通字符</span></span><br><span class="line"><span class="comment"> * st.ordinaryChar(&#x27;\&quot;&#x27;);    //将双引号设为普通字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatisFileChars</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计字符数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName 文件名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>    字符数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">statis</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        FileReader fileReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileReader = <span class="keyword">new</span> FileReader(fileName);</span><br><span class="line">            <span class="comment">//创建分析给定字符流的标记生成器</span></span><br><span class="line">            StreamTokenizer st = <span class="keyword">new</span> StreamTokenizer(<span class="keyword">new</span> BufferedReader(</span><br><span class="line">                    fileReader));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//ordinaryChar方法指定字符参数在此标记生成器中是“普通”字符。</span></span><br><span class="line">            <span class="comment">//下面指定单引号、双引号和注释符号是普通字符</span></span><br><span class="line">            st.ordinaryChar(<span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">            st.ordinaryChar(<span class="string">&#x27;\&quot;&#x27;</span>);</span><br><span class="line">            st.ordinaryChar(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            String s;</span><br><span class="line">            <span class="keyword">int</span> numberSum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> wordSum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> symbolSum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//nextToken方法读取下一个Token.</span></span><br><span class="line">            <span class="comment">//TT_EOF指示已读到流末尾的常量。</span></span><br><span class="line">            <span class="keyword">while</span> (st.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">                <span class="comment">//在调用 nextToken 方法之后，ttype字段将包含刚读取的标记的类型</span></span><br><span class="line">                <span class="keyword">switch</span> (st.ttype) &#123;</span><br><span class="line">                <span class="comment">//TT_EOL指示已读到行末尾的常量。</span></span><br><span class="line">                <span class="keyword">case</span> StreamTokenizer.TT_EOL:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//TT_NUMBER指示已读到一个数字标记的常量</span></span><br><span class="line">                <span class="keyword">case</span> StreamTokenizer.TT_NUMBER:</span><br><span class="line">                    <span class="comment">//如果当前标记是一个数字，nval字段将包含该数字的值</span></span><br><span class="line">                    s = String.valueOf((st.nval));</span><br><span class="line">                    System.out.println(s);</span><br><span class="line">                    numberSum += s.length();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//TT_WORD指示已读到一个文字标记的常量</span></span><br><span class="line">                <span class="keyword">case</span> StreamTokenizer.TT_WORD:</span><br><span class="line">                    <span class="comment">//如果当前标记是一个文字标记，sval字段包含一个给出该文字标记的字符的字符串</span></span><br><span class="line">                    s = st.sval;</span><br><span class="line">                    wordSum += s.length();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">//如果以上3中类型都不是，则为英文的标点符号</span></span><br><span class="line">                    s = String.valueOf((<span class="keyword">char</span>) st.ttype);</span><br><span class="line">                    symbolSum += s.length();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;sum of number = &quot;</span> + numberSum);</span><br><span class="line">            System.out.println(<span class="string">&quot;sum of word = &quot;</span> + wordSum);</span><br><span class="line">            System.out.println(<span class="string">&quot;sum of symbol = &quot;</span> + symbolSum);</span><br><span class="line">            total = symbolSum + numberSum + wordSum;</span><br><span class="line">            System.out.println(<span class="string">&quot;Total = &quot;</span> + total);</span><br><span class="line">            <span class="keyword">return</span> total;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fileReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fileReader.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String fileName = <span class="string">&quot;d:/ceshi.txt&quot;</span>;</span><br><span class="line">        StatisFileChars.statis(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
      <categories>
        <category>java方法</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Swagger2自动生成API文档</title>
    <url>/2020/01/25/20/48/Swagger2%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90API%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>Swagger2 是一个规范和完整的框架，用于生成、描述、调用和可视化Restful风格的web服务，现在我们使用spring boot 整合它。<a id="more"></a></p>
<h5 id="引入pom依赖"><a href="#引入pom依赖" class="headerlink" title="引入pom依赖"></a>引入pom依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--界面支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="编写Swagger2配置文件"><a href="#编写Swagger2配置文件" class="headerlink" title="编写Swagger2配置文件"></a>编写Swagger2配置文件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.git;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.PathSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Swagger2Configuration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//api接口扫描包路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SWAGGER2_SCAN_BASE_PACKAGE = <span class="string">&quot;com.kuang.git&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String VERSION = <span class="string">&quot;1.0.0&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">createRestApi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(swagger2ApiTest())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(SWAGGER2_SCAN_BASE_PACKAGE))</span><br><span class="line">                <span class="comment">//根据url路径设置哪些请求加入文档、忽略哪些请求</span></span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">swagger2ApiTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(<span class="string">&quot;SWAGGER2&quot;</span>)<span class="comment">//设置文档标题</span></span><br><span class="line">                .description(<span class="string">&quot;SWAGGER2 API文档测试&quot;</span>)<span class="comment">//文档描述</span></span><br><span class="line">                .version(VERSION)<span class="comment">//文档版本</span></span><br><span class="line">                .termsOfServiceUrl(<span class="string">&quot;http://www.baidu.com&quot;</span>)<span class="comment">//设置文档的License信息</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="使用注释"><a href="#使用注释" class="headerlink" title="使用注释"></a>使用注释</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.git;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONException;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.Api;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Api(description = &quot;Swagger2 时间测试&quot;)</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/swagger2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Swagger2Web</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/time&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;获取系统时间&quot;,notes = &quot;获取系统时间&quot;,produces = &quot;aplication/json&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JSONObject <span class="title">SwaggerTest</span><span class="params">()</span> <span class="keyword">throws</span> ParseException, JSONException </span>&#123;</span><br><span class="line">        JSONObject json = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        <span class="comment">//标准时间</span></span><br><span class="line">        String res = (<span class="keyword">new</span> Date()).toString();</span><br><span class="line">        json.put(<span class="string">&quot;Date&quot;</span>,res);</span><br><span class="line">        <span class="keyword">return</span> json;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="常用注释说明"><a href="#常用注释说明" class="headerlink" title="常用注释说明"></a>常用注释说明</h5><p>@Api 注解可以用来标记 Controller 的功能</p>
<p>@ApiOperation 注解用来标记一个方法的作用</p>
<p>@ApilmplicitParam 注解用来描述一个参数，可以配置参数的中文含义，也可以给参数设置默认值，这样在接口测试的时候可以避免手动输入</p>
<p>@ApilmplicitParams 如果有多个参数，则需要使用多个 @ApilmplicitParam 注解来描述， 多个 @ApilmplicitParam 注解需要放在一个 @ApilmplicitParams 注解中</p>
<p>@ApiModel 如果参数是一个对象，则需要在对象所在的类上加上此注解</p>
<p>@ApiModelProperty 如果参数是一个对象，则需要在对应的属性上加上此注解，还需要在对象所在的类上加上 @ApiModel</p>
<p>@ApiIgnore 注解标识此参数可以忽略</p>
<p>上面的配置完成之后就已经集成完成。启动项目之后，浏览器输入<a href="http://127.0.0.1:8083/swagger-ui.html">http://127.0.0.1:8083/swagger-ui.html</a>访问。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>XPath语法</title>
    <url>/2020/02/11/18/53/XPath%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>XPath使用语法<a id="more"></a></p>
<h6 id="选取节点"><a href="#选取节点" class="headerlink" title="选取节点"></a>选取节点</h6><table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">描述</th>
<th align="center">示例</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">nodename</td>
<td align="center">选取此节点的所有子节点</td>
<td align="center">html</td>
<td align="center">选取html下所有的子节点</td>
</tr>
<tr>
<td align="center">/</td>
<td align="center">如果是在最前面，代表从根节点选取。否则选择某节点下的某个节点</td>
<td align="center">/html</td>
<td align="center">选取整个html节点</td>
</tr>
<tr>
<td align="center">//</td>
<td align="center">从全局节点中选择节点，随便在哪个位置</td>
<td align="center">//div</td>
<td align="center">选取所有的div节点</td>
</tr>
<tr>
<td align="center">@</td>
<td align="center">选取某个节点中的属性</td>
<td align="center">//div[@class]</td>
<td align="center">选取所有div节点下的class属性</td>
</tr>
</tbody></table>
<h6 id="谓语"><a href="#谓语" class="headerlink" title="谓语"></a>谓语</h6><p>谓语用来查找某个特定的节点或者包含某个制定的值的节点，被嵌在方括号里。</p>
<p>在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果：</p>
<table>
<thead>
<tr>
<th align="center">路径表达式</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">//body/div[1]</td>
<td align="center">获取body节点下的第一个div(下标从1开始)</td>
</tr>
<tr>
<td align="center">//body/div[last()]</td>
<td align="center">获取body节点下最后一个div元素</td>
</tr>
<tr>
<td align="center">//body/div[position()&lt;3]</td>
<td align="center">获取body节点下前两个div元素</td>
</tr>
<tr>
<td align="center">//div[@class]</td>
<td align="center">获取div节点下拥有class属性的元素</td>
</tr>
<tr>
<td align="center">//div[@price=10]</td>
<td align="center">获取div节点下属性为price=10的元素</td>
</tr>
<tr>
<td align="center">//div[contains(@class,”fl”)]</td>
<td align="center">模糊匹配，选取div节点下包含fl的class元素</td>
</tr>
</tbody></table>
<h6 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h6><table>
<thead>
<tr>
<th align="center">通配符</th>
<th align="center">描述</th>
<th align="center">示例</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">*</td>
<td align="center">匹配任意节点</td>
<td align="center">//body/*</td>
<td align="center">body下的额所有节点</td>
</tr>
<tr>
<td align="center">@*</td>
<td align="center">匹配节点中的任何属性</td>
<td align="center">//div[@*]</td>
<td align="center">div下的所有属性节点</td>
</tr>
</tbody></table>
<h6 id="选取多个路径"><a href="#选取多个路径" class="headerlink" title="选取多个路径"></a>选取多个路径</h6><p>通过在路径表达式中使用”|”运算符，可以选取若干个路径</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//dd[@class=&quot;job_bt&quot;] | //dd[@class=&quot;job-advant-age&quot;]</span><br></pre></td></tr></table></figure>

<h6 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h6><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
<th align="center">实例</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">|</td>
<td align="center">计算两个节点集</td>
<td align="center">//book | //cd</td>
<td align="center">返回所有拥有 book 和 cd 元素的节点集</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">加法</td>
<td align="center">6 + 4</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">减法</td>
<td align="center">6 - 4</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">乘法</td>
<td align="center">6 * 4</td>
<td align="center">24</td>
</tr>
<tr>
<td align="center">div</td>
<td align="center">除法</td>
<td align="center">8 div 4</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">=</td>
<td align="center">等于</td>
<td align="center">price=9.80</td>
<td align="center">如果 price 是 9.80，则返回 true，否则 false。</td>
</tr>
<tr>
<td align="center">!=</td>
<td align="center">不等于</td>
<td align="center">price!=9.80</td>
<td align="center">如果 price 是 9.90，则返回 true，否则 false。</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">小于</td>
<td align="center">price&lt;9.80</td>
<td align="center">如果 price 是 9.00，则返回 true，否则 false。</td>
</tr>
<tr>
<td align="center">&lt;=</td>
<td align="center">小于或等于</td>
<td align="center">price&lt;=9.80</td>
<td align="center">如果 price 是 9.00，则返回 true，否则 false。</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">大于</td>
<td align="center">price&gt;9.80</td>
<td align="center">如果 price 是 9.90，则返回 true，否则 false。</td>
</tr>
<tr>
<td align="center">&gt;=</td>
<td align="center">大于或等于</td>
<td align="center">price&gt;=9.80</td>
<td align="center">如果 price 是 9.90，则返回 true，否则 false。</td>
</tr>
<tr>
<td align="center">or</td>
<td align="center">或</td>
<td align="center">price=9.80 or price=9.70</td>
<td align="center">如果 price 是 9.80，则返回 true，否则 false。</td>
</tr>
<tr>
<td align="center">and</td>
<td align="center">与</td>
<td align="center">price&gt;9.00 and price&lt;9.90</td>
<td align="center">如果 price 是 9.80，则返回 true，否则 false。</td>
</tr>
<tr>
<td align="center">mod</td>
<td align="center">计算除法的余数</td>
<td align="center">5 mod 2</td>
<td align="center">1</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>forupdate的用法</title>
    <url>/2020/08/30/16/30/forupdate%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>for update的作用和用法<a id="more"></a></p>
<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>for update是一种行级锁，又叫排它锁，一旦用户对某个行施加了行级加锁，则该用户可以查询也可以更新被加锁的数据行，其它用户只能查询但不能更新被加锁的数据行．如果其它用户想更新该表中的数据行，则也必须对该表施加行级锁．即使多个用户对一个表均使用了共享更新，但也不允许两个事务同时对一个表进行更新，真正对表进行更新时，是以独占方式锁表，一直到提交或复原该事务为止。行锁永远是独占方式锁。</p>
<p>只有当出现如下之一的条件，才会释放共享更新锁：</p>
<p>1、执行提交（COMMIT）语句</p>
<p>2、退出数据库（LOG　OFF）</p>
<p>3、程序停止运行</p>
<h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><p>通常情况下，select语句是不会对数据加锁，妨碍影响其他的DML和DDL操作。同时，在多版本一致读机制的支持下，select语句也不会被其他类型语句所阻碍。</p>
<p>而select … for update 语句是我们经常使用手工加锁语句。在数据库中执行select … for update ,大家会发现会对数据库中的表或某些行数据进行锁表，在mysql中，如果查询条件带有主键，会锁行数据，如果没有，会锁表。</p>
<p> 由于InnoDB预设是Row-Level Lock，所以只有「明确」的指定主键，MySQL才会执行Row lock (只锁住被选取的资料例) ，否则MySQL将会执行Table Lock (将整个资料表单给锁住)。</p>
<p>举个例子: 假设有张表user ，里面有 id 和 name 两列，id是主键。</p>
<p> 例1: (明确指定主键，并且数据真实存在，row lock)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">3</span> <span class="keyword">and</span> <span class="keyword">name</span>=<span class="string">&#x27;Tom&#x27;</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>例2: (明确指定主键，但数据不存在，无lock)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">0</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>例3: (主键不明确，table lock)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>&lt;&gt;<span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%3%&#x27;</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>例4: (无主键，table lock)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">&#x27;Tom&#x27;</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<p>1、FOR UPDATE仅适用于InnoDB，且必须在事务处理模块(BEGIN/COMMIT)中才能生效。</p>
<p>2、要测试锁定的状况，可以利用MySQL的Command Mode(命令模式) ，开两个视窗来做测试。</p>
<p>3、Myisam 只支持表级锁，InnerDB支持行级锁 添加了(行级锁/表级锁)锁的数据不能被其它事务再锁定，也不被其它事务修改。是表级锁时，不管是否查询到记录，都会锁定表。</p>
<h5 id="什么时候需要使用"><a href="#什么时候需要使用" class="headerlink" title="什么时候需要使用"></a>什么时候需要使用</h5><p>借助for update语句，我们可以在应用程序的层面手工实现数据加锁保护操作。就是那些需要业务层面数据独占时，可以考虑使用for update。</p>
<p>场景上，比如火车票订票，在屏幕上显示有票，而真正进行出票时，需要重新确定一下这个数据没有被其他客户端修改。所以，在这个确认过程中，可以使用for update。</p>
<h5 id="for-update悲观锁"><a href="#for-update悲观锁" class="headerlink" title="for update悲观锁"></a>for update悲观锁</h5><p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它解锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。就像for update，再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。</p>
<p>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>java获取操作系统信息</title>
    <url>/2019/11/26/10/40/java%E8%8E%B7%E5%8F%96%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p>常用操作系统信息获取<a id="more"></a></p>
<h6 id="获取本机的IP地址"><a href="#获取本机的IP地址" class="headerlink" title="获取本机的IP地址:"></a>获取本机的IP地址:</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getIpAddress</span><span class="params">()</span> <span class="keyword">throws</span> UnknownHostException </span>&#123; </span><br><span class="line">    InetAddress address = InetAddress.getLocalHost(); </span><br><span class="line">    <span class="keyword">return</span> address.getHostAddress(); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h6 id="获取网卡地址"><a href="#获取网卡地址" class="headerlink" title="获取网卡地址:"></a>获取网卡地址:</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMACAddress</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String address = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    String os = System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">    String osUser = System.getProperty(<span class="string">&quot;user.name&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(os != <span class="keyword">null</span> &amp;&amp; os.startsWith(<span class="string">&quot;Windows&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            String command = <span class="string">&quot;cmd.exe /c ipconfig /all&quot;</span>;</span><br><span class="line">            Process  p = Runtime.getRuntime().exec(command);</span><br><span class="line">            BufferedReader buffer = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(p.getInputStream()));</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span>((line = buffer.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(line.indexOf(<span class="string">&quot;Physical Address&quot;</span>) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> index = line.indexOf(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">                    index += <span class="number">2</span>;</span><br><span class="line">                    address = line.substring(index);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.close();</span><br><span class="line">            <span class="keyword">return</span> address.trim();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="获取操作系统账号"><a href="#获取操作系统账号" class="headerlink" title="获取操作系统账号"></a>获取操作系统账号</h6><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">String osUser = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>get<span class="constructor">Property(<span class="string">&quot;user.name&quot;</span>)</span>;</span><br></pre></td></tr></table></figure>

<h6 id="获取操作系统版本"><a href="#获取操作系统版本" class="headerlink" title="获取操作系统版本:"></a>获取操作系统版本:</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Properties; </span><br><span class="line"></span><br><span class="line">Properties props=System.getProperties(); <span class="comment">//获得系统属性集    </span></span><br><span class="line">String osName = props.getProperty(<span class="string">&quot;os.name&quot;</span>); <span class="comment">//操作系统名称    </span></span><br><span class="line">String osArch = props.getProperty(<span class="string">&quot;os.arch&quot;</span>); <span class="comment">//操作系统构架    </span></span><br><span class="line">String osVersion = props.getProperty(<span class="string">&quot;os.version&quot;</span>); <span class="comment">//操作系统版本</span></span><br></pre></td></tr></table></figure>

<h6 id="一些常用信息获得"><a href="#一些常用信息获得" class="headerlink" title="一些常用信息获得"></a>一些常用信息获得</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getProperty</span><span class="params">(String key)</span></span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>键</th>
<th>相关值的描述</th>
</tr>
</thead>
<tbody><tr>
<td>java.version</td>
<td>Java 运行时环境版本</td>
</tr>
<tr>
<td>java.vendor</td>
<td>Java 运行时环境供应商</td>
</tr>
<tr>
<td>java.vendor.url</td>
<td>Java 供应商的 URL</td>
</tr>
<tr>
<td>java.home</td>
<td>Java 安装目录</td>
</tr>
<tr>
<td>java.vm.specification.version</td>
<td>Java 虚拟机规范版本</td>
</tr>
<tr>
<td>java.vm.specification.vendor</td>
<td>Java 虚拟机规范供应商</td>
</tr>
<tr>
<td>java.vm.specification.name</td>
<td>Java 虚拟机规范名称</td>
</tr>
<tr>
<td>java.vm.version</td>
<td>Java 虚拟机实现版本</td>
</tr>
<tr>
<td>java.vm.vendor</td>
<td>Java 虚拟机实现供应商</td>
</tr>
<tr>
<td>java.vm.name</td>
<td>Java 虚拟机实现名称</td>
</tr>
<tr>
<td>java.specification.version</td>
<td>Java 运行时环境规范版本</td>
</tr>
<tr>
<td>java.specification.vendor</td>
<td>Java 运行时环境规范供应商</td>
</tr>
<tr>
<td>java.specification.name</td>
<td>Java 运行时环境规范名称</td>
</tr>
<tr>
<td>java.<strong>class</strong>.version</td>
<td>Java 类格式版本号</td>
</tr>
<tr>
<td>java.<strong>class</strong>.path</td>
<td>Java 类路径</td>
</tr>
<tr>
<td>java.library.path</td>
<td>加载库时搜索的路径列表</td>
</tr>
<tr>
<td>java.io.tmpdir</td>
<td>默认的临时文件路径</td>
</tr>
<tr>
<td>java.compiler</td>
<td>要使用的 JIT 编译器的名称</td>
</tr>
<tr>
<td>java.ext.dirs</td>
<td>一个或多个扩展目录的路径</td>
</tr>
<tr>
<td>file.separator</td>
<td>文件分隔符（在 UNIX 系统中是“/”）</td>
</tr>
<tr>
<td>path.separator</td>
<td>路径分隔符（在 UNIX 系统中是“:”）</td>
</tr>
<tr>
<td>line.separator</td>
<td>行分隔符（在 UNIX 系统中是“/n”）</td>
</tr>
<tr>
<td>user.name</td>
<td>用户的账户名称</td>
</tr>
<tr>
<td>user.home</td>
<td>用户的主目录</td>
</tr>
<tr>
<td>user.dir</td>
<td>用户的当前工作目录</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>lag和lead函数</title>
    <url>/2020/08/25/22/34/lag%E5%92%8Clead%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>oracle分析函数lag()和lead()<a id="more"></a></p>
<h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>lag与lead函数是跟偏移量相关的两个分析函数，通过这两个函数可以在一次查询中取出同一字段的前N行的数据(lag)和后N行的数据(lead)作为独立的列,从而更方便地进行进行数据过滤。这种操作可以代替表的自连接，并且LAG和LEAD有更高的效率。</p>
<p>over()表示 lag()与lead()操作的数据都在over()的范围内，它里面可以使用partition by 语句分组，order by 语句排序。partition by a order by b表示以a字段进行分组，再 以b字段进行排序，对数据进行查询。</p>
<p>例如：lead(field, num, defaultvalue) field需要查找的字段，num往后查找的num行的数据，defaultvalue没有符合条件的默认值。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><ul>
<li>获取当前记录的id，以及下一条记录的id  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select t.id id ,</span><br><span class="line">       lead(t.id, 1, null) over (order by t.id)  next_record_id, t.cphm</span><br><span class="line">from tb_test t       </span><br><span class="line">  order by t.id asc</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/25/22/34/lag%E5%92%8Clead%E5%87%BD%E6%95%B0/lag.png" alt></p>
<ul>
<li>获取当前记录的id，以及上一条记录的id</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select t.id id ,</span><br><span class="line">       lag(t.id, 1, null) over (order by t.id)  next_record_id, t.cphm</span><br><span class="line">from tb_test t       </span><br><span class="line">  order by t.id asc</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/25/22/34/lag%E5%92%8Clead%E5%87%BD%E6%95%B0/lead.png" alt></p>
<ul>
<li>获取号牌号码相同的，当前记录的id与，下一条记录的id（使用partition by）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select t.id id, </span><br><span class="line">       lead(t.id, 1, null) over(partition by cphm order by t.id) next_same_cphm_id, t.cphm</span><br><span class="line">from tb_test t</span><br><span class="line">     order by t.id asc   </span><br></pre></td></tr></table></figure>


<p><img src="/2020/08/25/22/34/lag%E5%92%8Clead%E5%87%BD%E6%95%B0/lead2.png" alt>  </p>
<ul>
<li>查询 cphm的总数，当create_date与下一条记录的create_date时间间隔不超过10分钟则忽略。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select cphm, count(1) total from</span><br><span class="line">(</span><br><span class="line">select t.id,</span><br><span class="line">  t.create_date t1,</span><br><span class="line">  lead(t.create_date,1, null) over( partition by  cphm order by create_date asc ) t2,</span><br><span class="line">  ( lead(t.create_date,1, null) over(  partition by  cphm order by create_date asc )  - t.create_date ) * 86400 as itvtime,</span><br><span class="line">  t.cphm</span><br><span class="line">from tb_test t</span><br><span class="line">  order by t.cphm, t.create_date asc</span><br><span class="line">) tt</span><br><span class="line">where tt.itvtime &gt;&#x3D; 600 or  tt.itvtime  is null</span><br><span class="line">group by tt.cphm</span><br></pre></td></tr></table></figure>

<p><img src="/2020/08/25/22/34/lag%E5%92%8Clead%E5%87%BD%E6%95%B0/lead3.png" alt></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql5.7分组排序后取每组最新一条</title>
    <url>/2020/08/01/08/31/mysql5-7%E5%88%86%E7%BB%84%E6%8E%92%E5%BA%8F%E5%90%8E%E5%8F%96%E6%AF%8F%E7%BB%84%E6%9C%80%E6%96%B0%E4%B8%80%E6%9D%A1/</url>
    <content><![CDATA[<p>在mysql5.7版本上实现的，目前mysql8.0已经可以使用分析函数了，不需要那么麻烦了。<a id="more"></a></p>
<h6 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h6><p>一张表内有ID、时间、描述信息等，依据ID找出最新时间的一条描述信息。</p>
<h6 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h6><p>先按照ID进行分组，然后对时间进行倒序排序，选出最新的一条记录。</p>
<h6 id="测试表结构"><a href="#测试表结构" class="headerlink" title="测试表结构"></a>测试表结构</h6><p>与实现有关的字段有task_id、dl_time、dl_dscr。</p>
<h6 id="Mysql实现方法"><a href="#Mysql实现方法" class="headerlink" title="Mysql实现方法"></a>Mysql实现方法</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	* </span><br><span class="line">FROM</span><br><span class="line">	dq_ld_log AS b </span><br><span class="line">WHERE</span><br><span class="line">	NOT EXISTS (</span><br><span class="line">	SELECT</span><br><span class="line">		1 </span><br><span class="line">	FROM</span><br><span class="line">		dq_dl_log </span><br><span class="line">	WHERE</span><br><span class="line">	task_id &#x3D; b.task_id </span><br><span class="line">	AND b.dl_time &lt; dl_time)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	* </span><br><span class="line">FROM</span><br><span class="line">	( SELECT dl_time, task_id, dl_dscr FROM dq_dl_log GROUP BY task_id DESC ) t </span><br><span class="line">ORDER BY</span><br><span class="line">	t.dl_time</span><br></pre></td></tr></table></figure>

<h6 id="Oracle实现方法"><a href="#Oracle实现方法" class="headerlink" title="Oracle实现方法"></a>Oracle实现方法</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	row_number() over ( PARTITION BY task_id ORDER BY dl_time ) rank </span><br><span class="line">FROM</span><br><span class="line">	dq_dl_log </span><br><span class="line">WHERE</span><br><span class="line">	rank &#x3D; 1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle中的数学公式</title>
    <url>/2020/08/22/18/26/oracle%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<p>oracle中的数学公式函数<a id="more"></a></p>
<h5 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h5><p>COVAR_POP 函数 [集合]：返回一组数字对的总体协方差。</p>
<h6 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COVAR_POP (&lt;dependent-expression&gt;, &lt;independent-expression&gt;)</span><br></pre></td></tr></table></figure>

<h6 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h6><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>dependent-expression</td>
<td>受独立变量影响的变量</td>
</tr>
<tr>
<td>independent-expression</td>
<td>影响结果的变量</td>
</tr>
</tbody></table>
<h6 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h6><p>此函数将其参数转换为 DOUBLE，执行双精度浮点计算，并返回一个 DOUBLE 作为结果。如果将 <em>COVAR_POP</em> 应用于空集，它将返回 NULL。</p>
<p>dependent-expression 和 independent-expression 都是数值。在消除 dependent-expression 或 independent-expression 为 NULL 的值对之后，系统会将此函数应用于 dependent-expression 和 independent-expression 的集合。然后执行以下计算：<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="40.58ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 17936.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"/><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(389, 0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g><g data-mml-node="mi" transform="translate(1034, 0)"><path data-c="1D448" d="M107 637Q73 637 71 641Q70 643 70 649Q70 673 81 682Q83 683 98 683Q139 681 234 681Q268 681 297 681T342 682T362 682Q378 682 378 672Q378 670 376 658Q371 641 366 638H364Q362 638 359 638T352 638T343 637T334 637Q295 636 284 634T266 623Q265 621 238 518T184 302T154 169Q152 155 152 140Q152 86 183 55T269 24Q336 24 403 69T501 205L552 406Q599 598 599 606Q599 633 535 637Q511 637 511 648Q511 650 513 660Q517 676 519 679T529 683Q532 683 561 682T645 680Q696 680 723 681T752 682Q767 682 767 672Q767 650 759 642Q756 637 737 637Q666 633 648 597Q646 592 598 404Q557 235 548 205Q515 105 433 42T263 -22Q171 -22 116 34T60 167V183Q60 201 115 421Q164 622 164 628Q164 635 107 637Z"/></g><g data-mml-node="mi" transform="translate(1801, 0)"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"/></g><g data-mml-node="mo" transform="translate(2852, 0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(3241, 0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mo" transform="translate(4035.2, 0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"/></g><g data-mml-node="mi" transform="translate(4757.4, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(5247.4, 0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(5858.7, 0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mi" transform="translate(6858.9, 0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g><g data-mml-node="mi" transform="translate(7503.9, 0)"><path data-c="1D448" d="M107 637Q73 637 71 641Q70 643 70 649Q70 673 81 682Q83 683 98 683Q139 681 234 681Q268 681 297 681T342 682T362 682Q378 682 378 672Q378 670 376 658Q371 641 366 638H364Q362 638 359 638T352 638T343 637T334 637Q295 636 284 634T266 623Q265 621 238 518T184 302T154 169Q152 155 152 140Q152 86 183 55T269 24Q336 24 403 69T501 205L552 406Q599 598 599 606Q599 633 535 637Q511 637 511 648Q511 650 513 660Q517 676 519 679T529 683Q532 683 561 682T645 680Q696 680 723 681T752 682Q767 682 767 672Q767 650 759 642Q756 637 737 637Q666 633 648 597Q646 592 598 404Q557 235 548 205Q515 105 433 42T263 -22Q171 -22 116 34T60 167V183Q60 201 115 421Q164 622 164 628Q164 635 107 637Z"/></g><g data-mml-node="mi" transform="translate(8270.9, 0)"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"/></g><g data-mml-node="mo" transform="translate(9321.9, 0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(9710.9, 0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mo" transform="translate(10282.9, 0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(10894.1, 0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"/></g><g data-mml-node="mi" transform="translate(11616.3, 0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g><g data-mml-node="mi" transform="translate(12261.3, 0)"><path data-c="1D448" d="M107 637Q73 637 71 641Q70 643 70 649Q70 673 81 682Q83 683 98 683Q139 681 234 681Q268 681 297 681T342 682T362 682Q378 682 378 672Q378 670 376 658Q371 641 366 638H364Q362 638 359 638T352 638T343 637T334 637Q295 636 284 634T266 623Q265 621 238 518T184 302T154 169Q152 155 152 140Q152 86 183 55T269 24Q336 24 403 69T501 205L552 406Q599 598 599 606Q599 633 535 637Q511 637 511 648Q511 650 513 660Q517 676 519 679T529 683Q532 683 561 682T645 680Q696 680 723 681T752 682Q767 682 767 672Q767 650 759 642Q756 637 737 637Q666 633 648 597Q646 592 598 404Q557 235 548 205Q515 105 433 42T263 -22Q171 -22 116 34T60 167V183Q60 201 115 421Q164 622 164 628Q164 635 107 637Z"/></g><g data-mml-node="mi" transform="translate(13028.3, 0)"><path data-c="1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"/></g><g data-mml-node="mo" transform="translate(14079.3, 0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(14468.3, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(14958.3, 0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(15347.3, 0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mi" transform="translate(15847.3, 0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(16447.3, 0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(16836.3, 0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mi" transform="translate(17336.3, 0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> {}<br>其中 x 表示 dependent-expression，y 表示 independent-expression。</p>
<h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> owner, <span class="keyword">COVAR_POP</span>(avg_row_len, avg_space)</span><br><span class="line"> <span class="keyword">from</span> all_tables</span><br><span class="line"> <span class="keyword">group</span> <span class="keyword">by</span> owner;</span><br></pre></td></tr></table></figure>

<p>[^注意]: GROUP BY 子句不支持 ROLLUP 和 CUBE。DISTINCT 不受支持。</p>
<h5 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h5><p> VAR_POP 函数 [集合]：计算由 numeric-expression 组成的总体的统计方差，类型为 DOUBLE。返回值DOUBLE。</p>
<h6 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VAR_POP ( [ ALL ] &lt;expression&gt; )</span><br></pre></td></tr></table></figure>

<h6 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h6><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>expression</td>
<td>要对一组行计算基于总体的方差的表达式（通常是列名）</td>
</tr>
</tbody></table>
<h6 id="注释-1"><a href="#注释-1" class="headerlink" title="注释"></a>注释</h6><p>计算所提供的针对每个组行或分区行（如果指定了 DISTINCT，则为在消除重复项后剩余的各行）求值的 <value expression> 的总体方差，其定义为：<value expression> 与 <value expression> 均值之差的平方和，然后再除以组中或分区中剩余的行数。</value></value></value></p>
<p>基于总体的方差是根据以下公式计算的：<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -1.018ex" xmlns="http://www.w3.org/2000/svg" width="16.298ex" height="3.167ex" role="img" focusable="false" viewbox="0 -950 7203.7 1400"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"/><g data-mml-node="mo" transform="translate(166.7, 0)"><path data-c="2211" d="M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z"/></g><g data-mml-node="mo" transform="translate(1610.7, 0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1999.7, 0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mi" transform="translate(2571.7, 0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3138.9, 0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mi" transform="translate(4139.1, 0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(4711.1, 0)"><g data-mml-node="mo"><text data-variant="normal" transform="matrix(1 0 0 -1 0 0)" font-size="884px" font-family="serif">̅</text></g></g><g data-mml-node="msup" transform="translate(5311.1, 0)"><g data-mml-node="mo"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mn" transform="translate(389, 413) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(6103.7, 0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mi" transform="translate(6603.7, 0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> {}</p>
<h6 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h6><p>以下语句列出不同时间段每个订单的产品数目的平均值和方差：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">year</span>( ShipDate ) <span class="keyword">AS</span> <span class="keyword">Year</span>, <span class="keyword">quarter</span>( ShipDate )</span><br><span class="line">  <span class="keyword">AS</span> <span class="keyword">Quarter</span>, <span class="keyword">AVG</span>( Quantity ) <span class="keyword">AS</span> Average, </span><br><span class="line">  VAR_POP( Quantity ) <span class="keyword">AS</span> <span class="keyword">Variance</span> </span><br><span class="line"><span class="keyword">FROM</span> SalesOrderItems <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">Year</span>, <span class="keyword">Quarter</span> </span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">Year</span>, <span class="keyword">Quarter</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">年</th>
<th align="left">季度</th>
<th align="left">平均值</th>
<th align="left">方差</th>
</tr>
</thead>
<tbody><tr>
<td align="left">2000</td>
<td align="left">1</td>
<td align="left">25.775148</td>
<td align="left">203.9021</td>
</tr>
<tr>
<td align="left">2000</td>
<td align="left">2</td>
<td align="left">27.050847</td>
<td align="left">225.8109</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle分析函数over</title>
    <url>/2020/07/28/23/49/oracle%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0over/</url>
    <content><![CDATA[<p>Over()分析函数的使用<a id="more"></a></p>
<h4 id="Over-分析函数"><a href="#Over-分析函数" class="headerlink" title="Over()分析函数"></a>Over()分析函数</h4><p>聚合函数（如sum()、max()等）可以计算基于组的某种聚合值，但是聚合函数对于某个组只能返回一行记录。若想对于某组返回多行记录，则需要使用分析函数。</p>
<h5 id="rank-dense-rank-over-partition-by-…-order-by-…"><a href="#rank-dense-rank-over-partition-by-…-order-by-…" class="headerlink" title="rank()/dense_rank over(partition by … order by …)"></a>rank()/dense_rank over(partition by … order by …)</h5><p>说明：over()在什么条件之上; </p>
<p>　　partition by 按哪个字段划分组；</p>
<p>　　order by 按哪个字段排序；</p>
<p>注意：</p>
<p>　　（1）使用rank()/dense_rank() 时，必须要带order by否则非法</p>
<p>　　（2）rank()/dense_rank()分级的区别：</p>
<p>rank(): 跳跃排序，如果有两个第一级时，接下来就是第三级。</p>
<p>dense_rank(): 连续排序，如果有两个第一级时，接下来仍然是第二级。</p>
<p>示例：查询每个部门工资最高的员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> E.ENAME, E.JOB, E.SAL, E.DEPTNO</span><br><span class="line">  <span class="keyword">FROM</span> SCOTT.EMP E,</span><br><span class="line">       (<span class="keyword">SELECT</span> E.DEPTNO, <span class="keyword">MAX</span>(E.SAL) SAL <span class="keyword">FROM</span> SCOTT.EMP E <span class="keyword">GROUP</span> <span class="keyword">BY</span> E.DEPTNO) ME</span><br><span class="line"> <span class="keyword">WHERE</span> E.DEPTNO = ME.DEPTNO</span><br><span class="line">   <span class="keyword">AND</span> E.SAL = ME.SAL;</span><br></pre></td></tr></table></figure>

<p>使用Over()函数：</p>
<p>方法一：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> E.ENAME, E.JOB, E.SAL, E.DEPTNO</span><br><span class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> E.ENAME,</span><br><span class="line">               E.JOB,</span><br><span class="line">               E.SAL,</span><br><span class="line">               E.DEPTNO,</span><br><span class="line">               <span class="keyword">RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> E.DEPTNO <span class="keyword">ORDER</span> <span class="keyword">BY</span> E.SAL <span class="keyword">DESC</span>) <span class="keyword">RANK</span>  <span class="comment">--在按部门划分的基础上，工资从高到低分级，级别RANK从1开始依次递增</span></span><br><span class="line">          <span class="keyword">FROM</span> EMP E) E</span><br><span class="line"> <span class="keyword">WHERE</span> E.RANK = <span class="number">1</span> ;</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> E.ENAME, E.JOB, E.SAL, E.DEPTNO</span><br><span class="line"> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> E.ENAME,</span><br><span class="line">              E.JOB,</span><br><span class="line">              E.SAL,</span><br><span class="line">              E.DEPTNO,</span><br><span class="line">              <span class="keyword">DENSE_RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> E.DEPTNO <span class="keyword">ORDER</span> <span class="keyword">BY</span> E.SAL <span class="keyword">DESC</span>) <span class="keyword">RANK</span></span><br><span class="line">         <span class="keyword">FROM</span> EMP E) E</span><br><span class="line"><span class="keyword">WHERE</span> E.RANK = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>对比查询结果：左边的是用一般的方法查询结果，右边的是分析函数查询结果（两种方法结果相同）</p>
<p><img src="/2020/07/28/23/49/oracle%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0over/sql.jpg" alt></p>
<h5 id="min-max-over-partition-by-…"><a href="#min-max-over-partition-by-…" class="headerlink" title="min()/max() over(partition by …)"></a>min()/max() over(partition by …)</h5><p>查询员工信息的同时，查询员工工资与所在部门最低、最高工资的差额</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> E.ENAME,</span><br><span class="line">       E.JOB,</span><br><span class="line">       E.SAL,</span><br><span class="line">       E.DEPTNO,</span><br><span class="line">       E.SAL - ME.MIN_SAL DIFF_MIN_SAL,</span><br><span class="line">       ME.MAX_SAL - E.SAL DIFF_MAX_SAL</span><br><span class="line">  <span class="keyword">FROM</span> SCOTT.EMP E,</span><br><span class="line">       (<span class="keyword">SELECT</span> E.DEPTNO, <span class="keyword">MIN</span>(E.SAL) MIN_SAL, <span class="keyword">MAX</span>(E.SAL) MAX_SAL</span><br><span class="line">          <span class="keyword">FROM</span> SCOTT.EMP E</span><br><span class="line">         <span class="keyword">GROUP</span> <span class="keyword">BY</span> E.DEPTNO) ME</span><br><span class="line"> <span class="keyword">WHERE</span> E.DEPTNO = ME.DEPTNO</span><br><span class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> E.DEPTNO, E.SAL;</span><br></pre></td></tr></table></figure>

<p>使用分析函数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> E.ENAME,</span><br><span class="line">       E.JOB,</span><br><span class="line">       E.SAL,</span><br><span class="line">       E.DEPTNO,</span><br><span class="line">       <span class="keyword">MIN</span>(E.SAL) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> E.DEPTNO) MIN_SAL,</span><br><span class="line">       <span class="keyword">MAX</span>(E.SAL) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> E.DEPTNO) MAX_SAL,</span><br><span class="line">       NVL(E.SAL - <span class="keyword">MIN</span>(E.SAL) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> E.DEPTNO), <span class="number">0</span>) DIFF_MIN_SAL,</span><br><span class="line">       NVL(<span class="keyword">MAX</span>(E.SAL) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> E.DEPTNO) - E.SAL, <span class="number">0</span>) DIFF_MAX_SAL</span><br><span class="line">  <span class="keyword">FROM</span> EMP E;</span><br></pre></td></tr></table></figure>

<p>注：这里没有排序条件，若加上order by 排序条件，</p>
<p>MAX() OVER(PARTITION BY .. ORDER BY .. DESC) 排序规则只能为desc，否则不起作用，将查询到目前为止排序值最高字段的对应值<br>MIN() OVER(PARTITION BY .. ORDER BY .. ASC ) 排序规则只能为asc，否则不起作用，将查询到目前为止排序值最低的字段的对应值，</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> E.ENAME,</span><br><span class="line">       E.JOB,</span><br><span class="line">       E.SAL,</span><br><span class="line">       E.DEPTNO,</span><br><span class="line">       <span class="keyword">MIN</span>(E.SAL) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> E.DEPTNO) MIN_SAL01,</span><br><span class="line">       <span class="keyword">MAX</span>(E.SAL) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> E.DEPTNO) MAX_SAL01,</span><br><span class="line">       <span class="keyword">MIN</span>(E.SAL) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> E.DEPTNO <span class="keyword">ORDER</span> <span class="keyword">BY</span> E.SAL) MIN_SAL02,</span><br><span class="line">       <span class="keyword">MAX</span>(E.SAL) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> E.DEPTNO <span class="keyword">ORDER</span> <span class="keyword">BY</span> E.SAL) MAX_SAL02, <span class="comment">--不起作用</span></span><br><span class="line">       <span class="keyword">MIN</span>(E.SAL) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> E.DEPTNO <span class="keyword">ORDER</span> <span class="keyword">BY</span> E.SAL <span class="keyword">DESC</span>) MIN_SAL03, <span class="comment">--不起作用</span></span><br><span class="line">       <span class="keyword">MAX</span>(E.SAL) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> E.DEPTNO <span class="keyword">ORDER</span> <span class="keyword">BY</span> E.SAL <span class="keyword">DESC</span>) MAX_SAL03,</span><br><span class="line">       <span class="keyword">MIN</span>(E.SAL) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> E.DEPTNO <span class="keyword">ORDER</span> <span class="keyword">BY</span> E.SAL <span class="keyword">ASC</span>) MIN_SAL04,</span><br><span class="line">       <span class="keyword">MAX</span>(E.SAL) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> E.DEPTNO <span class="keyword">ORDER</span> <span class="keyword">BY</span> E.SAL <span class="keyword">ASC</span>) MAX_SAL04, <span class="comment">--不起作用</span></span><br><span class="line">       NVL(E.SAL - <span class="keyword">MIN</span>(E.SAL) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> E.DEPTNO), <span class="number">0</span>) DIFF_MIN_SAL,</span><br><span class="line">       NVL(<span class="keyword">MAX</span>(E.SAL) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> E.DEPTNO) - E.SAL, <span class="number">0</span>) DIFF_MAX_SAL</span><br><span class="line">  <span class="keyword">FROM</span> EMP E;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/2020/07/28/23/49/oracle%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0over/oracle.jpg" alt></p>
<h5 id="lead-lag-over-partition-by-…-order-by-…-取前面-后面第n行记录"><a href="#lead-lag-over-partition-by-…-order-by-…-取前面-后面第n行记录" class="headerlink" title="lead()/lag() over(partition by … order by …) 取前面/后面第n行记录"></a>lead()/lag() over(partition by … order by …) 取前面/后面第n行记录</h5><p>说明：</p>
<p>lead(列名,n,m): 当前记录后面第n行记录的&lt;列名&gt;的值，没有则默认值为m；如果不带参数n,m，则查找当前记录后面第一行的记录&lt;列名&gt;的值，没有则默认值为null。<br>lag(列名,n,m): 当前记录前面第n行记录的&lt;列名&gt;的值，没有则默认值为m；如果不带参数n,m，则查找当前记录前面第一行的记录&lt;列名&gt;的值，没有则默认值为null。</p>
<p>示例：查询个人工资与比自己高一位、第一位的工资的差额</p>
<p>使用分析函数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> E.ENAME,</span><br><span class="line">        E.JOB,</span><br><span class="line">        E.SAL,</span><br><span class="line">        E.DEPTNO,</span><br><span class="line">        <span class="keyword">LEAD</span>(E.SAL, <span class="number">1</span>, <span class="number">0</span>) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> E.DEPTNO <span class="keyword">ORDER</span> <span class="keyword">BY</span> E.SAL) LEAD_SAL, <span class="comment">--记录后面第n行记录</span></span><br><span class="line">        LAG(E.SAL, <span class="number">1</span>, <span class="number">0</span>) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> E.DEPTNO <span class="keyword">ORDER</span> <span class="keyword">BY</span> E.SAL) LAG_SAL, <span class="comment">--记录前面第N行记录</span></span><br><span class="line">        NVL(<span class="keyword">LEAD</span>(E.SAL) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> E.DEPTNO <span class="keyword">ORDER</span> <span class="keyword">BY</span> E.SAL) - E.SAL,  </span><br><span class="line">            <span class="number">0</span>) DIFF_LEAD_SAL,</span><br><span class="line">        NVL(E.SAL - <span class="keyword">LEAD</span>(E.SAL) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> E.DEPTNO <span class="keyword">ORDER</span> <span class="keyword">BY</span> E.SAL),</span><br><span class="line">            <span class="number">0</span>) DIFF_LAG_SAL</span><br><span class="line">   <span class="keyword">FROM</span> EMP E;</span><br></pre></td></tr></table></figure>

<p>查询结果：</p>
<p><img src="/2020/07/28/23/49/oracle%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0over/lead.jpg" alt></p>
<h5 id="FIRST-VALUE-LAST-VALUE-OVER-PARTITION-BY-…-取首尾记录"><a href="#FIRST-VALUE-LAST-VALUE-OVER-PARTITION-BY-…-取首尾记录" class="headerlink" title="FIRST_VALUE/LAST_VALUE() OVER(PARTITION BY …) 取首尾记录"></a>FIRST_VALUE/LAST_VALUE() OVER(PARTITION BY …) 取首尾记录</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> E.EMPNO,</span><br><span class="line">        E.ENAME,</span><br><span class="line">        E.JOB,</span><br><span class="line">        E.MGR,</span><br><span class="line">        E.SAL,</span><br><span class="line">        E.DEPTNO,</span><br><span class="line">        <span class="keyword">FIRST_VALUE</span>(E.SAL) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> E.DEPTNO) FIRST_SAL,</span><br><span class="line">        <span class="keyword">LAST_VALUE</span>(E.SAL) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> E.DEPTNO) LAST_SAL</span><br><span class="line">   <span class="keyword">FROM</span> EMP E;</span><br></pre></td></tr></table></figure>

<p>查询结果：</p>
<p><img src="/2020/07/28/23/49/oracle%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0over/first.jpg" alt="first"></p>
<h5 id="ROW-NUMBER-OVER-PARTITION-BY-ORDER-BY-排序（应用：分页）"><a href="#ROW-NUMBER-OVER-PARTITION-BY-ORDER-BY-排序（应用：分页）" class="headerlink" title="ROW_NUMBER() OVER(PARTITION BY.. ORDER BY ..) 排序（应用：分页）"></a>ROW_NUMBER() OVER(PARTITION BY.. ORDER BY ..) 排序（应用：分页）</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> E.ENAME, E.JOB, E.SAL, E.DEPTNO,E.ROW_NUM</span><br><span class="line">   <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> E.ENAME,</span><br><span class="line">                E.JOB,</span><br><span class="line">                E.SAL,</span><br><span class="line">                E.DEPTNO,</span><br><span class="line">                ROW_NUMBER() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> E.DEPTNO <span class="keyword">ORDER</span> <span class="keyword">BY</span> E.SAL) ROW_NUM</span><br><span class="line">           <span class="keyword">FROM</span> EMP E) E</span><br><span class="line">  <span class="keyword">WHERE</span> E.ROW_NUM &gt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>查询结果：</p>
<p><img src="/2020/07/28/23/49/oracle%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0over/row.jpg" alt></p>
<p>补充：</p>
<p>类似分页的操作还可以用rownum、fetch(Oracle12C后的新特性)实现</p>
<h5 id="sum-avg-count-over-partition-by"><a href="#sum-avg-count-over-partition-by" class="headerlink" title="sum/avg/count() over(partition by ..)"></a>sum/avg/count() over(partition by ..)</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> E.ENAME,</span><br><span class="line">       E.JOB,</span><br><span class="line">       E.SAL,</span><br><span class="line">       E.DEPTNO,</span><br><span class="line">       <span class="keyword">SUM</span>(E.SAL) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> E.DEPTNO) SUM_SAL,     <span class="comment">--统计某组中的总计值</span></span><br><span class="line">       <span class="keyword">AVG</span>(E.SAL) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> E.DEPTNO) AVG_SAL,     <span class="comment">--统计某组中的平均值</span></span><br><span class="line">       <span class="keyword">COUNT</span>(E.SAL) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> E.DEPTNO) COUNT_SAL  <span class="comment">--按某列分组，并统计该组中记录数量</span></span><br><span class="line">  <span class="keyword">FROM</span> EMP E;</span><br></pre></td></tr></table></figure>

<p>查询结果：</p>
<p><img src="/2020/07/28/23/49/oracle%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0over/sum.jpg" alt></p>
<p>示例2（全统计）：为数据集统计部门销售总和，全公司销售总和，部门销售均值，全公司销售均值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.DEPT_ID,</span><br><span class="line">       A.SALE_DATE,</span><br><span class="line">       A.GOODS_TYPE,</span><br><span class="line">       A.SALE_CNT,</span><br><span class="line">       <span class="keyword">SUM</span>(A.SALE_CNT) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> A.DEPT_ID) DEPT_TOTAL, <span class="comment">--部门销售总和</span></span><br><span class="line">       <span class="keyword">SUM</span>(A.SALE_CNT) <span class="keyword">OVER</span>() CMP_TOTAL,  <span class="comment">--公司销售总额</span></span><br><span class="line">       <span class="keyword">AVG</span>(A.SALE_CNT) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> A.DEPT_ID) DEPT_AVG, <span class="comment">--部门销售均值</span></span><br><span class="line">       <span class="keyword">AVG</span>(A.SALE_CNT) <span class="keyword">OVER</span>() CMP_AVG  <span class="comment">--公司销售均值</span></span><br><span class="line">  <span class="keyword">FROM</span> LEARN_FUN_KEEP A;</span><br></pre></td></tr></table></figure>

<h5 id="rows-range-between-…-preceding-and-…-following-上下范围内求值"><a href="#rows-range-between-…-preceding-and-…-following-上下范围内求值" class="headerlink" title="rows/range between … preceding and … following 上下范围内求值"></a>rows/range between … preceding and … following 上下范围内求值</h5><p>说明：unbounded：不受控制的，无限的<br>　　　preceding：在…之前<br>　　　following：在…之后</p>
<p><strong>rows between … preceding and … following</strong></p>
<p>示例1：显示各部门员工的工资，并附带显示该部门的最高工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> E.DEPTNO,</span><br><span class="line">       E.EMPNO,</span><br><span class="line">       E.ENAME,</span><br><span class="line">       E.SAL,</span><br><span class="line">       <span class="keyword">LAST_VALUE</span>(E.SAL) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> E.DEPTNO <span class="keyword">ORDER</span> <span class="keyword">BY</span> E.SAL <span class="keyword">ROWS</span>       <span class="comment">/*MAX(E.SAL) OVER(PARTITION BY E.DEPTNO ORDER BY E.SAL ROWS*/</span></span><br><span class="line">       <span class="comment">--unbounded preceding and unbouned following针对当前所有记录的前一条、后一条记录，也就是表中的所有记录</span></span><br><span class="line">       <span class="comment">--unbounded：不受控制的，无限的</span></span><br><span class="line">       <span class="comment">--preceding：在...之前</span></span><br><span class="line">       <span class="comment">--following：在...之后</span></span><br><span class="line">        <span class="keyword">BETWEEN</span> <span class="keyword">UNBOUNDED</span> <span class="keyword">PRECEDING</span> <span class="keyword">AND</span> <span class="keyword">UNBOUNDED</span> <span class="keyword">FOLLOWING</span>) MAX_SAL</span><br><span class="line">  <span class="keyword">FROM</span> EMP E;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/2020/07/28/23/49/oracle%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0over/rows.jpg" alt></p>
<p>写法二:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> E.DEPTNO,</span><br><span class="line">       E.EMPNO,</span><br><span class="line">       E.ENAME,</span><br><span class="line">       E.SAL,</span><br><span class="line">       <span class="keyword">MAX</span>(E.SAL) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> E.DEPTNO</span><br><span class="line">       <span class="comment">/*ORDER BY E.SAL*/</span>) MAX_SAL</span><br><span class="line">  <span class="keyword">FROM</span> EMP E;</span><br></pre></td></tr></table></figure>

<p>示例2：对各部门进行分组，并附带显示第一行至当前行的汇总</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> EMPNO,</span><br><span class="line">       ENAME,</span><br><span class="line">       DEPTNO,</span><br><span class="line">       SAL,</span><br><span class="line">       <span class="comment">--注意ROWS BETWEEN unbounded preceding AND current row  是指第一行至当前行的汇总</span></span><br><span class="line">       <span class="keyword">SUM</span>(SAL) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> DEPTNO </span><br><span class="line">                     <span class="keyword">ORDER</span> <span class="keyword">BY</span> ENAME </span><br><span class="line">                     <span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> <span class="keyword">UNBOUNDED</span> <span class="keyword">PRECEDING</span> <span class="keyword">AND</span> <span class="keyword">CURRENT</span> <span class="keyword">ROW</span>) max_sal</span><br><span class="line">  <span class="keyword">FROM</span> SCOTT.EMP;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/2020/07/28/23/49/oracle%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0over/rows2.jpg" alt></p>
<p>示例3：当前行至最后一行的汇总</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> EMPNO,</span><br><span class="line">       ENAME,</span><br><span class="line">       DEPTNO,</span><br><span class="line">       SAL,</span><br><span class="line">       <span class="comment">--注意ROWS BETWEEN current row AND unbounded following 指当前行到最后一行的汇总</span></span><br><span class="line">       <span class="keyword">SUM</span>(SAL) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> DEPTNO </span><br><span class="line">                     <span class="keyword">ORDER</span> <span class="keyword">BY</span> ENAME </span><br><span class="line">                     <span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> <span class="keyword">CURRENT</span> <span class="keyword">ROW</span> <span class="keyword">AND</span> <span class="keyword">UNBOUNDED</span> <span class="keyword">FOLLOWING</span>) max_sal</span><br><span class="line">  <span class="keyword">FROM</span> SCOTT.EMP;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://images2015.cnblogs.com/blog/540755/201706/540755-20170621140513538-1201638924.png" alt="img"></p>
<p>示例4：当前行的上一行(rownum-1)到当前行的汇总</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> EMPNO,</span><br><span class="line">       ENAME,</span><br><span class="line">       DEPTNO,</span><br><span class="line">       SAL,</span><br><span class="line">       <span class="comment">--注意ROWS BETWEEN 1 preceding AND current row 是指当前行的上一行(rownum-1)到当前行的汇总 </span></span><br><span class="line">       <span class="keyword">SUM</span>(SAL) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> DEPTNO </span><br><span class="line">                     <span class="keyword">ORDER</span> <span class="keyword">BY</span> ENAME <span class="keyword">ROWS</span> </span><br><span class="line">                     <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">PRECEDING</span> <span class="keyword">AND</span> <span class="keyword">CURRENT</span> <span class="keyword">ROW</span>) max_sal</span><br><span class="line">  <span class="keyword">FROM</span> SCOTT.EMP;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://images2015.cnblogs.com/blog/540755/201706/540755-20170621140746882-1940488481.png" alt="img"></p>
<p>示例5：当前行的上一行(rownum-1)到当前行的下两行(rownum+2)的汇总 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> EMPNO,</span><br><span class="line">       ENAME,</span><br><span class="line">       DEPTNO,</span><br><span class="line">       SAL,</span><br><span class="line">       <span class="comment">--注意ROWS BETWEEN 1 preceding AND 1 following 是指当前行的上一行(rownum-1)到当前行的下辆行(rownum+2)的汇总</span></span><br><span class="line">       <span class="keyword">SUM</span>(SAL) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> DEPTNO </span><br><span class="line">                     <span class="keyword">ORDER</span> <span class="keyword">BY</span> ENAME </span><br><span class="line">                     <span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">PRECEDING</span> <span class="keyword">AND</span> <span class="number">2</span> <span class="keyword">FOLLOWING</span>) max_sal</span><br><span class="line">  <span class="keyword">FROM</span> SCOTT.EMP;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://images2015.cnblogs.com/blog/540755/201706/540755-20170621140921382-538208257.png" alt="img"></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle的存储过程</title>
    <url>/2020/08/27/23/02/oracle%E7%9A%84%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>oracle的存储过程用法<a id="more"></a></p>
<h5 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> PRODUCE 存储过程名</span><br><span class="line"><span class="keyword">IS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>CREATE OR REPLACE PROCEDURE 是一个SQL语句通知Oracle数据库去创建一个叫做skeleton存储过程, 如果存在就覆盖它;<br>　　IS关键词表明后面将跟随一个PL/SQL体。<br>　　BEGIN关键词表明PL/SQL体的开始。<br>　　NULL PL/SQL语句表明什么事都不做，这句不能删去，因为PL/SQL体中至少需要有一句;<br>　　END关键词表明PL/SQL体的结束</p>
<h5 id="创建语法"><a href="#创建语法" class="headerlink" title="创建语法"></a>创建语法</h5><p>create or replace procedure 存储过程名（param1 in type，param2 out type）as</p>
<p>变量1 类型（值范围）; –vs_msg VARCHAR2(4000);</p>
<p>变量2 类型（值范围）;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">Begin</span> </span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">count</span>(*) <span class="keyword">into</span> 变量<span class="number">1</span> <span class="keyword">from</span> 表A <span class="keyword">where</span>列名=param1； </span><br><span class="line"></span><br><span class="line"><span class="keyword">If</span> (判断条件) <span class="keyword">then</span> </span><br><span class="line"><span class="keyword">Select</span> 列名 <span class="keyword">into</span> 变量<span class="number">2</span> <span class="keyword">from</span> 表A <span class="keyword">where</span>列名=param1； </span><br><span class="line">Dbms_output。Put_line(‘打印信息<span class="string">&#x27;); </span></span><br><span class="line"><span class="string">Elsif (判断条件) then </span></span><br><span class="line"><span class="string">Dbms_output。Put_line(‘打印信息&#x27;</span>); </span><br><span class="line">Else </span><br><span class="line">Raise 异常名（NO_DATA_FOUND）; </span><br><span class="line"><span class="keyword">End</span> <span class="keyword">if</span>; </span><br><span class="line">Exception </span><br><span class="line">When others then </span><br><span class="line"><span class="keyword">Rollback</span>; </span><br><span class="line"><span class="keyword">End</span>; </span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong>：</p>
<ul>
<li><p>存储过程参数不带取值范围，in表示传入，out表示输出类型可以使用任意Oracle中的合法类型</p>
</li>
<li><p>变量带取值范围，后面接分号</p>
</li>
<li><p>在判断语句前最好先用count（*）函数判断是否存在该条操作记录</p>
</li>
<li><p>用select 。。。into。。。给变量赋值</p>
</li>
<li><p>在代码中抛异常用 raise+异常名</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">PROCEDURE</span>存储过程名 </span><br><span class="line">( </span><br><span class="line"><span class="comment">--定义参数 </span></span><br><span class="line">is_ym <span class="keyword">IN</span> <span class="built_in">CHAR</span>(<span class="number">6</span>) , </span><br><span class="line">the_count <span class="keyword">OUT</span> <span class="built_in">NUMBER</span>, </span><br><span class="line">) </span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="comment">--定义变量 </span></span><br><span class="line">vs_msg <span class="built_in">VARCHAR2</span>(<span class="number">4000</span>); <span class="comment">--错误信息变量 </span></span><br><span class="line">vs_ym_beg CHAR(6); <span class="comment">--起始月份 </span></span><br><span class="line">vs_ym_end CHAR(6); <span class="comment">--终止月份 </span></span><br><span class="line">vs_ym_sn_beg CHAR(6); <span class="comment">--同期起始月份 </span></span><br><span class="line">vs_ym_sn_end CHAR(6); <span class="comment">--同期终止月份 </span></span><br><span class="line"><span class="comment">--定义游标(简单的说就是一个可以遍历的结果集) </span></span><br><span class="line"></span><br><span class="line">CURSOR cur_1 IS </span><br><span class="line"><span class="keyword">SELECT</span> 。。。 </span><br><span class="line"><span class="keyword">FROM</span> 。。。 </span><br><span class="line"><span class="keyword">WHERE</span> 。。。 </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 。。。; </span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">--用输入参数给变量赋初值，用到了Oralce的SUBSTR TO_CHAR ADD_MONTHS </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">TO_DATE</span> 等很常用的函数。 </span><br><span class="line">vs_ym_beg := <span class="keyword">SUBSTR</span>(is_ym,<span class="number">1</span>,<span class="number">6</span>); </span><br><span class="line">vs_ym_end := SUBSTR(is_ym,7,6); </span><br><span class="line">vs_ym_sn_beg := TO_CHAR(ADD_MONTHS(TO_DATE(vs_ym_beg,&#x27;yyyymm&#x27;), -12),&#x27;yyyymm&#x27;); </span><br><span class="line">vs_ym_sn_end := TO_CHAR(ADD_MONTHS(TO_DATE(vs_ym_end,&#x27;yyyymm&#x27;), -12),&#x27;yyyymm&#x27;); </span><br><span class="line"></span><br><span class="line"><span class="comment">--先删除表中特定条件的数据。 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> ym = is_ym; </span><br><span class="line"></span><br><span class="line"><span class="comment">--然后用内置的DBMS_OUTPUT对象的put_line方法打印出影响的记录行数，其中用到一个系统变量SQL%rowcount </span></span><br><span class="line"></span><br><span class="line">DBMS_OUTPUT.put_line(&#x27;del上月记录=&#x27;||SQL%rowcount||&#x27;条&#x27;); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>表名(area_code,ym,CMCODE,rmb_amt,usd_amt) </span><br><span class="line"><span class="keyword">SELECT</span> area_code,is_ym,CMCODE,<span class="keyword">SUM</span>(rmb_amt)/<span class="number">10000</span>,<span class="keyword">SUM</span>(usd_amt)/<span class="number">10000</span> </span><br><span class="line"><span class="keyword">FROM</span> BGD_AREA_CM_M_BASE_T </span><br><span class="line"><span class="keyword">WHERE</span> ym &gt;= vs_ym_beg </span><br><span class="line"><span class="keyword">AND</span> ym &lt;= vs_ym_end </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> area_code,CMCODE; </span><br><span class="line">DBMS_OUTPUT.put_line(&#x27;ins当月记录=&#x27;||SQL%rowcount||&#x27;条&#x27;); </span><br><span class="line"><span class="comment">--遍历游标处理后更新到表。遍历游标有几种方法，用for语句是其中比较直观的一种。 </span></span><br><span class="line"></span><br><span class="line">FOR rec IN cur_1 LOOP </span><br><span class="line"><span class="keyword">UPDATE</span> 表名 </span><br><span class="line"><span class="keyword">SET</span> rmb_amt_sn = rec.rmb_amt_sn,usd_amt_sn = rec.usd_amt_sn </span><br><span class="line"><span class="keyword">WHERE</span> area_code = rec.area_code </span><br><span class="line"><span class="keyword">AND</span> CMCODE = rec.CMCODE </span><br><span class="line"><span class="keyword">AND</span> ym = is_ym; </span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span>; </span><br><span class="line"><span class="keyword">COMMIT</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">--错误处理部分。OTHERS表示除了声明外的任意错误。SQLERRM是系统内置变量保存了当前错误的详细信息。 </span></span><br><span class="line"></span><br><span class="line">EXCEPTION </span><br><span class="line"></span><br><span class="line">WHEN OTHERS THEN </span><br><span class="line">vs_msg := &#x27;ERROR IN xxxxxxxxxxx_p(&#x27;||is_ym||&#x27;):&#x27;||SUBSTR(SQLERRM,1,500); </span><br><span class="line"></span><br><span class="line"><span class="keyword">ROLLBACK</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">--把当前错误记录进日志表。 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> LOG_INFO(proc_name,error_info,op_date) </span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;xxxxxxxxxxx_p&#x27;</span>,vs_msg,<span class="keyword">SYSDATE</span>); </span><br><span class="line"><span class="keyword">COMMIT</span>; </span><br><span class="line">RETURN; </span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>; </span><br></pre></td></tr></table></figure>

<h5 id="存储过程语法"><a href="#存储过程语法" class="headerlink" title="存储过程语法"></a>存储过程语法</h5><h6 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h6><p>if 比较式 then begin end; end if;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">procedure</span> <span class="keyword">test</span>(x <span class="keyword">in</span> <span class="built_in">number</span>) <span class="keyword">is</span> </span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line"><span class="keyword">if</span> x &gt;<span class="number">0</span> <span class="keyword">then</span> </span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">x := <span class="number">0</span> - x; </span><br><span class="line"><span class="keyword">end</span>; </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>; </span><br><span class="line">if x = 0 then </span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">x: = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">end</span>; </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>; </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">test</span>; </span><br></pre></td></tr></table></figure>

<h6 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">procedure</span> <span class="keyword">test</span>() <span class="keyword">as</span> </span><br><span class="line"><span class="keyword">Cursor</span> <span class="keyword">cursor</span> <span class="keyword">is</span> <span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> student; name varchar(20); </span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line"><span class="keyword">for</span> <span class="keyword">name</span> <span class="keyword">in</span> <span class="keyword">cursor</span> <span class="keyword">LOOP</span> </span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">dbms_output.putline(<span class="keyword">name</span>); </span><br><span class="line"><span class="keyword">end</span>; </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">LOOP</span>; </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">test</span>; </span><br></pre></td></tr></table></figure>

<h6 id="循环遍历数组"><a href="#循环遍历数组" class="headerlink" title="循环遍历数组"></a>循环遍历数组</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">procedure</span> <span class="keyword">test</span>(varArray <span class="keyword">in</span> myPackage.TestArray) <span class="keyword">as</span> </span><br><span class="line"><span class="comment">--( 输入参数varArray 是自定义的数组类型，定义方式见标题6) </span></span><br><span class="line">i <span class="built_in">number</span>; </span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">i := <span class="number">1</span>; <span class="comment">-- 存储过程数组是起始位置是从1 开始的，与java 、C 、C++ 等语言不同。因为在Oracle 中本是没有数组的概念的，数组其实就是一张 </span></span><br><span class="line"><span class="comment">-- 表(Table), 每个数组元素就是表中的一个记录，所以遍历数组时就相当于从表中的第一条记录开始遍历 </span></span><br><span class="line">for i in 1..varArray.count LOOP </span><br><span class="line">dbms_output.putline(&#x27;The No.&#x27;|| i || &#x27;record in varArray is:&#x27;||varArray(i)); </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">LOOP</span>; </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">test</span>; </span><br></pre></td></tr></table></figure>

<h6 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span> </span><br><span class="line"><span class="keyword">end</span>; </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">LOOP</span>; </span><br><span class="line">E.g </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">procedure</span> <span class="keyword">test</span>(i <span class="keyword">in</span> <span class="built_in">number</span>) <span class="keyword">as</span> </span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">10</span> <span class="keyword">LOOP</span> </span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">i:= i + <span class="number">1</span>; </span><br><span class="line"><span class="keyword">end</span>; </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">LOOP</span>; </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">test</span>; </span><br></pre></td></tr></table></figure>

<h6 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h6><p>首先明确一个概念：Oracle 中本是没有数组的概念的，数组其实就是一张表(Table), 每个数组元素就是表中的一个记录。</p>
<p>使用数组时，用户可以使用Oracle 已经定义好的数组类型，或可根据自己的需要定义数组类型。</p>
<ol>
<li>使用Oracle 自带的数组类型</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x array; -- 使用时需要需要进行初始化</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">procedure</span> <span class="keyword">test</span>(y <span class="keyword">out</span> <span class="built_in">array</span>) <span class="keyword">is</span></span><br><span class="line">x <span class="built_in">array</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">x := <span class="keyword">new</span> <span class="built_in">array</span>();</span><br><span class="line">y := x;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>自定义的数组类型 ( 自定义数据类型时，建议通过创建Package 的方式实现，以便于管理)</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">package</span> myPackage <span class="keyword">is</span></span><br><span class="line"><span class="keyword">Public</span> <span class="keyword">type</span> declarations <span class="keyword">type</span> info <span class="keyword">is</span> <span class="built_in">record</span>( <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>), y <span class="built_in">number</span>);</span><br><span class="line">type TestArray is table of info index by binary_integer;</span><br><span class="line"><span class="comment">-- 此处声明了一个TestArray 的类型数据，其实其为一张存储Info 数据类型的Table 而已，及TestArray 就是一张表，有两个字段，一个是name ，一个是y 。需要注意的是此处使用了Index by binary_integer 编制该Table 的索引项，也可以不写，直接写成：type TestArray is</span></span><br><span class="line">table of info ，如果不写的话使用数组时就需要进行初始化：varArray myPackage.TestArray; varArray := new myPackage.TestArray();</span><br><span class="line"><span class="keyword">end</span> TestArray;</span><br></pre></td></tr></table></figure>

<h6 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h6><p>Oracle 中Cursor 是非常有用的，用于遍历临时表中的查询结果。其相关方法和属性也很多，现仅就常用的用法做一二介绍：</p>
<ol>
<li>Cursor 型游标( 不能用于参数传递)</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">procedure</span> <span class="keyword">test</span>() <span class="keyword">is</span></span><br><span class="line">cusor_1 <span class="keyword">Cursor</span> <span class="keyword">is</span> <span class="keyword">select</span> std_name <span class="keyword">from</span> student <span class="keyword">where</span> ...; <span class="comment">--Cursor 的使用方式1 cursor_2 Cursor;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">select</span> class_name <span class="keyword">into</span> cursor_2 <span class="keyword">from</span> <span class="keyword">class</span> <span class="keyword">where</span> ...; <span class="comment">--Cursor 的使用方式2</span></span><br><span class="line">可使用For x in cursor LOOP .... <span class="keyword">end</span> <span class="keyword">LOOP</span>; 来实现对Cursor 的遍历</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>SYS_REFCURSOR 型游标，该游标是Oracle 以预先定义的游标，可作出参数进行传递</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">procedure</span> <span class="keyword">test</span>(rsCursor <span class="keyword">out</span> SYS_REFCURSOR) <span class="keyword">is</span></span><br><span class="line"><span class="keyword">cursor</span> SYS_REFCURSOR;</span><br><span class="line">name varhcar(20);</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">OPEN</span> <span class="keyword">cursor</span> <span class="keyword">FOR</span> <span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> student <span class="keyword">where</span> ... <span class="comment">--SYS_REFCURSOR 只能通过OPEN 方法来打开和赋值</span></span><br><span class="line"><span class="keyword">LOOP</span></span><br><span class="line"><span class="keyword">fetch</span> <span class="keyword">cursor</span> <span class="keyword">into</span> <span class="keyword">name</span> <span class="comment">--SYS_REFCURSOR 只能通过fetch into 来打开和遍历 exit when cursor%NOTFOUND; --SYS_REFCURSOR 中可使用三个状态属性： ---%NOTFOUND( 未找到记录信息) %FOUND( 找到记录信息) ---%ROWCOUNT( 然后当前游标所指向的行位置)</span></span><br><span class="line">dbms_output.putline(<span class="keyword">name</span>);</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">LOOP</span>;</span><br><span class="line">rsCursor := cursor;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><p>假设存在两张表，一张是学生成绩表(studnet) ，字段：stdId, math, article, language, music, sport, total, average, step；一张是学生课外成绩表(out_school),，字段为：stdId, parctice, comment。通过存储过程自动计算出每位学生的总成绩和平均成绩，同时，如果学生在课外课程中获得的评价为A ，就在总成绩上加20 分。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">procedure</span> autocomputer(step <span class="keyword">in</span> <span class="built_in">number</span>) <span class="keyword">is</span> </span><br><span class="line">rsCursor SYS_REFCURSOR; </span><br><span class="line">commentArray myPackage.myArray; </span><br><span class="line">math number; </span><br><span class="line">article number; </span><br><span class="line">language number; </span><br><span class="line">music number; </span><br><span class="line">sport number; </span><br><span class="line">total number; </span><br><span class="line">average number; </span><br><span class="line">stdId varchar(30); </span><br><span class="line">record myPackage.stdInfo; </span><br><span class="line">i number; </span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">i := <span class="number">1</span>; </span><br><span class="line">get_comment(commentArray); <span class="comment">-- 调用名为get_comment() 的存储过程获取学生课外评分信息 </span></span><br><span class="line">OPEN rsCursor for <span class="keyword">select</span> stdId,math,article,<span class="keyword">language</span>,music,sport <span class="keyword">from</span> student t <span class="keyword">where</span> t.step = step; </span><br><span class="line">LOOP </span><br><span class="line">fetch rsCursor into stdId,math,article,language,music,sport; exit when rsCursor%NOTFOUND; </span><br><span class="line">total := math + article + language + music + sport; </span><br><span class="line">for i in 1..commentArray.count LOOP </span><br><span class="line">record := commentArray(i); </span><br><span class="line">if stdId = record.stdId then </span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line"><span class="keyword">if</span> record.comment = <span class="string">&#x27;A&#x27;</span> <span class="keyword">then</span> </span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">total := total + <span class="number">20</span>; </span><br><span class="line">go to next; <span class="comment">-- 使用go to 跳出for 循环 </span></span><br><span class="line"><span class="keyword">end</span>; </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>; </span><br><span class="line"><span class="keyword">end</span>; </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>; </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">LOOP</span>; </span><br><span class="line">&lt;&lt;continue&gt;&gt; average := total / 5; </span><br><span class="line"><span class="keyword">update</span> student t <span class="keyword">set</span> t.total=total <span class="keyword">and</span> t.average = average <span class="keyword">where</span> t.stdId = stdId; </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">LOOP</span>; </span><br><span class="line"><span class="keyword">end</span>; </span><br><span class="line"><span class="keyword">end</span> autocomputer; </span><br><span class="line"><span class="comment">-- 取得学生评论信息的存储过程 </span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">procedure</span> get_comment(commentArray <span class="keyword">out</span> myPackage.myArray) <span class="keyword">is</span> </span><br><span class="line">rs SYS_REFCURSOR ； </span><br><span class="line"><span class="built_in">record</span> myPackage.stdInfo; </span><br><span class="line">stdId varchar(30); </span><br><span class="line"><span class="keyword">comment</span> <span class="built_in">varchar</span>(<span class="number">1</span>); </span><br><span class="line">i number; </span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line"><span class="keyword">open</span> rs <span class="keyword">for</span> <span class="keyword">select</span> stdId,<span class="keyword">comment</span> <span class="keyword">from</span> out_school </span><br><span class="line">i := <span class="number">1</span>; </span><br><span class="line">LOOP </span><br><span class="line">fetch rs into stdId,<span class="keyword">comment</span>; exit when rs%NOTFOUND; </span><br><span class="line">record.stdId := stdId; </span><br><span class="line">record.comment := comment; </span><br><span class="line">recommentArray(i) := record; </span><br><span class="line">i:=i + 1; </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">LOOP</span>; </span><br><span class="line"><span class="keyword">end</span> get_comment; </span><br><span class="line"><span class="comment">-- 定义数组类型myArray </span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">package</span> myPackage <span class="keyword">is</span> <span class="keyword">begin</span> </span><br><span class="line"><span class="keyword">type</span> stdInfo <span class="keyword">is</span> <span class="built_in">record</span>(stdId <span class="built_in">varchar</span>(<span class="number">30</span>),<span class="keyword">comment</span> <span class="built_in">varchar</span>(<span class="number">1</span>)); </span><br><span class="line">type myArray is table of stdInfo index by binary_integer; </span><br><span class="line"><span class="keyword">end</span> myPackage; </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle表的删除和授权</title>
    <url>/2020/08/22/15/17/oracle%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4%E5%92%8C%E6%8E%88%E6%9D%83/</url>
    <content><![CDATA[<p>表的快速删除和授权操作<a id="more"></a></p>
<h5 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h5><p>TRUNCATE TABLE 一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</p>
<p>DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。</p>
<p>如果只想清空含有大量数据的表时，直接使用TRUNCATE。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小。</p>
<p><strong>执行速度DROP &gt;  TRUNCATE &gt; DELETE。</strong></p>
<p><strong>TRUNCATE 的使用范围只能对TABLE； DELETE可以是table和view。</strong></p>
<p> Truncate table 表名 速度快，而且效率高，因为truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同，二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。</p>
<p>对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。</p>
<h5 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h5><ul>
<li><p>select * from dba_users; –查询数据库中的所有用户</p>
</li>
<li><p>GRANT SELECT ON tableName to userName;–授权查询（将表tableName的查询权授给userName）<br>   GRANT INSERT ON tableName to userName;–授权插入（将表tableName的插入权授给userName）<br>   GRANT UPDATE ON tableName to userName;–授权更新（将表tableName的更新权授给userName）<br>  GRANT UPDATE ON table1 to userName with grant option; –授权更新权限转移给用户，该用户可以继续授权；<br>GRANT EXECUTE ON procedure1 to userName;–授权存储过程</p>
</li>
<li><p>revoke select on table1 from user1; –收回查询表的权限；<br>  revoke all on table1 from user1;–收回表table1的所有权限；</p>
</li>
<li><p>select table_name,privilege from dba_tab_privs where grantee=’xujin’ ;–查询一个用户拥有的对象权限<br>  select * from dba_sys_privs where grantee=’xujin’ ;–查询一个用户拥有的系统权限<br>  select * from session_privs ;–a当前会话有效的系统权限</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>sql函数</title>
    <url>/2020/08/02/10/34/sql%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>工作中所遇到的SQL函数。<a id="more"></a></p>
<p>top关键字属性SQL Server，平常并没有使用SQL Server。</p>
<h6 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h6><ul>
<li><p>upper(str)/ucase(str)：返回字符串str，将所有字符改为大写</p>
</li>
<li><p>lower(str)/lcase(str)：返回字符串str，将所有字符改为小写</p>
</li>
<li><p>first(column_name)：返回指定的字段中第一个记录的值，可使用 ORDER BY 语句对记录进行排序</p>
</li>
<li><p>last(column_name)：返回指定的字段中最后一个记录的值，可使用 ORDER BY 语句对记录进行排序</p>
</li>
<li><p>mid(str,start,length)：用于从文本字段中提取字符，str要提取的字段(必须)，start开始位置(必须)，length提取长度，若为空，则返回剩余字符串</p>
</li>
<li><p>now()：返回当前日期</p>
</li>
<li><p>format(column_name,format)：</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ProductName, UnitPrice, <span class="keyword">FORMAT</span>(<span class="keyword">Now</span>(),<span class="string">&#x27;YYYY-MM-DD&#x27;</span>) <span class="keyword">as</span> PerDate</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br></pre></td></tr></table></figure>

<ul>
<li><p>replace(X,old,new) n：在X中查找old，并替换成new</p>
</li>
<li><p>instr(X,STR[,START][,N)：从X中查找str，可以指定从start开始，也可以指定从n开始</p>
</li>
<li><p>ltrim(X[,TRIM_STR])：把X的左边截去trim_str字符串，缺省截去空格</p>
</li>
<li><p>rtrim(X[,TRIM_STR])：把X的右边截去trim_str字符串，缺省截去空格</p>
</li>
<li><p>trim([TRIM_STR FROM]X)：把X的两边截去trim_str字符串，缺省截去空格</p>
</li>
<li><p>trunc(x[,y])：直接截取，不四舍五入。</p>
<p>在缺省 y 时，默认 y=0；比如：TRUNC (3.56)=3。</p>
<p>Y是正整数，就是四舍五入到小数点后 y 位。TRUNC (5.654,2)=5.65。</p>
<p>y 是负整数，四舍五入到小数点左边|y|位。TRUNC (351.654,-2)=300。</p>
</li>
<li><p>add_months(d,n)，在某一个日期 d 上，加上指定的月数 n，返回计算后的新日期。d 表示日期，n 表示要加的月数</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SYSDATE</span>,add_months(<span class="keyword">SYSDATE</span>,<span class="number">5</span>) <span class="keyword">FROM</span> dual;</span><br></pre></td></tr></table></figure>

<ul>
<li>last_day(d)，返回指定日期当月的最后一天</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SYSDATE</span>,<span class="keyword">last_day</span>(<span class="keyword">SYSDATE</span>) <span class="keyword">FROM</span> dual;</span><br></pre></td></tr></table></figure>

<ul>
<li>nvl(X,VALUE)：如果X为空，返回value，否则返回X</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ENAME,JOB,SAL,NVL(COMM,<span class="number">100</span>) <span class="keyword">FROM</span> EMP <span class="keyword">WHERE</span> SAL&lt;<span class="number">2000</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>to_number()：将字符型数据转换成数字型    </p>
</li>
<li><p>to_date()：将字符型数据转换成日期型</p>
</li>
<li><p>ceil()：向上取整，结果为124。<code>select ceil(123.123) from dual;</code></p>
</li>
<li><p>floor()：向下取整，结果为123。<code>select floor(123.123) from dual;</code></p>
</li>
<li><p>trunc(n1,n2)取整函数,n1代表字符串，n2代表小数位数，结果为123.12。<br>  <code>select trunc(123.125,2) from dual;</code></p>
</li>
<li><p>round(n1,n2)四舍五入，n1代表字符串,n2代表小数位数，结果为123.57。<code>select round(123.567) from dual;</code></p>
</li>
</ul>
<h6 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h6><ul>
<li>except(sql server)：通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	reg_num </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	dq_list <span class="keyword">except</span></span><br><span class="line"><span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	reg_num </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	dq_result</span><br></pre></td></tr></table></figure>

<ul>
<li>minus(oracle)：先找出第一个 SQL 语句所产生的结果，然后看这些结果有没有在第二个 SQL 语句的结果中。如果有的话，那这一笔资料就被去除，而不会在最后的结果中出现。如果第二个 SQL 语句所产生的结果并没有存在于第一个 SQL 语句所产生的结果内，那这笔资料就被抛弃。</li>
</ul>
<p><strong><em>Store_Information</em></strong> 表格</p>
<table>
<thead>
<tr>
<th>Store_Name</th>
<th>Sales</th>
<th>Txn_Date</th>
</tr>
</thead>
<tbody><tr>
<td>Los Angeles</td>
<td>1500</td>
<td>05-Jan-1999</td>
</tr>
<tr>
<td>San Diego</td>
<td>250</td>
<td>07-Jan-1999</td>
</tr>
<tr>
<td>Los Angeles</td>
<td>300</td>
<td>08-Jan-1999</td>
</tr>
<tr>
<td>Boston</td>
<td>700</td>
<td>08-Jan-1999</td>
</tr>
</tbody></table>
<p><strong><em>Internet Sales</em></strong> 表格</p>
<table>
<thead>
<tr>
<th>Txn_Date</th>
<th>Sales</th>
</tr>
</thead>
<tbody><tr>
<td>07-Jan-1999</td>
<td>250</td>
</tr>
<tr>
<td>10-Jan-1999</td>
<td>535</td>
</tr>
<tr>
<td>11-Jan-1999</td>
<td>320</td>
</tr>
<tr>
<td>12-Jan-1999</td>
<td>750</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Txn_Date <span class="keyword">FROM</span> Store_Information</span><br><span class="line"><span class="keyword">MINUS</span></span><br><span class="line"><span class="keyword">SELECT</span> Txn_Date <span class="keyword">FROM</span> Internet_Sales;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Txn_Date</th>
</tr>
</thead>
<tbody><tr>
<td>Jan-05-1999</td>
</tr>
<tr>
<td>Jan-08-1999</td>
</tr>
</tbody></table>
<ul>
<li><p>intersect：通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。</p>
</li>
<li><p>zeroifnull(expr)：如果表达式expr的值为0，则返回null，否则返回表达式expr的值。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> zeroifnull(<span class="keyword">count</span>(<span class="keyword">DISTINCT</span> userid)) <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure>

<ul>
<li>nullifzero(expr)：如果表达式expr的值为null，则返回0，否则返回表达式expr的值。</li>
</ul>
<h6 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h6><p>复制表(只复制结构,源表名：a 新表名：b) (Access可用)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">into</span> b <span class="keyword">from</span> a <span class="keyword">where</span> <span class="number">1</span>&lt;&gt;<span class="number">1</span>（仅用于SQlServer）</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> top <span class="number">0</span> * <span class="keyword">into</span> b <span class="keyword">from</span> a</span><br></pre></td></tr></table></figure>

<p>显示文章、提交人和最后回复时间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.title,a.username,b.adddate <span class="keyword">from</span> <span class="keyword">table</span> a,(<span class="keyword">select</span> <span class="keyword">max</span>(adddate) adddate <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> table.title=a.title) b</span><br></pre></td></tr></table></figure>

<p>两张关联表，删除主表中已经在副表中没有的信息 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table1 <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> ( <span class="keyword">select</span> * <span class="keyword">from</span> table2 <span class="keyword">where</span> table1.field1=table2.field1 )</span><br></pre></td></tr></table></figure>

<p>日程安排提前五分钟提醒</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> 日程安排 <span class="keyword">where</span> <span class="keyword">datediff</span>(<span class="string">&#x27;minute&#x27;</span>,f开始时间,<span class="keyword">getdate</span>())&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>一条sql语句搞定数据库分页</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> top <span class="number">10</span> b.* <span class="keyword">from</span> (<span class="keyword">select</span> top <span class="number">20</span> 主键字段,排序字段 <span class="keyword">from</span> 表名 <span class="keyword">order</span> <span class="keyword">by</span> 排序字段 <span class="keyword">desc</span>) a,表名 b <span class="keyword">where</span> b.主键字段 = a.主键字段 <span class="keyword">order</span> <span class="keyword">by</span> a.排序字段</span><br></pre></td></tr></table></figure>

<p>前10条记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> top <span class="number">10</span> * <span class="keyword">from</span> table1 <span class="keyword">where</span> 范围</span><br></pre></td></tr></table></figure>

<p>选择在每一组b值相同的数据中对应的a最大的记录的所有信息(类似这样的用法可以用于论坛每月排行榜,每月热销产品分析,按科目成绩排名,等等.)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a,b,c <span class="keyword">from</span> tablename ta <span class="keyword">where</span> a=(<span class="keyword">select</span> <span class="keyword">max</span>(a) <span class="keyword">from</span> tablename tb <span class="keyword">where</span> tb.b=ta.b)</span><br></pre></td></tr></table></figure>

<p>包括所有在TableA中但不在TableB和TableC中的行并消除所有重复行而派生出一个结果表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">select</span> a <span class="keyword">from</span> tableA ) <span class="keyword">except</span> (<span class="keyword">select</span> a <span class="keyword">from</span> tableB) <span class="keyword">except</span> (<span class="keyword">select</span> a <span class="keyword">from</span> tableC)</span><br></pre></td></tr></table></figure>

<p>随机取出10条数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> top <span class="number">10</span> * <span class="keyword">from</span> tablename <span class="keyword">order</span> <span class="keyword">by</span> newid()</span><br></pre></td></tr></table></figure>

<p>随机选择记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> newid()</span><br></pre></td></tr></table></figure>

<p>列出数据库里所有的表名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> sysobjects <span class="keyword">where</span> <span class="keyword">type</span>=<span class="string">&#x27;U&#x27;</span> // U代表用户</span><br></pre></td></tr></table></figure>

<p>列出表里的所有的列名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> syscolumns <span class="keyword">where</span> <span class="keyword">id</span>=object_id(<span class="string">&#x27;TableName&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>选择从10到15的记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> top <span class="number">5</span> * <span class="keyword">from</span> (<span class="keyword">select</span> top <span class="number">15</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">asc</span>) table_别名 <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>常见浏览器的用户代理</title>
    <url>/2020/01/13/17/35/%E5%B8%B8%E8%A7%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%94%A8%E6%88%B7%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>常用浏览器用户代理总结。<a id="more"></a></p>
<p>&emsp;&emsp;所谓 用户代理（User Agent ），最初是指浏览器告知网站管理员，本浏览器支持的类型和框架，让网站管理员以支持的模式结构向浏览器发送页面，呈现给用户浏览。演变到今天，网站管理员为了给用户带呈现最佳的页面效果，为了使不同浏览器展现同样的网站页面，通过浏览器获取用户的系统信息，包括硬件平台、系统软件、应用软件和用户个人偏好，然后通过服务器解析后以适合用户的页面类型发送到浏览器。</p>
<p>&emsp;&emsp;目前 UA 分析监测可补全的系统：Windows 7、Windows 10、Mac OS X Lion、Ubuntu 14.04；浏览器：所有品牌和系列。</p>
<h5 id="Windows10-64位"><a href="#Windows10-64位" class="headerlink" title="Windows10 64位"></a>Windows10 64位</h5><p>微软Chrome内核 Edge 浏览器</p>
<p>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36 Edg/80.0.361.69</p>
<p>360极速浏览器</p>
<p>Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36 QIHU 360EE</p>
<h5 id="Windows-7-64位"><a href="#Windows-7-64位" class="headerlink" title="Windows 7 64位"></a>Windows 7 64位</h5><p>[^]: Internet Explorer 10 浏览器和 Internet Explorer 11 浏览器以及微软 Edge 浏览器为 Windows 10 64 位。</p>
<p>Chrome｜谷歌浏览器<br>Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.87 Safari/537.36</p>
<p>Firefox｜火狐浏览器<br>Mozilla/5.0 (Windows NT 6.1; WOW64; rv:46.0) Gecko/20100101 Firefox/46.0</p>
<p>Opera｜欧朋浏览器<br>Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.87 Safari/537.36 OPR/37.0.2178.32</p>
<p>Safari｜苹果浏览器<br>Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2</p>
<p>360极速浏览器<br>Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36</p>
<p>360安全浏览器<br>Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36</p>
<p>微软 Edge 浏览器<br>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Safari/537.36 Edge/13.10586</p>
<p>Internet Explorer 11 浏览器<br>Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko</p>
<p>Internet Explorer 10 浏览器<br>Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident/6.0)</p>
<p>Internet Explorer 9 浏览器<br>Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)</p>
<p>Internet Explorer 8 浏览器<br>Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0)</p>
<p>百度浏览器<br>Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 BIDUBrowser/8.3 Safari/537.36</p>
<p>遨游浏览器<br>Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Maxthon/4.9.2.1000 Chrome/39.0.2146.0 Safari/537.36</p>
<p>QQ浏览器<br>Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.80 Safari/537.36 Core/1.47.277.400 QQBrowser/9.4.7658.400</p>
<p>UC浏览器电脑版<br>Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 UBrowser/5.6.12150.8 Safari/537.36</p>
<p>搜狗浏览器<br>Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 Safari/537.36 SE 2.X MetaSr 1.0</p>
<p>猎豹浏览器<br>Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.154 Safari/537.36 LBBROWSER </p>
<p>世界之窗浏览器<br>Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36 TheWorld 7</p>
<p>安卓版QQ浏览器<br>Mozilla/5.0 (Linux; Android 5.0; SM-N9100 Build/LRX21V) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/37.0.0.0 Mobile Safari/537.36 V1_AND_SQ_5.3.1_196_YYB_D QQ/5.3.1.2335 NetType/WIFI</p>
<p>安卓版微信浏览器<br>Mozilla/5.0 (Linux; Android 5.0; SM-N9100 Build/LRX21V) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/37.0.0.0 Mobile Safari/537.36 MicroMessenger/6.0.2.56_r958800.520 NetType/WIFI</p>
<p>IOS版QQ浏览器<br>Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Mobile/11D257 QQ/5.2.1.302 NetType/WIFI Mem/28</p>
<p>IOS版微信浏览器<br>Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Mobile/11D257 MicroMessenger/6.0.1 NetType/WIFI</p>
]]></content>
      <categories>
        <category>代理</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2020/02/08/15/56/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<p>建立迷宫时有所涉及，用来处理格子之间的相连问题。<a id="more"></a></p>
<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>&emsp;&emsp;并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。这一类问题近几年来反复出现在信息学的国际国内赛题中，其特点是看似并不复杂，但数据量极大，若用正常的数据结构来描述的话，往往在空间上过大，计算机无法承受；即使在空间上勉强通过，运行的时间复杂度也极高，根本就不可能在比赛规定的运行时间（1～3秒）内计算出试题需要的结果，只能用并查集来描述。</p>
<p>&emsp;&emsp;并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。常常在使用中以森林来表示。</p>
<h5 id="主要操作"><a href="#主要操作" class="headerlink" title="主要操作"></a>主要操作</h5><ul>
<li>初始化<br>每个元素都将自己作为一个集合，时间复杂度为O(n)。</li>
<li>查找<br>查找元素所在的集合，即根节点。</li>
<li>合并<br>将两个元素所在的集合合并为一个集合。通常，首先判断两个元素是否在同一个集合，通过上步的查找来判断。</li>
</ul>
<h5 id="举例分析"><a href="#举例分析" class="headerlink" title="举例分析"></a>举例分析</h5><h6 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h6><p>&emsp;&emsp;若某个家族人员过于庞大，要判断两个是否是亲戚，确实不容易，给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。</p>
<p>规定：x和y是亲戚，y和z是亲戚，那么x和z也是亲戚。如果x,y是亲戚，那么x的亲戚都是y的亲戚，y的亲戚也都是x的亲戚。</p>
<h6 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h6><p>&emsp;&emsp;第一行：三个整数n,m,p，（n&lt;=5000,m&lt;=5000,p&lt;=5000）</p>
<p>&emsp;&emsp;分别表示有n个人，m个亲戚关系，询问p对新奇关系。</p>
<p>&emsp;&emsp;以下m行：每行两个数Mi，Mj，1&lt;=Mi，Mj&lt;=n，表示Mi和Mj具有亲戚关系。</p>
<p>&emsp;&emsp;接下来p行：每行两个数Pi，Pj，询问Pi和Pj是否具有亲戚关系。</p>
<h6 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h6><p>&emsp;&emsp;共p行，每行一个“Yes”或“No”，表示第Pi个询问的答案为“有”或“没有”亲戚关系。</p>
<h6 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h6><p>&emsp;&emsp;本题是一个图论中判断两个点是否在同一连通子图的问题。对于题目中的样例，将人作为点，亲戚关系作为边，建立无向图如下：</p>
<p><img src="/2020/02/08/15/56/%E5%B9%B6%E6%9F%A5%E9%9B%86/1.jpg" alt></p>
<p>&emsp;&emsp;比如判断3和4是否为亲戚时，我们检查3和4是否在同一个连通子图中，结果是在，于是他们是亲戚。又如7和10不在同一个连通子图中，所以他们不是亲戚。</p>
<p>&emsp;&emsp; 例如样例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span> <span class="number">7</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">8</span> <span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们可以给每个人建立一个集合，集合的元素值有它自己，表示最开始时它不知道任何人是它的亲戚。以后每次给出一个亲戚关系a, b，则a和它的亲戚与b和它的亲戚就互为亲戚了，将a所在集合与b所在集合合并。对于样例数据的操作全过程如下：</p>
<p>&emsp;&emsp;初始状态：{1} {2} {3} {4} {5} {6} {7} {8} {9}</p>
<p>&emsp;&emsp;输入关系 分离集合</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">(<span class="number">2</span>,<span class="number">4</span>) &#123;<span class="number">2</span>,<span class="number">4</span>&#125;&#123;<span class="number">1</span>&#125; &#123;<span class="number">3</span>&#125; &#123;<span class="number">5</span>&#125; &#123;<span class="number">6</span>&#125; &#123;<span class="number">7</span>&#125; &#123;<span class="number">8</span>&#125; &#123;<span class="number">9</span>&#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">5</span>,<span class="number">7</span>) &#123;<span class="number">2</span>,<span class="number">4</span>&#125; &#123;<span class="number">5</span>,<span class="number">7</span>&#125; &#123;<span class="number">1</span>&#125; &#123;<span class="number">3</span>&#125; &#123;<span class="number">6</span>&#125; &#123;<span class="number">8</span>&#125; &#123;<span class="number">9</span>&#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>,<span class="number">3</span>) &#123;<span class="number">1</span>,<span class="number">3</span>&#125; &#123;<span class="number">2</span>,<span class="number">4</span>&#125; &#123;<span class="number">5</span>,<span class="number">7</span>&#125;&#123;<span class="number">6</span>&#125; &#123;<span class="number">8</span>&#125; &#123;<span class="number">9</span>&#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">8</span>,<span class="number">9</span>) &#123;<span class="number">1</span>,<span class="number">3</span>&#125; &#123;<span class="number">2</span>,<span class="number">4</span>&#125; &#123;<span class="number">5</span>,<span class="number">7</span>&#125; &#123;<span class="number">8</span>,<span class="number">9</span>&#125;&#123;<span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>) &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125; &#123;<span class="number">5</span>,<span class="number">7</span>&#125; &#123;<span class="number">8</span>,<span class="number">9</span>&#125;&#123;<span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">5</span>,<span class="number">6</span>) &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125; &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125; &#123;<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>,<span class="number">3</span>) &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125; &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125; &#123;<span class="number">8</span>,<span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure>

<p>判断亲戚关系</p>
<p>(1,9)，因为1,9不在同一集合内，所以输出”NO”。</p>
<p>&emsp;&emsp;最后我们得到3个集合{1,2,3,4}、{5,6,7}、{8,9}，于是判断两个人是否亲戚的问题就变成判断两个数是否在同一个集合中的问题。</p>
<p>&emsp;&emsp;算法需要以下几个子过程：</p>
<ol>
<li>开始时，为每个人建立一个集合；</li>
<li>得到一个关系，合并相应的集合；</li>
<li>在合并集合时先要判断是否两个人在同一集合。合并完之后还要判断是否为亲戚；</li>
</ol>
<h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.StreamTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> father[];</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//获取输入流</span></span><br><span class="line">		StreamTokenizer st = <span class="keyword">new</span> StreamTokenizer(<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)));</span><br><span class="line">		<span class="keyword">while</span>(st.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">			<span class="comment">//n为亲戚总数</span></span><br><span class="line">			<span class="keyword">int</span> n = (<span class="keyword">int</span>)st.nval;</span><br><span class="line">			father = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">				father[i] = i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//m个亲戚关系</span></span><br><span class="line">			st.nextToken();</span><br><span class="line">			<span class="keyword">int</span> m = (<span class="keyword">int</span>)st.nval;</span><br><span class="line">			<span class="comment">//询问p对亲戚关系</span></span><br><span class="line">			st.nextToken();</span><br><span class="line">			<span class="keyword">int</span> p = (<span class="keyword">int</span>)st.nval;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">				st.nextToken();</span><br><span class="line">				<span class="keyword">int</span> a = (<span class="keyword">int</span>)st.nval;</span><br><span class="line">				st.nextToken();</span><br><span class="line">				<span class="keyword">int</span> b = (<span class="keyword">int</span>)st.nval;</span><br><span class="line">				union(a,b);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p; i++) &#123;</span><br><span class="line">				st.nextToken();</span><br><span class="line">				<span class="keyword">int</span> a = (<span class="keyword">int</span>)st.nval;</span><br><span class="line">				st.nextToken();</span><br><span class="line">				<span class="keyword">int</span> b = (<span class="keyword">int</span>)st.nval;</span><br><span class="line">				a = findParent(a);</span><br><span class="line">				b = findParent(b);</span><br><span class="line">				System.out.println(a == b ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//亲戚关系连接</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> f, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a = findParent(f);</span><br><span class="line">		<span class="keyword">int</span> b = findParent(t);</span><br><span class="line">        <span class="keyword">if</span>(a==b)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">            father[a] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            father[b] = a;</span><br><span class="line">        &#125; </span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//判断是否具有亲戚关系</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findParent</span><span class="params">(<span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(father[f] != f)&#123;</span><br><span class="line">            f = father[f];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>时间与时间戳相互转换</title>
    <url>/2020/01/14/09/43/%E6%97%B6%E9%97%B4%E4%B8%8E%E6%97%B6%E9%97%B4%E6%88%B3%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>java时间与时间戳相互转换<a id="more"></a></p>
<h6 id="时间转换成时间戳"><a href="#时间转换成时间戳" class="headerlink" title="时间转换成时间戳"></a>时间转换成时间戳</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dateToStamp</span><span class="params">(String s)</span> <span class="keyword">throws</span> ParaseException</span>&#123;</span><br><span class="line">    String res;</span><br><span class="line">    SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    Date date = simpleDateFormat.parse(s);</span><br><span class="line">    <span class="keyword">long</span> ts = date.getTime();</span><br><span class="line">    res = String.valueOf(ts);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="时间戳转换成时间"><a href="#时间戳转换成时间" class="headerlink" title="时间戳转换成时间"></a>时间戳转换成时间</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dateToStamp</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    String res;</span><br><span class="line">    SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="keyword">long</span> lt = <span class="keyword">new</span> Long(s);</span><br><span class="line">    Date date = <span class="keyword">new</span> Date(lt);</span><br><span class="line">    res = simpleDateFormat.format(date);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>格式化</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>时间格式化DateTimeFormatter</title>
    <url>/2020/02/14/16/43/%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96DateTimeFormatter/</url>
    <content><![CDATA[<p>DateTimeFormatter类提供了三种时间格式化方法。<a id="more"></a></p>
<h6 id="默认格式"><a href="#默认格式" class="headerlink" title="默认格式"></a>默认格式</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.新建一个DateTimeFormatter对象</span></span><br><span class="line">        DateTimeFormatter isoDate = DateTimeFormatter.ISO_DATE;</span><br><span class="line">        </span><br><span class="line">        LocalDateTime ldt1 = LocalDateTime.now();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.调用该对象的format方法，参数是需要格式化的LocalDateTime对象。</span></span><br><span class="line">        String format = isoDate.format(ldt1);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;时间是：&quot;</span> + format);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="自定义格式"><a href="#自定义格式" class="headerlink" title="自定义格式"></a>自定义格式</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.新建一个DateTimeFormatter对象，调用ofPattern方法。</span></span><br><span class="line">        DateTimeFormatter pattern = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;</span>, Locale.CHINA);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.调用该对象的format方法，参数是需要格式化的LocalDateTime对象。</span></span><br><span class="line">        String format = pattern.format(LocalDateTime.now());</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;时间是：&quot;</span> + format);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="自定义格式时间解析"><a href="#自定义格式时间解析" class="headerlink" title="自定义格式时间解析"></a>自定义格式时间解析</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.新建一个时间的字符串对象。</span></span><br><span class="line">        String dateTime = <span class="string">&quot;2020年02月12日 22点22分22秒&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.新建一个DateTimeFormatter对象，调用ofPattern方法。</span></span><br><span class="line">        DateTimeFormatter pattern = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH点mm分ss秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.调用DateTimeFormatter对象的parse方法，进行解析，返回一个TemporalAccessor对象。</span></span><br><span class="line">        TemporalAccessor parse = pattern.parse(dateTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.调用LocalDateTime的静态方法form，将TemporalAccessor转换成LocalDateTime对象。</span></span><br><span class="line">        LocalDateTime ldt1 = LocalDateTime.from(parse);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;LocalDateTime：&quot;</span> + ldt1);</span><br><span class="line">        System.out.println(<span class="string">&quot;LocalDateTime：&quot;</span> + LocalDateTime.now());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h6><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">时间是：<span class="number">2020</span><span class="number">-02</span><span class="number">-14</span></span><br><span class="line">时间是：<span class="number">2020</span>年<span class="number">02</span>月<span class="number">14</span>日 <span class="number">16</span>时<span class="number">30</span>分<span class="number">55</span>秒</span><br><span class="line">LocalDateTime：<span class="number">2020</span><span class="number">-02</span><span class="number">-12</span>T22:<span class="number">22</span>:<span class="number">22</span></span><br><span class="line">LocalDateTime：<span class="number">2020</span><span class="number">-02</span><span class="number">-14</span>T16:<span class="number">30</span>:<span class="number">55.544</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>格式化</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>比较java中Array类的两个方法：equals和deepEquals</title>
    <url>/2020/01/14/17/40/%E6%AF%94%E8%BE%83java%E4%B8%ADArray%E7%B1%BB%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%9Aequals%E5%92%8CdeepEquals/</url>
    <content><![CDATA[<p>举例分析equals和deepEquals的区别。<a id="more"></a></p>
<h5 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String[][] name1 = &#123;&#123; <span class="string">&quot;G&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;o&quot;</span>&#125;,&#123;<span class="string">&quot;H&quot;</span>,<span class="string">&quot;u&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;n&quot;</span>&#125;,&#123;<span class="string">&quot;j&quot;</span>,<span class="string">&quot;i&quot;</span>,<span class="string">&quot;e&quot;</span>&#125;&#125;;</span><br><span class="line">        String[][] name2 =  &#123;&#123; <span class="string">&quot;G&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;o&quot;</span>&#125;,&#123;<span class="string">&quot;H&quot;</span>,<span class="string">&quot;u&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;n&quot;</span>&#125;,&#123;<span class="string">&quot;j&quot;</span>,<span class="string">&quot;i&quot;</span>,<span class="string">&quot;e&quot;</span>&#125;&#125;;</span><br><span class="line">      System.out.println(Arrays.equals(name1,name2));<span class="comment">//false  </span></span><br><span class="line">      System.out.println(Arrays.deepEquals(name1,name2));<span class="comment">//true  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String[] name1 = &#123;&#123; <span class="string">&quot;G&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;o&quot;</span>&#125;,&#123;<span class="string">&quot;H&quot;</span>,<span class="string">&quot;u&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;n&quot;</span>&#125;,&#123;<span class="string">&quot;j&quot;</span>,<span class="string">&quot;i&quot;</span>,<span class="string">&quot;e&quot;</span>&#125;&#125;;</span><br><span class="line">        String[] name2 =  &#123;&#123; <span class="string">&quot;G&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;o&quot;</span>&#125;,&#123;<span class="string">&quot;H&quot;</span>,<span class="string">&quot;u&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;n&quot;</span>&#125;,&#123;<span class="string">&quot;j&quot;</span>,<span class="string">&quot;i&quot;</span>,<span class="string">&quot;e&quot;</span>&#125;&#125;;</span><br><span class="line">      System.out.println(Arrays.equals(name1,name2));<span class="comment">//false  </span></span><br><span class="line">      System.out.println(Arrays.deepEquals(name1,name2));<span class="comment">//true  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol>
<li>deepEquals用于判定两个指定数组彼此是否深层相等，此方法适用于任意深度的嵌套数组。</li>
<li>equals用于判定两个数组是否相等，如果两个数组以相同顺序包含相同元素，则返回true，否则返回false。</li>
<li>通过比对“例一”和“例二”我们可以得出这样一个结论：如果两个数组使用equals返回true，则使用deepEquals也返回true，也就是说在比较的两个数组均为一维数组的前提下，equals和deepEquals的比较结果没有差别。</li>
</ol>
<p>​    4、如果要比较多为数组，则需要使用deepEquals方法。</p>
]]></content>
      <categories>
        <category>java方法</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>研究生考试数学公式大全</title>
    <url>/2019/12/22/23/09/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<p>数学公式大全<a id="more"></a></p>
<p><img src="/2019/12/22/23/09/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/102.jpg" alt></p>
<p><img src="/2019/12/22/23/09/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/111.jpg" alt></p>
<p><img src="/2019/12/22/23/09/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/115.jpg" alt></p>
<p><img src="/2019/12/22/23/09/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/118.jpg" alt></p>
<p><img src="/2019/12/22/23/09/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/122.jpg" alt></p>
<p><img src="/2019/12/22/23/09/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/125.jpg" alt></p>
<p><img src="/2019/12/22/23/09/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/128.jpg" alt></p>
<p><img src="/2019/12/22/23/09/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/131.jpg" alt></p>
<p><img src="/2019/12/22/23/09/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/135.jpg" alt></p>
<p><img src="/2019/12/22/23/09/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/138.jpg" alt></p>
<p><img src="/2019/12/22/23/09/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/142.jpg" alt></p>
<p><img src="/2019/12/22/23/09/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%A4%A7%E5%85%A8/145.jpg" alt></p>
]]></content>
      <categories>
        <category>考试</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面经一</title>
    <url>/2020/04/30/21/44/Java%E9%9D%A2%E7%BB%8F%E4%B8%80/</url>
    <content><![CDATA[<p>Java面试总结 一<a id="more"></a></p>
<h6 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h6><table>
<thead>
<tr>
<th align="center">字符</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\</td>
<td align="left">将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，”n”匹配字符”n”。”\n”匹配换行符。序列<code>&quot;\\\\&quot;</code>匹配<code>&quot;\\&quot;</code>，<code>&quot;\\(&quot;</code>匹配”(“。</td>
</tr>
<tr>
<td align="center">^</td>
<td align="left">匹配输入字符串开始的位置。如果设置了 <strong>RegExp</strong> 对象的 <strong>Multiline</strong> 属性，^ 还会与”\n”或”\r”之后的位置匹配。</td>
</tr>
<tr>
<td align="center">$</td>
<td align="left">匹配输入字符串结尾的位置。如果设置了 <strong>RegExp</strong> 对象的 <strong>Multiline</strong> 属性，$ 还会与”\n”或”\r”之前的位置匹配。</td>
</tr>
<tr>
<td align="center">*</td>
<td align="left">零次或多次匹配前面的字符或子表达式。例如，zo* 匹配”z”和”zoo”。* 等效于 {0,}。</td>
</tr>
<tr>
<td align="center">+</td>
<td align="left">一次或多次匹配前面的字符或子表达式。例如，”zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 {1,}。</td>
</tr>
<tr>
<td align="center">?</td>
<td align="left">零次或一次匹配前面的字符或子表达式。例如，”do(es)?”匹配”do”或”does”中的”do”。? 等效于 {0,1}。</td>
</tr>
<tr>
<td align="center">{<em>n</em>}</td>
<td align="left"><em>n</em> 是非负整数。正好匹配 <em>n</em> 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。</td>
</tr>
<tr>
<td align="center">{<em>n</em>,}</td>
<td align="left"><em>n</em> 是非负整数。至少匹配 <em>n</em> 次。例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o*”。</td>
</tr>
<tr>
<td align="center">{<em>n</em>,<em>m</em>}</td>
<td align="left"><em>m</em> 和 <em>n</em> 是非负整数，其中 <em>n</em> &lt;= <em>m</em>。匹配至少 <em>n</em> 次，至多 <em>m</em> 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。</td>
</tr>
<tr>
<td align="center">?</td>
<td align="left">当此字符紧随任何其他限定符（<em>、+、?、{*n</em>}、{<em>n</em>,}、{<em>n</em>,<em>m</em>}）之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”。</td>
</tr>
<tr>
<td align="center">.</td>
<td align="left">匹配除”\r\n”之外的任何单个字符。若要匹配包括”\r\n”在内的任意字符，请使用诸如”[\s\S]”之类的模式。</td>
</tr>
<tr>
<td align="center">(<em>pattern</em>)</td>
<td align="left">匹配 <em>pattern</em> 并捕获该匹配的子表达式。可以使用 <strong>$0…$9</strong> 属性从结果”匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用”(“或者”)“。</td>
</tr>
<tr>
<td align="center">(?:<em>pattern</em>)</td>
<td align="left">匹配 <em>pattern</em> 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用”or”字符 (|) 组合模式部件的情况很有用。例如，’industr(?:y|ies) 是比 ‘industry|industries’ 更经济的表达式。</td>
</tr>
<tr>
<td align="center">(?=<em>pattern</em>)</td>
<td align="left">执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 <em>pattern</em> 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?=95|98|NT|2000)’ 匹配”Windows 2000”中的”Windows”，但不匹配”Windows 3.1”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td>
</tr>
<tr>
<td align="center">(?!<em>pattern</em>)</td>
<td align="left">执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 <em>pattern</em> 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?!95|98|NT|2000)’ 匹配”Windows 3.1”中的 “Windows”，但不匹配”Windows 2000”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</td>
</tr>
<tr>
<td align="center"><em>x</em>|<em>y</em></td>
<td align="left">匹配 <em>x</em> 或 <em>y</em>。例如，’z|food’ 匹配”z”或”food”。’(z|f)ood’ 匹配”zood”或”food”。</td>
</tr>
<tr>
<td align="center">[<em>xyz</em>]</td>
<td align="left">字符集。匹配包含的任一字符。例如，”[abc]”匹配”plain”中的”a”。</td>
</tr>
<tr>
<td align="center">[^<em>xyz</em>]</td>
<td align="left">反向字符集。匹配未包含的任何字符。例如，”[^abc]”匹配”plain”中”p”，”l”，”i”，”n”。</td>
</tr>
<tr>
<td align="center">[<em>a-z</em>]</td>
<td align="left">字符范围。匹配指定范围内的任何字符。例如，”[a-z]”匹配”a”到”z”范围内的任何小写字母。</td>
</tr>
<tr>
<td align="center">[^<em>a-z</em>]</td>
<td align="left">反向范围字符。匹配不在指定的范围内的任何字符。例如，”[^a-z]”匹配任何不在”a”到”z”范围内的任何字符。</td>
</tr>
<tr>
<td align="center">\b</td>
<td align="left">匹配一个字边界，即字与空格间的位置。例如，”er\b”匹配”never”中的”er”，但不匹配”verb”中的”er”。</td>
</tr>
<tr>
<td align="center">\B</td>
<td align="left">非字边界匹配。”er\B”匹配”verb”中的”er”，但不匹配”never”中的”er”。</td>
</tr>
<tr>
<td align="center">\c<em>x</em></td>
<td align="left">匹配 <em>x</em> 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。<em>x</em> 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是”c”字符本身。</td>
</tr>
<tr>
<td align="center">\d</td>
<td align="left">数字字符匹配。等效于 [0-9]。</td>
</tr>
<tr>
<td align="center">\D</td>
<td align="left">非数字字符匹配。等效于 <code>[^0-9]</code>。</td>
</tr>
<tr>
<td align="center">\f</td>
<td align="left">换页符匹配。等效于 \x0c 和 \cL。</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="left">换行符匹配。等效于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td align="center">\r</td>
<td align="left">匹配一个回车符。等效于 \x0d 和 \cM。</td>
</tr>
<tr>
<td align="center">\s</td>
<td align="left">匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。</td>
</tr>
<tr>
<td align="center">\S</td>
<td align="left">匹配任何非空白字符。与 <code>[^ \f\n\r\t\v]</code> 等效。</td>
</tr>
<tr>
<td align="center">\t</td>
<td align="left">制表符匹配。与 \x09 和 \cI 等效。</td>
</tr>
<tr>
<td align="center">\v</td>
<td align="left">垂直制表符匹配。与 \x0b 和 \cK 等效。</td>
</tr>
<tr>
<td align="center">\w</td>
<td align="left">匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效。</td>
</tr>
<tr>
<td align="center">\W</td>
<td align="left">与任何非单词字符匹配。与”<code>[^A-Za-z0-9_]</code>“等效。</td>
</tr>
<tr>
<td align="center">\x<em>n</em></td>
<td align="left">匹配 <em>n</em>，此处的 <em>n</em> 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，”\x41”匹配”A”。”\x041”与”\x04”&amp;”1”等效。允许在正则表达式中使用 ASCII 代码。</td>
</tr>
<tr>
<td align="center">*num*</td>
<td align="left">匹配 <em>num*，此处的 *num</em> 是一个正整数。到捕获匹配的反向引用。例如，”(.)\1”匹配两个连续的相同字符。</td>
</tr>
<tr>
<td align="center">*n*</td>
<td align="left">标识一个八进制转义码或反向引用。如果 *n* 前面至少有 <em>n</em> 个捕获子表达式，那么 <em>n</em> 是反向引用。否则，如果 <em>n</em> 是八进制数 (0-7)，那么 <em>n</em> 是八进制转义码。</td>
</tr>
<tr>
<td align="center">*nm*</td>
<td align="left">标识一个八进制转义码或反向引用。如果 *nm* 前面至少有 <em>nm</em> 个捕获子表达式，那么 <em>nm</em> 是反向引用。如果 *nm* 前面至少有 <em>n</em> 个捕获，则 <em>n</em> 是反向引用，后面跟有字符 <em>m</em>。如果两种前面的情况都不存在，则 *nm* 匹配八进制值 <em>nm*，其中 *n</em> 和 <em>m</em> 是八进制数字 (0-7)。</td>
</tr>
<tr>
<td align="center">\nml</td>
<td align="left">当 <em>n</em> 是八进制数 (0-3)，<em>m</em> 和 <em>l</em> 是八进制数 (0-7) 时，匹配八进制转义码 <em>nml</em>。</td>
</tr>
<tr>
<td align="center">\u<em>n</em></td>
<td align="left">匹配 <em>n</em>，其中 <em>n</em> 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。</td>
</tr>
</tbody></table>
<p>Java中的String类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java中可以用Pattern类表示正则表达式对象，它提供了丰富的API进行各种正则表达式操作，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegExpTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;成都市(成华区)(武侯区)(高新区)&quot;</span>;</span><br><span class="line">        Pattern p = Pattern.compile(<span class="string">&quot;.*?(?=\\()&quot;</span>);</span><br><span class="line">        Matcher m = p.matcher(str);</span><br><span class="line">        <span class="keyword">if</span>(m.find()) &#123;</span><br><span class="line">            System.out.println(m.group());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result: 成都市</span><br></pre></td></tr></table></figure>

<h6 id="Java与JavaScript的比较"><a href="#Java与JavaScript的比较" class="headerlink" title="Java与JavaScript的比较"></a>Java与JavaScript的比较</h6><p>Java是面向对象的程序设计语言，适用于互联网应用程序的开发。JavaScript是一种可以嵌入到Web页面中运行的基于对象和事件驱动的解释性语言。</p>
<p>Java是真正的面向对象语言，即使开发简单的应用程序，必须设计对象；而JavaScript是脚本语言，基于对象的事件驱动的编程语言，所以它本身就含有大量的内部对象供编程者使用。</p>
<p>Java源代码在运行前必须先进行编译，JavaScript是解释性变成语言，源代码不需要进行编译，由浏览器解释执行。</p>
<p>Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript的解释器在运行时检查推断其数据类型。</p>
<p>代码格式不一样。</p>
<h6 id="Array与ArrayList的区别"><a href="#Array与ArrayList的区别" class="headerlink" title="Array与ArrayList的区别"></a>Array与ArrayList的区别</h6><p>Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。</p>
<p>Array大小是固定的，ArrayList的大小是动态变化的。</p>
<p>ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。</p>
<p>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p>
<h6 id="Java8的新特性"><a href="#Java8的新特性" class="headerlink" title="Java8的新特性"></a>Java8的新特性</h6><p>Lambda 表达式 − Lambda允许把函数作为一个方法的参数传递到方法中。</p>
<p>方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p>
<p>默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。</p>
<p>新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。</p>
<p>Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</p>
<p>Date Time API − 加强对日期与时间的处理。</p>
<p>Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</p>
<p>Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</p>
<h6 id="为什么重写equals还要重写hashcode"><a href="#为什么重写equals还要重写hashcode" class="headerlink" title="为什么重写equals还要重写hashcode?"></a>为什么重写equals还要重写hashcode?</h6><p>HashMap中，如果要比较key是否相等，要同时使用这两个函数！因为自定义的类的hashcode()方法继承于Object类，其hashcode码为默认的内存地址，这样即便有相同含义的两个对象，比较也是不相等的。HashMap中的比较key是这样的，先求出key的hashcode(),比较其值是否相等，若相等再比较equals(),若相等则认为他们是相等的。若equals()不相等则认为他们不相等。如果只重写hashcode()不重写equals()方法，当比较equals()时只是看他们是否为同一对象（即进行内存地址的比较）,所以必定要两个方法一起重写。HashMap用来判断key是否相等的方法，其实是调用了HashSet判断加入元素是否相等。重载hashCode()是为了对同一个key，能得到相同的Hash Code，这样HashMap就可以定位到我们指定的key上。重载equals()是为了向HashMap表明当前对象和key上所保存的对象是相等的，这样我们才真正地获得了这个key所对应的这个键值对。</p>
<h6 id="map的分类和常见的情况"><a href="#map的分类和常见的情况" class="headerlink" title="map的分类和常见的情况"></a>map的分类和常见的情况</h6><p>java为数据结构中的映射定义了一个接口java.util.Map。它有四个实现类,分别是HashMap、HashTable、LinkedHashMap 和TreeMap。</p>
<p>Map主要用于存储键值对，根据键得到值，因此不允许键重复(重复了覆盖),但允许值重复。</p>
<p>Hashmap 是一个最常用的Map,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。 HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。</p>
<p>Hashtable与 HashMap类似,它继承自Dictionary类，不同的是:它不允许记录的键或者值为空;它支持线程的同步，即任一时刻只有一个线程能写Hashtable,因此也导致了 Hashtable在写入时会比较慢。</p>
<p>LinkedHashMap 是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。</p>
<p>TreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。</p>
<p>一般情况下，我们用的最多的是HashMap,在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。如果需要输出的顺序和输入的相同,那么用LinkedHashMap 可以实现,它还可以按读取顺序来排列.</p>
<p>HashMap是一个最常用的Map，它根据键的hashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。HashMap最多只允许一条记录的键为NULL，允许多条记录的值为NULL。</p>
<p>HashMap不支持线程同步，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致性。如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力。</p>
<p>Hashtable与HashMap类似，不同的是：它不允许记录的键或者值为空；它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtable在写入时会比较慢。</p>
<p>LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的。</p>
<p>在遍历的时候会比HashMap慢TreeMap能够把它保存的记录根据键排序，默认是按升序排序，也可以指定排序的比较器。当用Iterator遍历TreeMap时，得到的记录是排过序的。</p>
<h6 id="synchronized和lock"><a href="#synchronized和lock" class="headerlink" title="synchronized和lock"></a>synchronized和lock</h6><p>synchronized是Java的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。JDK1.5以后引入了自旋锁、锁粗化、轻量级锁，偏向锁来有优化关键字的性能。</p>
<p>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</p>
<h6 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h6><p>volatile关键字是用来保证有序性和可见性的。这跟Java内存模型有关。比如我们所写的代码，不一定是按照我们自己书写的顺序来执行的，编译器会做重排序，CPU也会做重排序的，这样的重排序是为了减少流水线的阻塞的，引起流水阻塞，比如数据相关性，提高CPU的执行效率。需要有一定的顺序和规则来保证，不然程序员自己写的代码都不知带对不对了，所以有happens-before规则，其中有条就是volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；有序性实现的是通过插入内存屏障来保证的。可见性：首先Java内存模型分为，主内存，工作内存。比如线程A从主内存把变量从主内存读到了自己的工作内存中，做了加1的操作，但是此时没有将i的最新值刷新会主内存中，线程B此时读到的还是i的旧值。加了volatile关键字的代码生成的汇编代码发现，会多出一个lock前缀指令。Lock指令对Intel平台的CPU，早期是锁总线，这样代价太高了，后面提出了缓存一致性协议，MESI，来保证了多核之间数据不一致性问题。</p>
<h6 id="hashCode-和equals的联系"><a href="#hashCode-和equals的联系" class="headerlink" title="hashCode()和equals的联系"></a>hashCode()和equals的联系</h6><p>Java对象的eqauls方法和hashCode方法是这样规定的：</p>
<p>➀相等（相同）的对象必须具有相等的哈希码（或者散列码）。</p>
<p>➁如果两个对象的hashCode相同，它们并不一定相同。</p>
<h6 id="面向对象的”六原则一法则”"><a href="#面向对象的”六原则一法则”" class="headerlink" title="面向对象的”六原则一法则”"></a>面向对象的”六原则一法则”</h6><p><strong>单一职责原则</strong>：一个类只做它该做的事情。（单一职责原则想表达的就是”高内聚”，写代码最终极的原则只有六个字”高内聚、低耦合”，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。）</p>
<p><strong>开闭原则</strong>：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。）</p>
<p><strong>依赖倒转原则</strong>：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。）</p>
<p><strong>里氏替换原则</strong>：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。）</p>
<p><strong>接口隔离原则</strong>：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。）</p>
<p><strong>合成聚合复用原则</strong>：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A关系、Has-A关系、Use-A关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A关系，合成聚合复用原则想表达的是优先考虑Has-A关系而不是Is-A关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在Java的API中也有不少滥用继承的例子，例如Properties类继承了Hashtable类，Stack类继承了Vector类，这些继承明显就是错误的，更好的做法是在Properties类中放置一个Hashtable类型的成员并且将其键和值都设置为字符串来存储数据，而Stack类的设计也应该是在Stack类中放一个Vector对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。）</p>
<p><strong>迪米特法则</strong>：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。再复杂的系统都可以为用户提供一个简单的门面，Java Web开发中作为前端控制器的Servlet或Filter不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面经七</title>
    <url>/2020/05/06/11/03/Java%E9%9D%A2%E7%BB%8F%E4%B8%83/</url>
    <content><![CDATA[<p>Java面试总结七<a id="more"></a></p>
<h6 id="Redis的List能在什么场景下使用？"><a href="#Redis的List能在什么场景下使用？" class="headerlink" title="Redis的List能在什么场景下使用？"></a>Redis的List能在什么场景下使用？</h6><p>Redis 中list的数据结构实现是双向链表，所以可以非常便捷的应用于消息队列（生产者 / 消费者模型）。消息的生产者只需要通过lpush将消息放入 list，消费者便可以通过rpop取出该消息，并且可以保证消息的有序性。如果需要实现带有优先级的消息队列也可以选择sorted set。而pub/sub功能也可以用作发布者 / 订阅者模型的消息。</p>
<h6 id="AOF和RDB都有哪些优点？以及两者有何区别？"><a href="#AOF和RDB都有哪些优点？以及两者有何区别？" class="headerlink" title="AOF和RDB都有哪些优点？以及两者有何区别？"></a>AOF和RDB都有哪些优点？以及两者有何区别？</h6><p>Redis的数据都存放在内存中，如果没有配置持久化，redis重启后数据就全丢失了，于是需要开启redis的持久化功能，将数据保存到磁盘上，当redis重启后，可以从磁盘中恢复数据。redis提供两种方式进行持久化，一种是RDB持久化（原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化），另外一种是AOF持久化（原理是将Reids的操作日志以追加的方式写入文件）。</p>
<p>RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。</p>
<p>AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。你甚至可以关闭持久化功能，让数据只在服务器运行时存在。</p>
<p>RDB 的优点:</p>
<p>RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心，或者亚马逊 S3 中。RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</p>
<p>RDB 的缺点:</p>
<p>如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， 因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， fork() 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端； 如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 虽然 AOF 重写也需要进行 fork() ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。</p>
<p>AOF 的优点:</p>
<p>使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 fsync 策略，比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 fsync 。 AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 seek ， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， redis-check-aof 工具也可以轻易地修复这种问题。</p>
<p>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。</p>
<p>AOF 的缺点:</p>
<p>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。AOF 在过去曾经发生过这样的 bug ： 因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。 （举个例子，阻塞命令 BRPOPLPUSH 就曾经引起过这样的 bug 。） 测试套件里为这种情况添加了测试： 它们会自动生成随机的、复杂的数据集， 并通过重新载入这些数据来确保一切正常。 虽然这种 bug 在 AOF 文件中并不常见， 但是对比来说， RDB 几乎是不可能出现这种 bug 的。</p>
<h6 id="Redis为什么是单线程？"><a href="#Redis为什么是单线程？" class="headerlink" title="Redis为什么是单线程？"></a>Redis为什么是单线程？</h6><p>因为CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>
<p>缺点：服务器其他核闲置。</p>
<h6 id="为什么-redis-读写速率快、性能好？"><a href="#为什么-redis-读写速率快、性能好？" class="headerlink" title="为什么 redis 读写速率快、性能好？"></a>为什么 redis 读写速率快、性能好？</h6><p>Redis是纯内存数据库，相对于读写磁盘，读写内存的速度就不是几倍几十倍了，一般，hash查找可以达到每秒百万次的数量级。</p>
<p>多路复用IO，“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗）。可以直接理解为：单线程的原子操作，避免上下文切换的时间和性能消耗；加上对内存中数据的处理速度，很自然的提高redis的吞吐量。</p>
<h6 id="DAO模式"><a href="#DAO模式" class="headerlink" title="DAO模式"></a>DAO模式</h6><p>DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共API中。用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。DAO模式实际上包含了两个模式，一是Data Accessor（数据访问器），二是Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。</p>
<h6 id="Get和Post请求的区别"><a href="#Get和Post请求的区别" class="headerlink" title="Get和Post请求的区别"></a>Get和Post请求的区别</h6><p>①get请求用来从服务器上获得资源，而post是用来向服务器提交数据；</p>
<p>②get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用”?”连接，而各个变量之间使用”&amp;”连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL；</p>
<p>③get传输的数据要受到URL长度限制（1024字节）；而post可以传输大量的数据，上传文件通常要使用post方式；</p>
<p>④使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post；</p>
<p>⑤get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是”%20”。</p>
<h6 id="J2EE常用名词解释"><a href="#J2EE常用名词解释" class="headerlink" title="J2EE常用名词解释"></a>J2EE常用名词解释</h6><p><strong>web 容器</strong>：给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使JSP,SERVLET直接和容器中的环境变量接接口互，不必关注其它系统问题。主要有WEB服务器来实现。例如：TOMCAT,WEBLOGIC,WEBSPHERE等。该容器提供的接口严格遵守J2EE规范中的WEBAPPLICATION 标准。我们把遵守以上标准的WEB服务器就叫做J2EE中的WEB容器。</p>
<p><strong>Web container</strong>：实现J2EE体系结构中Web组件协议的容器。这个协议规定了一个Web组件运行时的环境，包括安全，一致性，生命周期管理，事务，配置和其它的服务。一个提供和JSP和J2EE平台APIs界面相同服务的容器。一个Web container 由Web服务器或者J2EE服务器提供。</p>
<p><strong>EJB容器</strong>：Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件EJB各种管理功能。只要满足J2EE规范的EJB放入该容器，马上就会被容器进行高效率的管理。并且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。一个实现了J2EE体系结构中EJB组件规范的容器。这个规范指定了一个Enterprise bean的运行时环境，包括安全，一致性，生命周期，事务，配置，和其他的服务。</p>
<p><strong>JNDI</strong>：（Java Naming &amp; Directory Interface）JAVA命名目录服务。主要提供的功能是：提供一个目录系统，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布式应用程序的功能。</p>
<p><strong>JMS</strong>：（Java Message Service）JAVA消息服务。主要实现各个应用程序之间的通讯。包括点对点和广播。</p>
<p><strong>JTA</strong>：（Java Transaction API）JAVA事务服务。提供各种分布式事务服务。应用程序只需调用其提供的接口即可。</p>
<p><strong>JAF</strong>：（Java Action FrameWork）JAVA安全认证框架。提供一些安全控制方面的框架。让开发者通过各种部署和自定义实现自己的个性安全控制策略。</p>
<p><strong>RMI/IIOP</strong>: （Remote Method Invocation /internet对象请求中介协议）他们主要用于通过远程调用服务。例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本地计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通信。RMI是JAVA特有的。RMI-IIOP出现以前，只有RMI和 CORBA两种选择来进行分布式程序设计。RMI-IIOP综合了RMI和CORBA的优点，克服了他们的缺点，使得程序员能更方便的编写分布式程序设计，实现分布式计算。首先，RMI-IIOP综合了RMI的简单性和CORBA的多语言性（兼容性），其次RMI-IIOP克服了RMI只能用于Java 的缺点和CORBA的复杂性。</p>
<h6 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h6><p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</p>
<p>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗</p>
<p>考虑到安全应当使用session。</p>
<p>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。</p>
<p>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p>
<h6 id="数据库优化方法"><a href="#数据库优化方法" class="headerlink" title="数据库优化方法"></a>数据库优化方法</h6><p>（1）选取最适用的字段属性</p>
<p>MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。</p>
<p>例如，在定义邮政编码这个字段时，如果将其设置为CHAR(255),显然给数据库增加了不必要的空间，甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段。</p>
<p>另外一个提高效率的方法是在可能的情况下，应该尽量把字段设置为NOTNULL，这样在将来执行查询的时候，数据库不用去比较NULL值。<br>对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。</p>
<p>（2）使用连接（JOIN）来代替子查询(Sub-Queries)</p>
<p>MySQL从4.1开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。例如，我们要将客户基本信息表中没有任何订单的客户删除掉，就可以利用子查询先从销售信息表中将所有发出订单的客户ID取出来，然后将结果传递给主查询</p>
<p>（3）使用联合(UNION)来代替手动创建的临时表</p>
<p>MySQL从4.0的版本开始支持union查询，它可以把需要使用临时表的两条或更多的select查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。使用union来创建查询的时候，我们只需要用UNION作为关键字把多个select语句连接起来就可以了，要注意的是所有select语句中的字段数目要想同。下面的例子就演示了一个使用UNION的查询。</p>
<p>（4）事务</p>
<p>尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样的查询，但不是所有的数据库操作都可以只用一条或少数几条SQL语句就可以完成的。更多的时候是需要用到一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来。设想一下，要把某个数据同时插入两个相关联的表中，可能会出现这样的情况：第一个表中成功更新后，数据库突然出现意外状况，造成第二个表中的操作没有完成，这样，就会造成数据的不完整，甚至会破坏数据库中的数据。要避免这种情况，就应该使用事务，它的作用是：要么语句块中每条语句都操作成功，要么都失败。换句话说，就是可以保持数据库中数据的一致性和完整性。事物以BEGIN关键字开始，COMMIT关键字结束。在这之间的一条SQL操作失败，那么，ROLLBACK命令就可以把数据库恢复到BEGIN开始之前的状态。</p>
<h6 id="数据库的三个范式"><a href="#数据库的三个范式" class="headerlink" title="数据库的三个范式"></a>数据库的三个范式</h6><p>第一范式（1NF）<br>强调的是列的原子性，即列不能够再分成其他几列。</p>
<p>第二范式（2NF）<br>首先是 1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。<br>在1NF基础上，任何非主属性不依赖于其它非主属性[在2NF基础上消除传递依赖]。</p>
<p>第三范式（3NF）<br>第三范式（3NF）是第二范式（2NF）的一个子集，即满足第三范式（3NF）必须满足第二范式（2NF）。首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据库学习</title>
    <url>/2019/12/26/15/01/Redis%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>Redis数据库的一些常用知识了解。<a id="more"></a></p>
<h4 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h4><p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。</p>
<p>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p>
<p>它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p>
<p>Redis 与其他 key - value 缓存产品有以下三个特点：</p>
<ul>
<li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份。</li>
</ul>
<h4 id="Redis基本命令"><a href="#Redis基本命令" class="headerlink" title="Redis基本命令"></a>Redis基本命令</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">redis-cli</td>
<td align="center">本地连接redis数据库</td>
</tr>
<tr>
<td align="center">redis-cli -h host -p port -a password</td>
<td align="center">远程连接redis数据库</td>
</tr>
<tr>
<td align="center">set key value</td>
<td align="center">设置指定key的值，返回值：OK</td>
</tr>
<tr>
<td align="center">get key</td>
<td align="center">获取指定key的值</td>
</tr>
<tr>
<td align="center">del key</td>
<td align="center">删除指定的key，返回值：1或0</td>
</tr>
<tr>
<td align="center">dump key</td>
<td align="center">序列化给定的key，返回被序列化的值</td>
</tr>
<tr>
<td align="center">exists key</td>
<td align="center">检查key是否存在</td>
</tr>
<tr>
<td align="center">exists key second</td>
<td align="center">给key设置过期时间，以秒计</td>
</tr>
<tr>
<td align="center">expireat key timestamp</td>
<td align="center">设置过期时间，参数是时间戳</td>
</tr>
<tr>
<td align="center">move key db</td>
<td align="center">将当前数据库的key移动到给定的数据库db中</td>
</tr>
<tr>
<td align="center">persist key</td>
<td align="center">移除key的过期时间，key将继续保持</td>
</tr>
<tr>
<td align="center">ttl key</td>
<td align="center">以秒计，返回给定key的剩余生存时间time to live</td>
</tr>
<tr>
<td align="center">randomkey</td>
<td align="center">从当前数据库中随机返回一个key</td>
</tr>
<tr>
<td align="center">rename key newkey</td>
<td align="center">修改key的名称</td>
</tr>
<tr>
<td align="center">type key</td>
<td align="center">返回key所存储的值的类型</td>
</tr>
</tbody></table>
<h4 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h4><h5 id="字符串String"><a href="#字符串String" class="headerlink" title="字符串String"></a>字符串String</h5><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getrange key start end</td>
<td align="center">返回key中字符串的子字符</td>
</tr>
<tr>
<td align="center">getset key value</td>
<td align="center">将给定的key设为value，并返回key的旧值</td>
</tr>
<tr>
<td align="center">getbit key offset</td>
<td align="center">对key所存储的字符串值，获取指定偏移量上的位（bit）</td>
</tr>
<tr>
<td align="center">mget key1 [key2…]</td>
<td align="center">获取所有(一个或多个)给定key的值</td>
</tr>
<tr>
<td align="center">setbit key offset value</td>
<td align="center">对key所存储的字符串值，设置或清除指定偏移量上的位(bit)</td>
</tr>
<tr>
<td align="center">setex key seconds value</td>
<td align="center">将值value关联到key，并将key的过期时间设为seconds</td>
</tr>
<tr>
<td align="center">setnx key value</td>
<td align="center">只有key不存在时设置key的值</td>
</tr>
<tr>
<td align="center">setrange key offset value</td>
<td align="center">用value参数覆写给定key所存储的字符串值，从偏移量offset开始</td>
</tr>
<tr>
<td align="center">setrange key</td>
<td align="center">返回key所存储的字符串长度</td>
</tr>
<tr>
<td align="center">mset key value [key value…]</td>
<td align="center">同时设置一个或多个key-value对</td>
</tr>
<tr>
<td align="center">incr key</td>
<td align="center">将key中存储的数字值增一</td>
</tr>
<tr>
<td align="center">incrbyfloat key increment</td>
<td align="center">将key所存储的值加上给定的增量值</td>
</tr>
<tr>
<td align="center">decr key</td>
<td align="center">将key中存储的数字值减一</td>
</tr>
<tr>
<td align="center">decrby key decrement</td>
<td align="center">key所存储的值减去给定的减量值</td>
</tr>
<tr>
<td align="center">append key value</td>
<td align="center">如果key已经存在并且是一个字符串，append命令将指定的value追加到该key原来值(value)的末尾</td>
</tr>
</tbody></table>
<h5 id="哈希Hash"><a href="#哈希Hash" class="headerlink" title="哈希Hash"></a>哈希Hash</h5><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">hdel key field1 [field2]</td>
<td align="center">删除一个或多个哈希字段</td>
</tr>
<tr>
<td align="center">hget key field</td>
<td align="center">获取存储在哈希表中指定字段和值</td>
</tr>
<tr>
<td align="center">hgetall key</td>
<td align="center">获取在哈希表中指定key的所有字段和值</td>
</tr>
<tr>
<td align="center">hincrby key field increment</td>
<td align="center">为哈希表key中的指定字段的整数值加上增量increment</td>
</tr>
<tr>
<td align="center">hkeys key</td>
<td align="center">获取所有哈希表中的字段</td>
</tr>
<tr>
<td align="center">hlen key</td>
<td align="center">获取哈希表中字段的数量</td>
</tr>
<tr>
<td align="center">hmget key field1 [field2]</td>
<td align="center">获取所有给定字段的值</td>
</tr>
<tr>
<td align="center">hmset key field1 value1 [field2 value2]</td>
<td align="center">同时将多个field-value对设置到哈希表key中</td>
</tr>
<tr>
<td align="center">hset key field value</td>
<td align="center">将哈希表key中的字段field的值设为value</td>
</tr>
<tr>
<td align="center">hvals key</td>
<td align="center">获取哈希表中所有值</td>
</tr>
</tbody></table>
<h5 id="列表List"><a href="#列表List" class="headerlink" title="列表List"></a>列表List</h5><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">lpush|rpush listname key</td>
<td align="center">从左/右边将值插入列表</td>
</tr>
<tr>
<td align="center">blpop key1 [key2] timeout</td>
<td align="center">移除并获取列表的第一个元素，如果列表没有元素会阻塞列表知道等待超时或发现可弹出元素为止</td>
</tr>
<tr>
<td align="center">brpop key1 [key2] timeout</td>
<td align="center">移除并获取列表的最后一个元素，如果没有，同上</td>
</tr>
<tr>
<td align="center">brpoplpush source destination timeout</td>
<td align="center">从列表弹出一个值，将弹出的元素插入到另一个列表中并返回塔，如果没有元素，同上</td>
</tr>
<tr>
<td align="center">lindex key index</td>
<td align="center">通过索引获取列表中的元素</td>
</tr>
<tr>
<td align="center">linsert key before|after pivot value</td>
<td align="center">在列表的元素前或者后插入元素</td>
</tr>
<tr>
<td align="center">llen key</td>
<td align="center">获取列表长度</td>
</tr>
<tr>
<td align="center">lpop key</td>
<td align="center">移除并获取列表的第一个元素</td>
</tr>
<tr>
<td align="center">lpush key value1 [value2]</td>
<td align="center">将一个或多个值插入到列表头部</td>
</tr>
<tr>
<td align="center">lpushx key value</td>
<td align="center">将一个值插入到已存在的列表头部</td>
</tr>
<tr>
<td align="center">lrange key start stop</td>
<td align="center">获取列表指定范围内的元素</td>
</tr>
<tr>
<td align="center">lrem key count value</td>
<td align="center">移除列表元素</td>
</tr>
<tr>
<td align="center">lset key index value</td>
<td align="center">通过索引设置列表元素的值</td>
</tr>
<tr>
<td align="center">ltrim key start stop</td>
<td align="center">对一个列表进行修剪(trim)，只保留区间内的元素</td>
</tr>
<tr>
<td align="center">rpop key</td>
<td align="center">移除列表的最后一个元素，返回值为移除的元素</td>
</tr>
<tr>
<td align="center">rpoplpush source destination</td>
<td align="center">移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td>
</tr>
<tr>
<td align="center">rpushx key value</td>
<td align="center">为已存在的列表添加值</td>
</tr>
</tbody></table>
<h5 id="集合Set"><a href="#集合Set" class="headerlink" title="集合Set"></a>集合Set</h5><p>Redis中的set是String类型的无序集合。集合成员是唯一的。Redis中集合是通过哈希表实现的。</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sadd key member1 [member2]</td>
<td align="center">向集合添加一个或多个成员</td>
</tr>
<tr>
<td align="center">scard key</td>
<td align="center">获取集合的成员数</td>
</tr>
<tr>
<td align="center">sdiff key1 [key2]</td>
<td align="center">返回给定所有集合的差集</td>
</tr>
<tr>
<td align="center">sdiffstore destination key1 [key2]</td>
<td align="center">返回给定所有集合的差集并存储在destination中</td>
</tr>
<tr>
<td align="center">sinter key1 [key2]</td>
<td align="center">返回给定所有集合的交集</td>
</tr>
<tr>
<td align="center">sinterstore destionation key1 [key2]</td>
<td align="center">返回给定集合所有几何的交集并存储在destination中</td>
</tr>
<tr>
<td align="center">sismember key member</td>
<td align="center">判断member元素是否是集合key的成员</td>
</tr>
<tr>
<td align="center">smebers key</td>
<td align="center">返回集合中的所有成员</td>
</tr>
<tr>
<td align="center">smove source destination member</td>
<td align="center">将member元素从source集合移动到destination集合</td>
</tr>
<tr>
<td align="center">spop key</td>
<td align="center">移除并返回集合中的一个随机元素</td>
</tr>
<tr>
<td align="center">srandmember key [count]</td>
<td align="center">移除集合中一个或多个随机数</td>
</tr>
<tr>
<td align="center">srem key member1 [member2]</td>
<td align="center">移除集合中一个或多个成员</td>
</tr>
<tr>
<td align="center">sunion key1 [key2]</td>
<td align="center">返回所有给定集合的并集</td>
</tr>
<tr>
<td align="center">sunionstore destination key1 [key2]</td>
<td align="center">所有给定集合的并集存储在destination集合中</td>
</tr>
</tbody></table>
<h5 id="有序集合Sorted"><a href="#有序集合Sorted" class="headerlink" title="有序集合Sorted"></a>有序集合Sorted</h5><p>每个元素都会关联一个double类型的分数。redis正式通过分数来为集合中的成员进行从小到大的排序。集合成员是唯一的，但是分数却可以重复。</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">zadd key score1 member1</td>
<td align="center">向有序集合添加一个或多个成员，或更新已存在成员的分数</td>
</tr>
<tr>
<td align="center">zcard key</td>
<td align="center">获取有序集合的成员数</td>
</tr>
<tr>
<td align="center">zcount key min max</td>
<td align="center">计算在有序集合中指定成员数</td>
</tr>
<tr>
<td align="center">zincrby key increment member</td>
<td align="center">有序集合中对指定成员的分数加上增量increment</td>
</tr>
<tr>
<td align="center">zinterstore destination numkeys key</td>
<td align="center">计算给定的一个或多个有序集合的交集并将结果集存储在新的有序集合key中</td>
</tr>
<tr>
<td align="center">zlexcount key min max</td>
<td align="center">在有序集合中计算指定字典区间内的成员</td>
</tr>
<tr>
<td align="center">zrangebylex key min max [limit offset count]</td>
<td align="center">通过字典区间返回有序集合的成员</td>
</tr>
<tr>
<td align="center">zrangebyscore key min max [withscores] [limit]</td>
<td align="center">通过分数返回有序集合指定区间内的成员</td>
</tr>
<tr>
<td align="center">zrank key member</td>
<td align="center">返回有序集合中指定成员的索引</td>
</tr>
<tr>
<td align="center">zrem key member</td>
<td align="center">移除有序集合中的成员</td>
</tr>
<tr>
<td align="center">zremrangebylex key min max</td>
<td align="center">移除有序集合中给定的字典区间的所有成员</td>
</tr>
<tr>
<td align="center">zremrangebyrank key start stop</td>
<td align="center">移除有序集合中给定的排名区间的所有成员</td>
</tr>
<tr>
<td align="center">zremrangebyscore key min max</td>
<td align="center">移除有序集合中给定的分数区间的所有成员</td>
</tr>
<tr>
<td align="center">zrevrange key start stop [withscores]</td>
<td align="center">返回有序集合中指定区间内的成员，通过索引，分数从高到低</td>
</tr>
<tr>
<td align="center">zrevrangebyscore key min max[withscores]</td>
<td align="center">返回有序集合中指定分数区间内的成员，分数从高到低排序</td>
</tr>
</tbody></table>
<h4 id="Redis发布订阅"><a href="#Redis发布订阅" class="headerlink" title="Redis发布订阅"></a>Redis发布订阅</h4><p>客户端可以订阅任意数量的频道，客户端发布消息到频道，频道收到消息后传递给所有订阅该频道的客户端。</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">subscribe redisChat</td>
<td align="center">创建订阅频道名为redisChat</td>
</tr>
<tr>
<td align="center">publish redisChat message</td>
<td align="center">频道发布消息</td>
</tr>
<tr>
<td align="center">pubsub subcommand [argument]</td>
<td align="center">查看订阅与发布系统状态</td>
</tr>
<tr>
<td align="center">publish channel message</td>
<td align="center">将信息发送到指定的频道</td>
</tr>
<tr>
<td align="center">subscribe channel</td>
<td align="center">订阅给定的频道</td>
</tr>
<tr>
<td align="center">unsubscribe channel</td>
<td align="center">退订给定的频道</td>
</tr>
</tbody></table>
<h4 id="Redis连接"><a href="#Redis连接" class="headerlink" title="Redis连接"></a>Redis连接</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">auth password</td>
<td align="center">验证密码是否正确</td>
</tr>
<tr>
<td align="center">echo message</td>
<td align="center">打印字符串</td>
</tr>
<tr>
<td align="center">ping</td>
<td align="center">查看服务是否运行</td>
</tr>
<tr>
<td align="center">quit</td>
<td align="center">关闭当前连接</td>
</tr>
<tr>
<td align="center">select index</td>
<td align="center">切换到指定的数据库</td>
</tr>
</tbody></table>
<h4 id="Redis服务器"><a href="#Redis服务器" class="headerlink" title="Redis服务器"></a>Redis服务器</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">bgrewriteaof</td>
<td align="center">异步执行一个AOF(appendonly file)文件重写操作</td>
</tr>
<tr>
<td align="center">bgsave</td>
<td align="center">在后台异步保存当前数据库的数据到磁盘</td>
</tr>
<tr>
<td align="center">client kill [ip:port]</td>
<td align="center">关闭客户端连接</td>
</tr>
<tr>
<td align="center">client list</td>
<td align="center">获取连接到服务器的客户端连接列表</td>
</tr>
<tr>
<td align="center">client getname</td>
<td align="center">获取连接的名称</td>
</tr>
<tr>
<td align="center">client pause timeout</td>
<td align="center">在指定时间内终止运行来自客户端的命令</td>
</tr>
<tr>
<td align="center">client setname connection-name</td>
<td align="center">设置当前连接的名称</td>
</tr>
<tr>
<td align="center">cluster slots</td>
<td align="center">获取集群节点的映射数组</td>
</tr>
<tr>
<td align="center">command</td>
<td align="center">获取Redis命令详情数组</td>
</tr>
<tr>
<td align="center">command count</td>
<td align="center">获取Redis命令总数</td>
</tr>
<tr>
<td align="center">command getkeys</td>
<td align="center">获取给定命令的所有键</td>
</tr>
<tr>
<td align="center">time</td>
<td align="center">返回当前服务器时间</td>
</tr>
<tr>
<td align="center">config get patameter</td>
<td align="center">获取指定配置参数的值</td>
</tr>
<tr>
<td align="center">config rewrite</td>
<td align="center">对启动redis服务器时所指定的redis.conf配置文件进行改写</td>
</tr>
<tr>
<td align="center">config set parameter value</td>
<td align="center">修改redis配置参数，无需重启</td>
</tr>
<tr>
<td align="center">config resetstat</td>
<td align="center">重置info命令中的某些统计数据</td>
</tr>
<tr>
<td align="center">dbsize</td>
<td align="center">返回当前数据库的key的数量</td>
</tr>
<tr>
<td align="center">debug object key</td>
<td align="center">获取key的调试信息</td>
</tr>
<tr>
<td align="center">debug segfault</td>
<td align="center">让redis服务崩溃</td>
</tr>
<tr>
<td align="center">flushall</td>
<td align="center">删除所有数据库的所有key</td>
</tr>
<tr>
<td align="center">flushdb</td>
<td align="center">删除当前数据库的所有key</td>
</tr>
<tr>
<td align="center">info</td>
<td align="center">获取redis服务器的各种信息和统计数值</td>
</tr>
<tr>
<td align="center">lastsave</td>
<td align="center">返回最近一次redis成功将数据保存到磁盘上的时间，以UNIX时间戳表示</td>
</tr>
<tr>
<td align="center">monitor</td>
<td align="center">实时打印出redis服务器接收到的命令，调试用</td>
</tr>
<tr>
<td align="center">role</td>
<td align="center">返回主从实例所属的角色</td>
</tr>
<tr>
<td align="center">save</td>
<td align="center">同步保存数据到硬盘</td>
</tr>
<tr>
<td align="center">shutdown [nosave] [save]</td>
<td align="center">异步保存数据到硬盘，并关闭服务器</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>java面试题</title>
    <url>/2020/04/25/23/31/java%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>Java面试理论题目<a id="more"></a></p>
<ol>
<li>下面哪个说法正确的( <strong>D</strong> )</li>
</ol>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">ConcurrentHashMap使用<span class="keyword">synchronized</span>关键字保证线程安全</span><br></pre></td></tr></table></figure>

<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">HashMap</span>实现了Collction接口</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Array</span><span class="selector-class">.asList</span>方法返回<span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.ArrayList</span>对象</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat是线程不安全的</span><br></pre></td></tr></table></figure>

<p>解析：A选项中，ConcurrentHashMap 使用segment来分段和管理锁，segment继承自ReentrantLock，因此ConcurrentHashMap使用ReentrantLock来保证线程安全。</p>
<p>B中，HashMap定义规则如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p>C中，应该是Arrays.asList()，其将一个数组转化为一个List对象，这个方法返回一个ArrayList类型的对象， 这个<font color="red">ArrayList类并非java.util.ArrayList类，而是Arrays类的内部类</font>。</p>
<p>2.下面哪些具体实现类可以用于存储键值对，并且方法调用提供了基本的多线程安全支持：(<strong>AE</strong>)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.ConcurrentHashMap</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.Map</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.TreeMap</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.SortMap</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.Hashtable</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.HashMap</span></span><br></pre></td></tr></table></figure>

<p>解析：线程安全的类有hashtable、concurrentHashMap、synchronizedMap。</p>
<p>3.以下描述错误的是( C )</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，是线程隔离的</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原则上讲，所有的对象都是在堆区上分配内存，是线程之间共享的</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法区用于存储JVM加载的类信息、常量、静态变量，即时编译器编译后的代码等数据，是线程隔离的</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java方法执行内存模型，用于存储局部变量，操作数栈，动态链接，方法出口等信息，是线程隔离的</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p><img src="/2020/04/25/23/31/java%E9%9D%A2%E8%AF%95%E9%A2%98/JavaMemory.png" alt></p>
<p>JAVA的JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method)</p>
<ul>
<li>栈区:</li>
</ul>
<ol>
<li><strong>每个线程包含一个栈区</strong>，栈中只保存方法中（不包括对象的成员变量）的<strong>基础数据类型和自定义对象的引用(不是对象)</strong>，对象都存放在堆区中</li>
<li>每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。</li>
<li>栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。</li>
</ol>
<ul>
<li>堆区:</li>
</ul>
<ol>
<li>存储的全部是对象实例，每个对象都包含一个与之对应的class的信息(class信息存放在方法区)。</li>
<li><strong>jvm只有一个堆区(heap)被所有线程共享</strong>，堆中不存放基本类型和对象引用，只存放对象本身，几乎所有的<strong>对象实例和数组</strong>都在堆中分配。</li>
</ol>
<ul>
<li>方法区:</li>
</ul>
<ol>
<li>又叫静态区，跟堆一样，被所有的线程共享。它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li>
</ol>
<p>4.类Person里面有个方法sleep()，如果直接用Person.sleep()，则方法sleep前面必须用的关键词是？  ( B )</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">static</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">final</span></span></span><br></pre></td></tr></table></figure>

<p>解析：sleep方法能被类直接调用，说明是静态的，随着类的加载而加载。</p>
<p><strong>static关键字：针对多个对象共有的成员变量值时所提出的。</strong></p>
<p><strong>特点：1、随着类的加载而加载；  2、优先于对象存在；  3、被类的所有对象共享；    4、可以通过类名直接调用。</strong></p>
<p>注意事项：1.在静态方法中是没有this关键字的；    2.静态方法只能访问静态的成员变量和静态的成员方法。</p>
<p>5.列表(List)和集合(Set)下面说法正确的是？  ( A )</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Set</span>中至多只能有一个空元素</span><br></pre></td></tr></table></figure>

<figure class="highlight capnproto"><table><tr><td class="code"><pre><span class="line"><span class="built_in">List</span>中至多只能有一个空元素</span><br></pre></td></tr></table></figure>

<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">List</span>和<span class="keyword">Set</span>都可以包含重复元素的有序集合</span><br></pre></td></tr></table></figure>

<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">List</span>和<span class="keyword">Set</span>都是有序集合</span><br></pre></td></tr></table></figure>

<p>解析：<font color="red">Set 不能有重复的元素，且是无序的，要有空值也就只能有一个。因为它不允许重复</font>。 L ist 可以有重复元素，且是有序的，要有空值也可以有多个，因为它可重复。</p>
<p>6.在JAVA中，假设A有构造方法A(int a)，则在类A的其他构造方法中调用该构造方法和语句格式应该为（ B ）</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.A(X)</span><br></pre></td></tr></table></figure>

<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">this</span><span class="params">(X)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">super</span><span class="params">(X)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">A</span><span class="params">(X)</span></span></span><br></pre></td></tr></table></figure>

<p>解析：<font color="red">this的作用其中一个就是在一个构造方法中调用另一个构造方法，格式为this(参数)；super是调用父类的方法；</font>A(a)这种形式是在new一个类时使用。</p>
<p>7.A 是抽象父类或接口， B ， C 派生自 A ，或实现 A ，现在 Java 源代码中有如下声明：</p>
<ol>
<li><p>A a0=new A();</p>
</li>
<li><p>A a1 =new B();</p>
</li>
<li><p>A a2=new C();</p>
</li>
</ol>
<p>问以下哪个说法是正确的？（ A ）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行不能通过编译</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">第<span class="number">1</span>、<span class="number">2</span>行能通过编译，但第<span class="number">3</span>行编译出错</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">第<span class="number">1</span>、<span class="number">2</span>、<span class="number">3</span>行能通过编译，但第<span class="number">2</span>、<span class="number">3</span>行运行时出错</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">第<span class="number">1</span>行、第<span class="number">2</span>行和第<span class="number">3</span>行的声明都是正确的</span><br></pre></td></tr></table></figure>

<p>解析：<font color="red">抽象类不能实例化</font>。抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。由于不能实例化对象，所以抽象类必须被继承，才能被使用。父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p>
<p>8.对于子类的构造函数说明，下列叙述中错误的是（ D ）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">子类不能继承父类的无参构造函数。</span><br></pre></td></tr></table></figure>

<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">子类可以在自己的构造函数中使用<span class="keyword">super</span>关键字来调用父类的含参数构造函数，但这个调用语句必须是子类构造函数的第一个可执行语句。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在创建子类的对象时，若不含带参构造函数，将先执行父类的无参构造函数，然后再执行自己的无参构造函数。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">子类不但可以继承父类的无参构造函数，也可以继承父类的有参构造函数。</span><br></pre></td></tr></table></figure>

<p>解析：<font color="red">构造函数不能被继承，只能被调用</font>。</p>
<p>9.在一个基于分布式的游戏服务器系统中，不同的服务器之间，哪种通信方式是不可行的（ A ）？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">管道</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">消息队列</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">高速缓冲数据库</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">套接字</span><br></pre></td></tr></table></figure>

<p>解析：对于管道，有下面这几种类型：</p>
<p>①普通管道（PIPE）：通常有两种限制，一是单工，即只能单向传输；二是血缘，即常用于父子进程间（或有血缘关系的进程间）。</p>
<p>②流管道（s_pipe）：去除了上述的第一种限制，实现了双向传输。</p>
<p>③命名管道（name_pipe）：去除了上述的第二种限制，实现了无血缘关系的不同进程间通信。</p>
<p>显然，要求是对于不同的服务器之间的通信，是要要求全双工形式的，而管道只能是半双工，虽然可以双向，但是同一时间只能有一个方向传输，全双工和半双工的区别可以如下图示理解：</p>
<p><img src="/2020/04/25/23/31/java%E9%9D%A2%E8%AF%95%E9%A2%98/PE.png" alt></p>
<p>10.</p>
<p>以下代码的输出结果是（ C ）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;?&gt;[] collections =</span><br><span class="line">                &#123;<span class="keyword">new</span> HashSet&lt;String&gt;(), <span class="keyword">new</span> ArrayList&lt;String&gt;(), <span class="keyword">new</span> HashMap&lt;String, String&gt;().values()&#125;;</span><br><span class="line">        Super subToSuper = <span class="keyword">new</span> Sub();</span><br><span class="line">        <span class="keyword">for</span> (Collection&lt;?&gt; collection : collections) &#123;</span><br><span class="line">            System.out.println(Super.getType(collection));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getType</span><span class="params">(Collection&lt;?&gt; collection)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Super:collection&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getType</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Super:list&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(ArrayList&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Super:arrayList&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getType</span><span class="params">(Set&lt;?&gt; set)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Super:set&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(HashSet&lt;?&gt; set)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Super:hashSet&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getType</span><span class="params">(Collection&lt;?&gt; collection)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Sub&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Sub:collection</span><br><span class="line">Sub:collection</span><br><span class="line">Sub:collection</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Sub:hashSet</span><br><span class="line">Sub:arrayList</span><br><span class="line">Sub:collection</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Super:collection</span><br><span class="line">Super:collection</span><br><span class="line">Super:collection</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Super:hashSet</span><br><span class="line">Super:arrayList</span><br><span class="line">Super:collection</span><br></pre></td></tr></table></figure>

<p>解析：这是静态分派的过程，在编译时已经决定了使用super的方法，因为subToSuper 是指super对象，可是为什么会选择collection呢，for循环出来他们实际上指的是collection对象表示的，即类似于Collection   col = new  HashSet&lt;&gt;();这样传入方法getType()中的参数就是col，左边是静态类型，右边是实际类型。由于重载实际上是使用静态分派的，重载时是通过参数的静态类型而不是实际类型作为判定依据的。</p>
<p>11.下面代码运行结果是（ C ）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;   </span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">return</span> a+b;      </span><br><span class="line">         &#125; </span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;catch语句块&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">finally</span>&#123; </span><br><span class="line">             System.out.println(<span class="string">&quot;finally语句块&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span></span>&#123; </span><br><span class="line">         Test test =<span class="keyword">new</span> Test(); </span><br><span class="line">         System.out.println(<span class="string">&quot;和是：&quot;</span>+test.add(<span class="number">9</span>, <span class="number">34</span>)); </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span>语句块</span><br><span class="line">和是：<span class="number">43</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">编译异常</span><br></pre></td></tr></table></figure>

<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">finally</span>语句块</span><br><span class="line">和是：<span class="number">43</span></span><br></pre></td></tr></table></figure>

<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">和是：<span class="number">43</span></span><br><span class="line"><span class="keyword">finally</span>语句块</span><br></pre></td></tr></table></figure>

<p>解析：举一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(beforeFinally());</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">beforeFinally</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            a = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            a = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="red">当程序执行到try{}语句中的return方法时，它会干这么一件事，将要返回的结果存储到一个临时栈中，然后程序不会立即返回，而是去执行finally{}中的程序</font>， 在执行<code>a = 2</code>时，程序仅仅是覆盖了a的值，但不会去更新临时栈中的那个要返回的值 。执行完之后，就会通知主程序“finally的程序执行完毕，可以请求返回了”，这时，就会将临时栈中的值取出来返回。这下应该清楚了，要返回的值是保存至临时栈中的。</p>
<p>12.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">float</span> f= <span class="number">1.0f</span>;</span><br><span class="line">  <span class="keyword">int</span> m= <span class="number">12</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> n= <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    Test t= <span class="keyword">new</span> Test();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下哪些使用是正确的( D )</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">A</span> <span class="string">t.f = 1.0</span></span><br><span class="line"><span class="attr">B</span> <span class="string">this.n</span></span><br><span class="line"><span class="attr">C</span> <span class="string">Test.m</span></span><br><span class="line"><span class="attr">D</span> <span class="string">Test.n</span></span><br></pre></td></tr></table></figure>

<p>解析：A项，编译不成功，因为float浮点类型默认是double，所以<code>float f = 1.0f</code>。选项没有加 <code>&#39;f&#39;</code>，<font color="red">由高精度(double)向低精度(float)转换会丢失精度</font>，所以报错。</p>
<p>B项，this使用时，在方法内部使局部变量等值于实例变量而使用的一个关键字，此处的n是静态变量而非实例变量 所以this的调用会出错（试想一下，static本来是全类中可以使用的，是全局的，你非得this去调用，这不是区分局部变量和实例变量的分水线吗？但是此处是全局的，不需要区分）</p>
<p>C项，m是实例变量，什么是实例变量：就是需要new 一个对象出来才能使用的，这里直接用类名就调用了，jvm怎么知道m是谁？</p>
<p>13.下列关于Java并发的说法中正确的是（ B ）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CopyOnWriteArrayList适用于写多读少的并发场景</span><br><span class="line"></span><br><span class="line">ReadWriteLock适用于读多写少的并发场景</span><br><span class="line"></span><br><span class="line">ConcurrentHashMap的写操作不需要加锁，读操作需要加锁</span><br><span class="line"></span><br><span class="line">只要在定义<span class="keyword">int</span>类型的成员变量i的时候加上<span class="keyword">volatile</span>关键字，那么多线程并发执行i++这样的操作的时候就是线程安全的了</span><br></pre></td></tr></table></figure>

<p>解析：A，CopyOnWriteArrayList适用于<strong>写少读多</strong>的并发场景；B，ReadWriteLock即为读写锁，他要求写与写之间互斥，读与写之间互斥，读与读之间可以并发执行。在读多写少的情况下可以提高效率；C，ConcurrentHashMap是同步的HashMap，读写都加锁；D，volatile只保证多线程操作的可见性，不保证原子性。</p>
<p>14.以下代码的输出结果是？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> B t1 = <span class="keyword">new</span> B();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> B t2 = <span class="keyword">new</span> B();</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        B t = <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析： 1.程序入口main方法要执行首先要加载类B ;</p>
<p>2.<strong>静态域：分为静态变量，静态方法，静态块。这里面涉及到的是静态变量和静态块，当执行到静态域时，按照静态域的顺序加载，并且静态域只在类的第一次加载时执行 ；</strong></p>
<p>3.每次new对象时，会执行一次构造块和构造方法，构造块总是在构造方法前执行(当然，第一次new时，会先执行静态域，静态域&gt;构造块&gt;构造方法) 注意：加载类时并不会调用构造块和构造方法，只有静态域会执行 ；</p>
<p>4.根据前三点，首先加载类B，执行静态域的第一个静态变量，static b1=new B()，输出构造块和构造方法（空）。ps:这里为什么不加载静态方法呢？因为执行了静态变量的初始化，意味着已经加载了B的静态域的一部分，这时候不能再加载另一个静态域了，否则属于重复加载 了（静态域必须当成一个整体来看待。否则加载会错乱） 于是，依次static b2 =new B，输出构造块，再执行静态块，完成对整个静态域的加载，再执行main方法，new b，输出构造块。</p>
<p>15.JVM规范</p>
<p><img src="/2020/04/25/23/31/java%E9%9D%A2%E8%AF%95%E9%A2%98/JVM.png" alt></p>
<p>16.JDBC连接数据库</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Statement sta=con.createStatement();</span><br><span class="line">ResultSet rst=sta.executeQuery(“select * from book”);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PreparedStatement pst=con.prepareStatement(“select * from book”);</span><br><span class="line">ResultSet rst=pst.executeQuery();</span><br></pre></td></tr></table></figure>

<p>解析：<strong>PreparedStatement</strong>有预编译的过程，已经绑定sql，之后无论执行多少遍，都不会再去进行编译，执行速度要比statement 快，<strong>安全性高，可以防止SQL注入</strong>。而 statement 不同，如果执行多遍，则相应的就要编译多少遍sql。</p>
<p>17.如下语句通过算术运算和逻辑运算之后i和 j的结果是（ D ）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>((++i&gt;<span class="number">0</span>)||(++j&gt;<span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打印出i和j的值。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">A	i=<span class="number">0</span>;j=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">B	i=<span class="number">1</span>;j=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">C	i=<span class="number">0</span>;j=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">D	i=<span class="number">1</span>;j=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>解析：<strong>&amp;&amp; 和 || 为短路与和短路或</strong>。&amp;&amp; 若前面的表达式为false,整个逻辑表达式为false,所以后面的表达式无论true和false都无法影响整个表达式的逻辑结果，所以为了提高代码执行速率，这里后面的表达式就不会执行。同理， || 若前面表达式为true,则后面的表达式无需计算。<strong>&amp; 和 | 为不短路与不短路或</strong>。无论什么情况，前面的和后面的都要执行。</p>
<p>18.关于JVM的垃圾回收机制：</p>
<ul>
<li><strong>垃圾回收在jvm中优先级相当相当低。</strong></li>
</ul>
<ul>
<li><p><strong>垃圾收集器（GC）程序开发者只能推荐JVM进行回收，但何时回收，回收哪些，程序员不能控制。</strong></p>
</li>
<li><p><strong>垃圾回收机制只是回收不再使用的JVM内存，如果程序有严重BUG，照样内存溢出。</strong></p>
</li>
<li><p><strong>进入DEAD的线程，它还可以恢复，GC不会回收。</strong></p>
</li>
</ul>
<p>19.以下JAVA程序代码的输出是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="number">17</span>^<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析：<font color="red">“^”是位异运算符号</font>。</p>
<p>运算规则是：两个数转为二进制，然后从高位开始比较，如果相同则为0，不相同则为1。</p>
<p>17：<code>0001 0001</code>  5：<code>0000 0101</code>结果：<code>0001 0100</code> 转10进制：20。</p>
<p>20.假设 a 是一个由线程 1 和线程 2 共享的初始值为 0 的全局变量，则线程 1 和线程 2 同时执行下面的代码，最终 a 的结果不可能是（ D ）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isOdd = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>（i%<span class="number">2</span>==<span class="number">1</span>）</span><br><span class="line">        isOdd = <span class="keyword">true</span>；</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">        isOdd = <span class="keyword">false</span>；</span><br><span class="line">	a+=i*(isOdd?<span class="number">1</span>:-<span class="number">1</span>)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">A	<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">B	<span class="number">-2</span></span><br><span class="line"></span><br><span class="line">C	<span class="number">0</span></span><br><span class="line"></span><br><span class="line">D	<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>解析：每个线程对a 均做了两次读写操作，分别是 “ +1 ” 和 “ -2 ”。</p>
<p>而题目问了是最终a 的结果，所以 a 的结果取决于各自线程对 a 的先后读写的顺序。</p>
<p>结论：a的可能取值为-1、0、-2。<img src="/2020/04/25/23/31/java%E9%9D%A2%E8%AF%95%E9%A2%98/Thread.png" alt></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>使用信念-愿望-意图模型在室内社交机器人中增加主动性的案例研究</title>
    <url>/2019/12/24/23/26/%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%BF%B5-%E6%84%BF%E6%9C%9B-%E6%84%8F%E5%9B%BE%E6%A8%A1%E5%9E%8B%E5%9C%A8%E5%AE%A4%E5%86%85%E7%A4%BE%E4%BA%A4%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%BB%E5%8A%A8%E6%80%A7%E7%9A%84%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<p>&emsp;&emsp;<strong>摘要</strong>：事实证明，机器人和机器人技术的兴起在不同方面都对人类有益。机器人技术从一个简单的按钮进化而来，多年来得到了大规模的发展。因此，它已经成为人类生活的一个组成部分，因为机器人被广泛应用，从室内使用到行星际任务。<a id="more"></a>最近，在商业室内空间使用社交机器人提供帮助或与人进行社交互动已经相当流行。因此，考虑到越来越多的社交机器人的使用，人们已经实施了许多工作来开发机器人，使他们能够像人类一样行动。这一发展背后的理念是，需要机器人在没有被要求的情况下提供服务。社交机器人应该更像人类那样思考，通过分析他们所处的环境，提出可能的、适合的行动建议。信念-愿望-意图是开发基于人类如何基于环境中获得的信息而行动的理性代理的最流行的模型之一。因此，这项工作定义于一个基础框架，将BDI集成到一个社交机器人中以添加主动行为的“像人一样”功能。该工作通过在由机器人操作系统(ROS)操纵的室内社交机器人Waldo中使用PROFETA BDI框架开发基于视觉的主动行动，从而验证了所提议的体系结构。</p>
<p>&emsp;&emsp;关键字：社交机器人；积极主动性；信念-愿望-意图模型(BDI)；机器人操纵系统(ROS)</p>
<h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>&emsp;&emsp;在这部分里，我们首先讨论社交机器人和主动性的概念以及在我们日常生活中的意义。然后，我们将这些概念融合在一起，从而通过使用信念-愿望-意图(BDI)模型在由机器人操作系统(ROS)驱动的室内社交机器人中增加主动性，从而形成创造附加价值的主要目标。</p>
<h6 id="社交机器人"><a href="#社交机器人" class="headerlink" title="社交机器人"></a>社交机器人</h6><p>&emsp;&emsp;机器人的概念给人一种类似人类的机器的印象，主要是为他们的创造者服务的。机器人为人类服务的方式有着更广阔的范围。机器人可以用于日常的家务劳动和太空探索任务，这取决于他们是如何被制造的，以及他们身上安装了多少智能设备。随着时间的推移，一定机器人的方式从“一个为工厂组装产品而建造的机械人”转变为“一个人类能与之社交互动的实体”。社交机器人的诞生受到了生物学的启发，社交机器人最初是被用于学习蜂群或昆虫的行为[1]。后来，社交机器人被用于和人类互动。</p>
<p>&emsp;&emsp;根据社交科学家Kate Darling称，”社交机器人是 一种身体上的体现，是一种在情感层面上与人类交流和互动的自主智能体“[2]。在这篇文章中区分社交机器人和无生命的计算机以及工业或服务机器人是很重要的（不是为了激发人类的情感和模仿社交线索设计的）。社交机器人也遵循社交行为模式，具有各种“心里状态”，并适应他们通过互动学习的内容。通常，社交机器人是以类人或类动物的形式与人类建立情感联系的，因为社交机器人的形式和形状非常重要。社会互动被期望类似于视觉和触觉感知的言语交流。根据这些交互作用，社交机器人可以分为以下几类[3]。</p>
<ol>
<li>社会唤起。这些机器人依靠人类的动作来产生一组特定的感受[4]。</li>
<li>社会地位。这些机器人对来自它们所处的社会环境的感知做出反应。机器人能够区分环境中的社会主体和对象[1]。</li>
<li>善于交际。这些机器人具有社会认知的模型，并且为了一些社会目标主动与人类接触[4]。</li>
<li>社交智慧。这些机器人尝试头基于认知和社交能力模型来复制人类的社会职能[5]。</li>
</ol>
<p>&emsp;&emsp;对老年人的个人护理的需求的增长和技术的进步使得社交机器人可以广泛地用于老年人护理。社交机器人形式的辅助技术帮助老年人在家中独立生活。社交机器人可以提供广泛的互动服务，如远程护理和机器人辅助治疗。这种机器人也可以用于老年人的心理和认知障碍的病人护理[6]。一些社交机器人可以监测运动、血压、呼吸或心脏问题，并在出现任何危险或风险时向相关人员发出警告[7]。社交机器人也已广泛用于与儿童的互动。一个名为Arash的社交同伴机器人被建造来为儿科医院提供治疗干预[8]。社交机器人也被用来帮助患有癌症的儿童[8]。最近有报道称，社交机器人被用于教育和照顾发育障碍儿童[9]。主动机器人已被用作家教和同伴学习者，以提供教育[10]。因此，社交机器人目前被用于医院、家庭、购物中心和会议中心，与人们互动，以欢迎、交谈或照顾人们[11]。社交机器人在与人类互动、协助、服务和探索方面都面临挑战，它们以不同的方式帮助人类。对于这些应用程序，主动行为对于社交机器人是必要的。</p>
<h6 id="主动性"><a href="#主动性" class="headerlink" title="主动性"></a>主动性</h6><p>&emsp;&emsp;社交机器人是自主的机器人，它按照一套为人类定义的社交规则与人类交流[12]。这些机器人使用三种不同的控制体系结构来决定对环境做出反应所需的动作——协商、反应和混合。在协商式控制中，机器人在决策时具有深思熟虑的能力，因为除了当前的传感器输入和刺激之外，机器人还具有与过去或未来状态相关的能力，可以采取相关的行动。反应控制类似于“刺激-反应”控制机制，在这种机制中，机器人通过紧密耦合感官输入和效应器输出，对不断变化的非结构化环境做出快速反应。在混合控制中，一个组件处理计划动作，而另一个组件处理通常不需要学习能力的即时反应。在混合架构中，两个不同的机制之间的耦合可能很困难，因为两个控制机制必须连续地相互通信。</p>
<p>&emsp;&emsp;基于这些控制架构，一个社交机器人可以通过两种方式与人类互动。机器人可以被要求为人类做事，在这种情况下，机器人是被动的。相反，机器人能够在不被要求的情况下自动帮助用户，在这些案情况下，机器人是主动的。社交机器人中的主动性概念可能是有用的实用程序，因为社交机器人主要是为了以更人性化的方式与人类互动。附录A中包含了一个示例（从[13]中采用）来理解社交机器人的反应性行为与主动性行为之间的区别。</p>
<h6 id="机器人操纵系统-ROS"><a href="#机器人操纵系统-ROS" class="headerlink" title="机器人操纵系统(ROS)"></a>机器人操纵系统(ROS)</h6><p>&emsp;&emsp;ROS是基于C ++的开源软件，它是用于机器人软件开发的通用软件框架，具有操作系统功能[14]。这些功能包括硬件抽象，底层设备控制，常用功能的实现，进程之间的消息传递以及程序包管理。它基于图形架构，其中每个节点从传感器，执行器接收/处理有关其状态的多个消息。 该操作系统在Linux（Ubuntu）上运行，并且可以在Windows中使用，但功能有所减少。 ROS创建了一个生态系统，其中称为节点的不同组件之间使用消息通信系统互连。 ROS是驱动商用室内机器人的关键驱动组件之一。</p>
<h6 id="信念-愿望-意图模型-BDI"><a href="#信念-愿望-意图模型-BDI" class="headerlink" title="信念-愿望-意图模型(BDI)"></a>信念-愿望-意图模型(BDI)</h6><p>&emsp;&emsp;BDI是通过智能编程代理构建多代理系统的主要方法之一。 该模型受人类推理的启发，并基于三个实体，即信念，愿望和意图[15]。 它提供了一种机制，用于将选择行动的活动与当前活动计划的执行分开。 系统中的代理是根据这些实体定义的。 该模型还考虑了资源限制，以便在代理进行推理后产生意图。 BDI模型希望代理在动态环境中行动，以便代理的推理应考虑环境变化以采取行动。BDI模型的三个实体解释如下：</p>
<ol>
<li>信念。 信念是代表代理人信息状态的实体。 信念反映了机器人的知识。 信念存储在信念集中。</li>
<li>愿望。 愿望是代表代理人的激励状态或代理人想要实现的目标，目的或情况的实体。 愿望是代理商想要完成的。</li>
<li>意图。 意图是代表代理的审议状态的实体。 计划是代理为实现目标而采取的一系列动作。</li>
</ol>
<p>&emsp;&emsp;对于社交机器人，传感器输出会构建置信集，以根据不同参数的不同值来表示机器人周围的环境。 特定的信念集描述了机器人在特定时间所在的特定情况。 根据位置，为机器人定义一个目标，该目标可以称为“期望”。 BDI解释器或引擎根据情况从计划库中选择特定的行动（意图），该计划是意图的集合。</p>
<h6 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h6><p>&emsp;&emsp;社交机器人已经成为我们生活中不可或缺的部分。从医院到像家一样的会议商店，都广泛使用社交机器人以一种或另一种方式与人类互动。现在，无论何时何地无法在特定任务中出现人员，社交机器人都可以替代人员。因此，希望机器人能够像人类一样发挥更多作用，而主动性可以成为此类机器人中的功能，它将使这种功能成为可能。许多研究试图发展机器人的主动行为。但是，当谈到由ROS提供动力的商业室内社交机器人时，还没有明确定义的系统架构和实现。考虑到此类机器人在商用室内环境中的影响，本研究试图探索增强此类商用室内社交机器人主动性的可能性。这项工作定义了一种清晰的方法，通过将基于人类推理的BDI框架集成到系统体系结构中，将社交机器人的不同活动实现为主动行为。这项工作通过在ROS操作的室内社交机器人Waldo中开发由PROFETA（BDI）框架实现的基于视觉的主动行为来验证实施。该研究的具体贡献如下：</p>
<ol>
<li>一个经过验证的模块化系统架构，具有模块化、灵活性和合理的工作分布等特点，有利于不同的逻辑块与ROS所控制的机器人集成，用于主动行为。</li>
<li>为在日常生活应用的罗斯控制机器人中开发类人行为奠定了基础。</li>
</ol>
<p>&emsp;&emsp;论文的其余部分组织如下:第2节讨论相关工作，第3节解释案例研究的建立以及系统概述。第4节讨论结果，第5节总结论文。</p>
<h5 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h5><p>&emsp;&emsp;在这一部分中，我们将描述不同BDI模型的背景，以及为集成机器人中的行为模型而构建的不同框架。此外，我们提出了不同的工作，研究人员试图将这些模型纳入机器人的各种日常生活应用。</p>
<h6 id="BDI模型"><a href="#BDI模型" class="headerlink" title="BDI模型"></a>BDI模型</h6><p>&emsp;&emsp;当软件代理认知模型的设计开始发挥作用时，BDI模型是最流行的体系结构选择之一。BDI模型提供了信息态度、动机态度和协商承诺的显式和说明性表示。Myers等人将BDI模型分为两大类:B-DOING和Delegative模型。在B-DOING模型中，动机态度是高度适应的，而愿望与代理人的愿望相对应。此外，义务与其他代理人的责任相对应，规范与代理人在环境中所起作用的公约相对应。为代理创建的目标需要一致且可实现的[17]。根据目标的定义，计划执行的意图。在Delegative模型中，目标被定义为候选目标和采用目标[18]。候选目标是那些内部不一致的目标，而采用的目标是BDI模型中一致和连贯的目标。该模型甚至可以将用户指定的指导和来自用户的首选项合并为建议的形式。B-DOING框架缺乏主动性帮助目标类型之间的区别，而Delegative BDI框架缺乏动机态度类型之间的区别。</p>
<h6 id="BDI框架"><a href="#BDI框架" class="headerlink" title="BDI框架"></a>BDI框架</h6><p>&emsp;&emsp;Russel等人开发了代理工厂框架，作为各种工具、平台和语言的开源集合，这些工具、平台和语言最终促进了多代理系统的开发和开发。Winikoff [20]构建了一个高度可移植、健壮和跨平台的环境，称为JACK，用于构建、运行和集成商用级的多代理系统。在称为JADE[21]的BDI框架中，代理平台可以分布在不同的独立机器之间，可以进行远程控制。甚至可以在运行时通过在实现期间将代理从一台机器移动到另一台机器来更改配置。Braubach 和 Pokahr [22]开发了一个基于XML和Java的JADEX框架，该框架遵循BDI模型，从工程角度简化了智能代理系统的构建。JASON是作为[24]AgentSpeak [23]的扩展而开发的超灵活平台，实现了该语言的语义，并为开发具有许多可定制特性的多代理系统提供了一个良好的平台。不同行为模型平台的比较如表1所示。</p>
<p>​                                                        表1 不同信念-愿望-意图 (BDI)平台的比较。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">主要领域</th>
<th align="center">资源开放</th>
<th align="center">学习能力</th>
<th align="center">程序语言</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AgentFactory</td>
<td align="center">基于通用代理</td>
<td align="center">是</td>
<td align="center">平均</td>
<td align="center">Java,AgentSpeak</td>
</tr>
<tr>
<td align="center">JACK</td>
<td align="center">动态复杂环境</td>
<td align="center">否</td>
<td align="center">容易</td>
<td align="center">Java</td>
</tr>
<tr>
<td align="center">JADE</td>
<td align="center">由自治实体组成的分布式应用程序</td>
<td align="center">是</td>
<td align="center">容易</td>
<td align="center">Java</td>
</tr>
<tr>
<td align="center">JADEX</td>
<td align="center">由自治BDI实体组成的分布式应用程序</td>
<td align="center">是</td>
<td align="center">容易</td>
<td align="center">Java</td>
</tr>
<tr>
<td align="center">BDI4JADE</td>
<td align="center">企业应用程序</td>
<td align="center">是</td>
<td align="center">平均</td>
<td align="center">Java</td>
</tr>
<tr>
<td align="center">JASON</td>
<td align="center">由自治BDI实体组成的分布式应用程序</td>
<td align="center">是</td>
<td align="center">容易</td>
<td align="center">Java</td>
</tr>
<tr>
<td align="center">PROFETA</td>
<td align="center">由自主BDI实体和AI应用组成的分布式应用</td>
<td align="center">是</td>
<td align="center">容易</td>
<td align="center">Python</td>
</tr>
<tr>
<td align="center">SPYSE</td>
<td align="center">分布式人工智能应用</td>
<td align="center">是</td>
<td align="center">平均</td>
<td align="center">Python</td>
</tr>
<tr>
<td align="center">SPADE</td>
<td align="center">分布式多代理</td>
<td align="center">否</td>
<td align="center">平均</td>
<td align="center">Python</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;ROS支持C++和Python编程语言，用于在其生态系统中的不同分布式节点之间进行通信。由于Python中有各种BDI框架，本研究考虑了pythonic框架。</p>
<h6 id="BDI模型在机器人中的应用"><a href="#BDI模型在机器人中的应用" class="headerlink" title="BDI模型在机器人中的应用"></a>BDI模型在机器人中的应用</h6><p>&emsp;&emsp;该行为模型适用于研究机器人与人类的自然互动，以显示出主动行为。可以想象，机器人的前瞻性行为可以增加人机交互和使用机器人的实用价值。因此，与机器人主动行为有关的工作是采用混合启动方法启动的。 Finzi和Orlandini [25]为搜索和营救行动中使用的机器人开发了一种基于计划者混合启动方法的架构。该研究具有用于执行任务的基于模型的执行监视和反应性计划程序。亚当斯等人[26]提出了一种基于效果的人机交互的混合启动交互方法。机器人会主动检测人类的情绪变化，例如检测睡意和注意力不集中。由Acosta等人开发的机器人[27]通过监视活动并将任务定义为时间表来显示一些主动行为。 Satake等人[28]提出了一种行为模型来发起与在街上行走的行人的对话。 Shi等人的工作研究了开始与人交谈或互动的适当时间。 [29]。此外，Garrel等人 [30]提出了一种主动模型的行为模型，该模型试图说服人们以不同的行为和情感发起对话。由Araiza-Illan等进行的研究[31]提出使用BDI模型来提高机器人的逼真度和类人仿真水平。实现了一个自动测试台，用于模拟人形机器人与机器人操作系统和凉亭中的人员之间的协作任务组装。 Gottifredi等人开发了一种基于BDI架构的足球比赛机器人。 [32]允许在需要时基于高层推理和反应性来规范声明性目标驱动行为。 Duffy等人的工作[33]开发了一种以自我为中心的机器人控制策略的多层BDI架构，以使机器人能够进行明确的社交行为。 Pereira等人[34]提出了BDI体系结构的扩展，以情感BDI体系结构的形式支持人工情感。</p>
<p>&emsp;&emsp;鉴于社交机器人主动性的现状，本研究试图扩展此类机器人的能力，将基于视觉的活动纳入社交机器人中。集成基于一个模块化架构，其他逻辑块可以很容易地集成到该架构上，以类似于人类思维的方式实现更高级的主动行为。</p>
<h5 id="案例研究设置"><a href="#案例研究设置" class="headerlink" title="案例研究设置"></a>案例研究设置</h5><p>&emsp;&emsp;在本节中，我们将解释为开发社交机器人Waldo中的主动行为而创建的用例场景。此外，我们定义了一个基于现有技术的系统框架，将OpenCV和BDI推理的模块模块与ROS生态系统集成在一起，每一步的详细说明如下。</p>
<h6 id="用例场景"><a href="#用例场景" class="headerlink" title="用例场景"></a>用例场景</h6><p>&emsp;&emsp;在本研究中，我们考虑在社交机器人中加入一种主动行为的基于视觉图像的活动。室内机器人Waldo的眼睛里安装了摄像头，从环境中收集图像。这些图像反馈有助于建立一种关于情况的信念。使用OpenCV中的人员检测模块处理摄像机提要。这个模块为机器人建立了一个关于环境中是否有人存在的信念。如果OpenCV模块检测到一个人，Waldo将设置一个目标，即在没有来自该人的任何显式命令的情况下问候该人。在这个实验中，机器人可以执行两个精确的动作。在检测到人之后，使用BDI框架，机器人用一句话问候被检测到的人。在一段固定的时间内，机器人不断地检测到这个人，它就会改变自己的信念，通过说出不同的句子来为这个人提供额外的帮助。对于这项工作，Waldo可以执行的操作仅限于语音，但是高级服务可以轻松地替换这些操作。这个规定是在实验中提出的，目的是为了展示信念是如何随着环境的变化而改变的，从而使机器人所采取的行动具有相关性和互动性。</p>
<h6 id="社交室内机器人Waldo"><a href="#社交室内机器人Waldo" class="headerlink" title="社交室内机器人Waldo"></a>社交室内机器人Waldo</h6><p>&emsp;&emsp;本研究考虑的机器人是Waldo，它是浸入式机器人[35]制造的多服务机器人。Waldo是一款具有先进视觉能力的远程呈现服务机器人。机器人有一个Arduino卡用于基本的控制功能，还有一个安装了ROS的Linux卡作为操作系统，用于更高级和复杂的功能。Waldo的可调高度为130至170厘米。这个机器人可以自主操作激光雷达、声纳、麦克风和照相机。Waldo是一个人形的室内社交机器人，用于欢迎、交谈、理解和与人交流。Waldo的移动可以通过鼠标、键盘、操纵杆、平板电脑、智能手机、平板电脑或任何其他需要的外设进行远程控制。Waldo如图1所示。<img src="/2019/12/24/23/26/%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%BF%B5-%E6%84%BF%E6%9C%9B-%E6%84%8F%E5%9B%BE%E6%A8%A1%E5%9E%8B%E5%9C%A8%E5%AE%A4%E5%86%85%E7%A4%BE%E4%BA%A4%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%BB%E5%8A%A8%E6%80%A7%E7%9A%84%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/1.png" alt="图1 Waldo"></p>
<h6 id="系统概述"><a href="#系统概述" class="headerlink" title="系统概述"></a>系统概述</h6><p>&emsp;&emsp;本研究的主要目的是利用现有的技术，开发一个灵活和模块化的框架，可以方便地将不同的模块集成到框架中，<br>这最终有助于ROS控制的社交机器人主动行为的发展。在室内模型中实现环境行为模型的整体系统概况如图2所示。安装在室内机器人Waldo上的不同传感器收集环境信息。摄像头、激光雷达和Kinect传感器帮助收集特定时刻的环境信息。信息被中继到Waldo PC，它通过无线连接连接到监控PC。由于Waldo PC的功能有限，计算密集型逻辑模块可以在功能更强大的监视PC上运行。逻辑模型负责从机器人传感器收集的环境数据中获取各种知识。基于这个知识库，BDI框架为任何给定的时刻建立信念和目标。框架还从预定义的计划列表中选择一组操作来实现目标。这些动作通过无线连接转发到Waldo PC，并指导Waldo中的不同执行器执行广泛的动作。ROS中的内部机制管理节点与Waldo PC之间的通信。安装了Linux和ROS的Waldo PC可以安装几个逻辑模块，或者监视PC以建立一个或多个关于环境的信念。逻辑层中的模块可以是BDI框架、用于视觉处理的OpenCV，以及用于建立关于环境的重要信念的其他智能模块。BDI框架响应已建立的信念，并为任何时刻设置目标。框架中的引擎从预定义的库中选择一个行动计划来实现目标。计划执行转发给Waldo PC，它在机器人中产生实际的动作来响应环境。可以使用通过无线网络连接到Waldo PC的监视PC来监视流操作。<img src="/2019/12/24/23/26/%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%BF%B5-%E6%84%BF%E6%9C%9B-%E6%84%8F%E5%9B%BE%E6%A8%A1%E5%9E%8B%E5%9C%A8%E5%AE%A4%E5%86%85%E7%A4%BE%E4%BA%A4%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%BB%E5%8A%A8%E6%80%A7%E7%9A%84%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/2.jpg" alt="图2 系统概述"></p>
<h6 id="BDI建模"><a href="#BDI建模" class="headerlink" title="BDI建模"></a>BDI建模</h6><p>&emsp;&emsp;问题的BDI建模应该能够有效地回答以下问题。</p>
<ul>
<li>当采取行动?只要机器人发现房间里有人，它就会工作。因此，一个有效的人的检测机制应该集成到机器人。必须采用有效的块来触发动作。</li>
<li>采取什么行动？机器人的动作很大程度上取决于对人的检测。这个动作可以是一个简单的问候语传递给某人，也可以是传递给提供帮助或根本不采取任何行动的人。</li>
<li>如何执行这些操作?基于对环境的一系列信念，机器人可以决定采取行动。在任何检测到人的情况下，机器人会利用它的文本到语音节点说出句子来问候或帮助人们。对于不被发现的人，机器人可以故意保持空闲或进入睡眠模式。</li>
</ul>
<p>&emsp;&emsp;机器人眼睛上安装的摄像头收集周围的知识。在实验中，只使用了摄像机的输入。来自OpenCV的人员检测块用于显式地定义系统设计的信念。此外，目标和行动被相应地定义，以实现主动行为的用例。机器人可能采取的行动仅限于语言。根据案例的BDI模型，一组信念、愿望和意图研究定义如下:</p>
<p><strong>Belief</strong>: personDetected(“Yes”), personDetected(“No”) and personDetected(“Next”)</p>
<p><strong>Desire</strong>: DoNothing(), GreetPeople() and OfferHelp()</p>
<p><strong>Intentions</strong>: stayIdle(), speak()</p>
<hr>
<p>PROFETA框架可以通过以下步骤来实现行为建模:</p>
<p>算法1 PROFETA框架实现。</p>
<p>1:导入必要的PROFETA库</p>
<p>2:在脚本中将信念和目标定义为类</p>
<p>3:通过创建类并覆盖execute()方法来定义用户操作</p>
<p>4:启动PROFETA引擎</p>
<p>5:使用声明性语法定义规则</p>
<p>6 .发动引擎</p>
<hr>
<p>&emsp;&emsp;此外，PROFETA框架还促进了传感器类的定义，传感器类本身可以根据环境添加或删除一组信念。这可以在PROFETA中通过声明一个子类Sensor、重写sense（）方法并通知PROFETA引擎程序中添加了一个新的传感器来完成。PROFETA使用陈述性语言来表达代理人的行为。代理行为的声明性语法描述如下：“Event/”Condition“ &gt;&gt; ”setofActions”</p>
<p>&emsp;&emsp;在这种声明性语法中，事件可以是信念断言或撤回、目标完成或请求，甚至是目标失败中的任何一个。语法中的条件是指一组特定的知识库，而操作可以是目标完成请求、用户定义的操作集或添加或删除信仰。这种语法可以举例说明：</p>
<p>+objectAt(“A”, “B”)/objectGot(“no”) » [moveTo(“A”,“B”), pickObject()]</p>
<h6 id="使用OpenCV进行人身检测"><a href="#使用OpenCV进行人身检测" class="headerlink" title="使用OpenCV进行人身检测"></a>使用OpenCV进行人身检测</h6><p>&emsp;&emsp;对于人的检测，开源计算机视觉库（OpenCV）是一个免费提供的用于计算机视觉和机器学习的开源库。OpenCV中的库和算法直接用于基于HOG特征直方图和支持向量机分类器的人体检测实验。OpenCV算法的性能改进超出了本文的研究范围。ROS有自己的图像格式，用于通过订阅和发布在节点之间进行通信。此图像格式必须转换为OpenCV格式才能使用OpenCV库进行人员检测。CvBridge是ROS中的一个库，它促进了ROS图像到OpenCV图像格式的转换，反之亦然。CvBridge接口如图3所示。<img src="/2019/12/24/23/26/%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%BF%B5-%E6%84%BF%E6%9C%9B-%E6%84%8F%E5%9B%BE%E6%A8%A1%E5%9E%8B%E5%9C%A8%E5%AE%A4%E5%86%85%E7%A4%BE%E4%BA%A4%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%BB%E5%8A%A8%E6%80%A7%E7%9A%84%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/3.jpg" alt="图3 CvBridge 接口"></p>
<h6 id="实验装置"><a href="#实验装置" class="headerlink" title="实验装置"></a>实验装置</h6><p>&emsp;&emsp;测试用例在Waldo中实现，工作分布在两台PC上。工作站PC在Intel i5-5300U处理器上安装了Ubuntu 16.04，而Waldo PC在Intel(R) Atom(TM)处理器上安装了相同的操作系统。Waldo的主动行为在PROFETA的BDI框架中得到了很好的实现。</p>
<h5 id="结果与讨论"><a href="#结果与讨论" class="headerlink" title="结果与讨论"></a>结果与讨论</h5><p>&emsp;&emsp;在本节中，我们将验证所提出的系统设计，以将各种逻辑模块(如BDI模型和OpenCV)集成到ROS中，实现主动行为。使用定性方法验证了所提出框架的功能，并研究了模块化、灵活性和合理的工作分配等几个特性。此外,我们详细解释了相关的发现，并对逻辑OpenCV模块的结果进行了定量分析。</p>
<h6 id="系统架构中的工作分配"><a href="#系统架构中的工作分配" class="headerlink" title="系统架构中的工作分配"></a>系统架构中的工作分配</h6><p>&emsp;&emsp;该框架的一个重要特点是合理分配机器人主动行为开发所需的工作。本研究使用PROFETA的BDI框架的一个覆盖层来实现ROS中的测试用例。OpenCV库中的一个模块进行图像处理。该系统设计将操作分配到两台PC上，即安装在机器人和工作站PC上的Waldo PC。测试实验使用了ROS的分布式工作架构，将Waldo PC从繁重的图像处理中解脱出来。人员检测和实用推理模块(BDI框架)安装在一个功能相对强大的工作站PC上。在Waldo PC中处理实际操作和不同ROS节点的管理。这些操作不是计算密集型的。因此，所提出的体系结构在开发主动性行为时支持合理的工作分配。因此，更高级的活动可以被认为是一个扩展，因为更多的计算密集型模块可以很容易地集成到机器人中，这要感谢它的架构。更强大的机器可以承担工作站PC的角色，而Waldo PC可以承担信息收集和效应器的轻角色。此外，该框架允许我们添加额外的计算设备，以考虑各种主动行为所需的不同工作负载。这些功能也使所提议的框架具有灵活性。</p>
<h6 id="用测试用例验证提出的系统设计"><a href="#用测试用例验证提出的系统设计" class="headerlink" title="用测试用例验证提出的系统设计"></a>用测试用例验证提出的系统设计</h6><p>&emsp;&emsp;该系统设计的验证主要研究了在Waldo的主动性行为展示过程中是否实现了灵活性、模块化和合理的工作分配。为了验证所提出的系统设计，我们在ROS生态系统内外创建了几个分布式节点。每个ROS节点分别用于摄像机馈送、人员检测块和语音块。不同的ROS节点通过主题消息相互通信。Roscore管理节点之间的通信。根据需要，可以创建和删除节点来添加或删除功能。可以在提议的框架内的任何计算设备中创建节点，从而提供灵活性和模块化。最初，摄像机节点发布Waldo眼睛收集的图像提要。转换器节点通过CvBridge接口订阅摄像机节点的主题消息，并将ROS图像转换为OpenCV图像。然后节点发布转换后的图像。在工作站PC中有一个名为person detector的节点，它订阅转换后的图像消息。该节点执行OpenCV库的person检测模块。在工作站PC中有一个名为BDI engine的附加节点，它订阅由person检测器发布的关于人员检测的消息。BDI引擎执行所有必要的行为建模，以发布最终由机器人完成的动作。还有另一个节点listener订阅BDI引擎节点并发布机器人中执行器的消息以执行操作。订阅侦听器的语音节点使机器人说出句子以达到目的。在广泛分布的ROS生态系统中，不同节点之间的整个交互作用如图4所示。从图中可以看出，主动行为所需的不同工作负载分布在Waldo PC和Workstation PC上。这种合理的工作分配是建议的框架的优点之一，可以根据需求轻松地添加或删除计算设备。此外，在建议的框架中，可以创建额外的逻辑块/模块作为ROS生态系统中的新节点，以开发社交机器人的额外功能。在我们的研究中，我们创建了一个节点，用于在人员检测期间机器人头部的移动，以演示所提出的框架中的模块化。新创建的节点与person检测器节点通信以创建任何移动。<img src="/2019/12/24/23/26/%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%BF%B5-%E6%84%BF%E6%9C%9B-%E6%84%8F%E5%9B%BE%E6%A8%A1%E5%9E%8B%E5%9C%A8%E5%AE%A4%E5%86%85%E7%A4%BE%E4%BA%A4%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%BB%E5%8A%A8%E6%80%A7%E7%9A%84%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/4.jpg" alt="图4 机器人操作系统(ROS)生态系统中不同节点之间的交互作用"></p>
<h6 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h6><p>&emsp;&emsp;为了进行性能分析和评估，Waldo保持在走廊的固定位置。 装有相机的机器人眼睛的高度约为162厘米。 重复进行测试，其中自然光和人造光均会影响照明条件。</p>
<p>&emsp;&emsp;图5和图6分别表示未检测到人员和检测到人员的情况下BDI动作和由安装在机器人中的摄像机收集的图像馈送的执行情况。当在图像供稿中未检测到人时，BDI引擎会建立对环境的信念，并建立不向人打招呼的目标。因此，引擎选择NoTalk的动作来实现该目标，如图5a所示。同样，当检测到人员时，BDI引擎会通过在工作站PC上运行的人员检测模块来启用遇到人员的信念。基于这种信念，引擎必须设定一个目标，要么向人们打招呼，要么向人们提供额外的帮助。为了两者之间的区别，我们添加了跟踪遇到该人多长时间的逻辑操作，如图6a中的计数器所示。基于在图像馈送中检测到的计数器和人员的值，BDI引擎建立了两个不同的信念集，需要两个不同的目标。实现问候对象目标的问候动作在图6a中表示为交谈动作。执行帮助动作以实现在更长的时间内连续检测到人时向他人提供帮助的目的。<img src="/2019/12/24/23/26/%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%BF%B5-%E6%84%BF%E6%9C%9B-%E6%84%8F%E5%9B%BE%E6%A8%A1%E5%9E%8B%E5%9C%A8%E5%AE%A4%E5%86%85%E7%A4%BE%E4%BA%A4%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%BB%E5%8A%A8%E6%80%A7%E7%9A%84%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/5.jpg" alt="图5 案例:未检测到人员(a) BDI执行情况(b) Waldo眼睛采集的图像"><img src="/2019/12/24/23/26/%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%BF%B5-%E6%84%BF%E6%9C%9B-%E6%84%8F%E5%9B%BE%E6%A8%A1%E5%9E%8B%E5%9C%A8%E5%AE%A4%E5%86%85%E7%A4%BE%E4%BA%A4%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%BB%E5%8A%A8%E6%80%A7%E7%9A%84%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/6.jpg" alt="图6 案例：检测到人员（a）执行BDI和（b）Waldo的眼睛收集到的图像供稿。此外，我们在两个不同的场景中考虑了距机器人的不同距离，测试了整个系统的工作情况。 表2和表3给出了性能分析。"></p>
<p>​                                                            表2.验证工作的距离考虑</p>
<table>
<thead>
<tr>
<th align="center">距离</th>
<th align="center"></th>
<th align="center">场景1</th>
<th align="center"></th>
<th align="center"></th>
<th align="center">场景2</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">人与相机</td>
<td align="center">准确</td>
<td align="center">误报</td>
<td align="center">漏报</td>
<td align="center">准确</td>
<td align="center">误报</td>
<td align="center">漏报</td>
</tr>
<tr>
<td align="center">&lt;2 m</td>
<td align="center">253</td>
<td align="center">160</td>
<td align="center">187</td>
<td align="center">175</td>
<td align="center">160</td>
<td align="center">265</td>
</tr>
<tr>
<td align="center">2–10 m</td>
<td align="center">401</td>
<td align="center">87</td>
<td align="center">112</td>
<td align="center">354</td>
<td align="center">114</td>
<td align="center">132</td>
</tr>
</tbody></table>
<p>​                                                            表3.准确性和召回率评估</p>
<table>
<thead>
<tr>
<th align="center">距离</th>
<th align="center"></th>
<th align="center">场景1</th>
<th align="center"></th>
<th align="center"></th>
<th align="center">场景2</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">人与相机</td>
<td align="center">精度</td>
<td align="center">召回</td>
<td align="center">F1 分数</td>
<td align="center">准确</td>
<td align="center">召回</td>
<td align="center">F1 分数</td>
</tr>
<tr>
<td align="center">&lt;2 m</td>
<td align="center">0.612</td>
<td align="center">0.575</td>
<td align="center">0.593</td>
<td align="center">0.52</td>
<td align="center">0.398</td>
<td align="center">0.451</td>
</tr>
<tr>
<td align="center">2–10 m</td>
<td align="center">0.822</td>
<td align="center">0.782</td>
<td align="center">0.801</td>
<td align="center">0.756</td>
<td align="center">0.728</td>
<td align="center">0.742</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;整个系统的性能分析表明，机器人在2-10 m以上的区域表现较差。场景1的准确率和召回率分别为0.822和0.782，场景2的准确率和召回率分别为0.756和0.728。与场景1相比，场景2有更多的光照不一致。测试期间的漏报和准确（如图7和8所示）是由于物体移动引起的照明条件变化引起的。此外，这些负面因素是由几种光源（自然和人工）形成的人的阴影造成的。由于数据集分布不均，我们还针对每种情况计算了F1-Score。对于场景1，在2-10 m的区域中，最佳F1分数为0.801。 F1分数的高值（接近1）表明模块在检测到人时的效率，从而使机器人可以表现出主动的招呼行为并为被检测到的人提供帮助。与精度和召回率的分析相似，场景2的F1得分在&lt;2 m范围内最低，这突出说明了逻辑块在该位置执行的效率不高。此外，我们绘制了实验的精确召回曲线，如图9所示。该曲线还证实了这一发现，并确定了场景1（2-10 m区域）中模块的最佳性能，作为该曲线下的面积。情况是最高的（请参见图9）。模块的性能受多种因素影响，例如人造光，阴影，多种光源以及相机与人之间的距离。通过增强OpenCV逻辑块的性能，可以提高给定测试用例中系统设计的准确性。<img src="/2019/12/24/23/26/%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%BF%B5-%E6%84%BF%E6%9C%9B-%E6%84%8F%E5%9B%BE%E6%A8%A1%E5%9E%8B%E5%9C%A8%E5%AE%A4%E5%86%85%E7%A4%BE%E4%BA%A4%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%BB%E5%8A%A8%E6%80%A7%E7%9A%84%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/7.jpg" alt="图7 漏报"><img src="/2019/12/24/23/26/%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%BF%B5-%E6%84%BF%E6%9C%9B-%E6%84%8F%E5%9B%BE%E6%A8%A1%E5%9E%8B%E5%9C%A8%E5%AE%A4%E5%86%85%E7%A4%BE%E4%BA%A4%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%BB%E5%8A%A8%E6%80%A7%E7%9A%84%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/8.jpg" alt="图8 误报"><img src="/2019/12/24/23/26/%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%BF%B5-%E6%84%BF%E6%9C%9B-%E6%84%8F%E5%9B%BE%E6%A8%A1%E5%9E%8B%E5%9C%A8%E5%AE%A4%E5%86%85%E7%A4%BE%E4%BA%A4%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%BB%E5%8A%A8%E6%80%A7%E7%9A%84%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/9.jpg" alt="图9 精度-召回 曲线"></p>
<h6 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h6><p>&emsp;&emsp;在这项研究中，不考虑没有人的全身的图像帧。由于摄像机放置在一定的高度上，头部的角度运动是有限的，所以摄像机无法覆盖小于一米的距离。因此，机器人前方不到2米的区域是一个盲点。这种盲点在人的检测方面表现不佳。此外，在约10 m的距离之外，人检测模块无法检测到人。至于系统设计，该架构仍然提供模块化和灵活性。整个系统的准确性在很大程度上取决于用于开发机器人主动行为的逻辑块。除了逻辑块的局限性之外，本研究更多地关注了所提出的框架的定性验证，其中研究了模块性、灵活性和合理的工作分布等特征。这项工作主要是在开发一个基本灵活的基础上，利用现有的和自由可用的工具来开发社会机器人中的主动行为。由于没有现成的可比较的体系结构和案例研究，本文不包括比较分析。此外，社交机器人的先进能力目前也未被考虑。这些研究的局限性将在未来得到加强。</p>
<h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>&emsp;&emsp;最近，在商业空间（包括家庭）中，类人和类动物室内社交机器人的兴起，使得这些机器人的“类人行为”行为成为一种更友好的人机交互的必要条件。这种社交机器人的主动性为机器人增加了更多的效用。因此，在本文中，我们提出了一个在室内商业社交机器人中这种主动行为的验证用例，Waldo由行为模型框架PROFETA支持。我们明确地定义了具有灵活性、模块性和合理工作分布的基本系统体系结构，以将BDI框架集成到ROS的分布式生态系统中。在该体系结构中，多个ROS节点可以通过无线通信在多台机器上独立创建。我们演示了如何使用外部模块（如OpenCV库）以即插即用的方式增强室内机器人的能力。我们希望所提出的系统架构奠定了坚实的基础，以开发广泛的主动行为在室内社会机器人的行为和行为像一个人。通过在所提出的体系结构中添加各种逻辑模块，可以实现这种行为。</p>
<p>&emsp;&emsp;通过机器人的基本动作验证了所提出的结构的有效性。目前正在进行初步工作，将人工智能的各个模块集成到所提出的体系结构中，以便在机器人中开发更多的智能动作。Waldo可以执行的操作的扩展也在进行中。未来的工作可以集中在通过使用机器人中多个传感器收集的数据，在人类推理范式BDI中建立更精确的信念。除了相机，激光雷达和Kinect传感器可以更好地代表环境的状态。在机器人的行为方面，进一步的工作可以集中在融合机器人的自主导航来实现基于不同信念的目标设置上。学习机制的加入，不断完善，可以看作是一个必不可少的延伸。</p>
<p><strong>&emsp;&emsp;作者贡献</strong>：U.K.C.促成了项目概念化、文献综述、方法论、工具集成、测试、验证和实验。J.C. 协助项目开发、管理、概念化、方法、验证和监督。两位作者都对论文的撰写、评论和编辑做出了贡献。</p>
<p><strong>&emsp;&emsp;资金</strong>：这个调查没有收到外部的资金。</p>
<p><strong>&emsp;&emsp;致谢</strong>：作者感谢Orange Labs, Lannion的Home and Family Communication (HFC)团队所有成员在项目期间给予的帮助和支持。同时，作者也非常感谢在论文发表的各个阶段帮助我们提高论文质量的每一个人。</p>
<p><strong>&emsp;&emsp;利益冲突</strong>:作者声明没有利益冲突。</p>
<p>附录 A</p>
<p>​                                                                        表A1 反应性和主动性行为</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">反应性</th>
<th align="center">主动性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">User</td>
<td align="center">Could you  help me?</td>
<td align="center"><strong>It seems like your computer</strong></td>
</tr>
<tr>
<td align="center">Robot</td>
<td align="center">Yes, What  is wrong?</td>
<td align="center"><strong>is  not responding, let me know if I can do anything?</strong></td>
</tr>
<tr>
<td align="center">User</td>
<td align="center">It seems like my computer is not  responding</td>
<td align="center">Could you  help me?</td>
</tr>
<tr>
<td align="center">Robot</td>
<td align="center">You should  end the process</td>
<td align="center">You should  end the process</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">by  pressing ALT+CTRL+DEL.</td>
<td align="center">by  pressing ALT+CTRL+DEL.</td>
</tr>
<tr>
<td align="center">User</td>
<td align="center">Won’t that  restart my computer?</td>
<td align="center">Won’t that  restart my computer?</td>
</tr>
<tr>
<td align="center">Robot</td>
<td align="center">Don’t  worry; it will just</td>
<td align="center">Don’t  worry; it will just</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">end the  process.</td>
<td align="center">end the  process.</td>
</tr>
<tr>
<td align="center">User</td>
<td align="center">Hmm, it’s  not doing anything.</td>
<td align="center">OK</td>
</tr>
<tr>
<td align="center">Robot</td>
<td align="center">Press  ALT+CTRL+DEL together.</td>
<td align="center">Press  ALT+CTRL+DEL together.</td>
</tr>
<tr>
<td align="center">User</td>
<td align="center">Ok and  now?</td>
<td align="center">Then you  should end the process.</td>
</tr>
<tr>
<td align="center">Robot</td>
<td align="center">Then you  should end the process.</td>
<td align="center"><strong>Do you have a back-up?</strong></td>
</tr>
<tr>
<td align="center">User</td>
<td align="center">But then I  lost my work?</td>
<td align="center">I’m not  sure.</td>
</tr>
<tr>
<td align="center">Robot</td>
<td align="center">Don’t  worry your computer makes a</td>
<td align="center">Don’t  worry your computer makes a</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">backup  every five minutes</td>
<td align="center">backup  every five minutes</td>
</tr>
<tr>
<td align="center">User</td>
<td align="center">How can I  find a backup?</td>
<td align="center">Where is  my backup?</td>
</tr>
<tr>
<td align="center">Robot</td>
<td align="center">You can  open your program</td>
<td align="center">To find  your program, you can</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">again and  select the file.</td>
<td align="center">open your program again and  select the file. Try it!</td>
</tr>
</tbody></table>
<h6 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h6><ol>
<li><p>Fong, T.; Nourbakhsh, I.; Dautenhahn, K. A survey of socially interactive robots. <em>Robot. Auton. Syst.</em> <strong>2003</strong>, <em>42</em>, 143–166.</p>
</li>
<li><p>Campa, R. The rise of social robots: a review of the recent literature. <em>J. Evol. Technol.</em> <strong>2016</strong>, <em>26</em>, 106–113.</p>
</li>
<li><p>Dautenhahn, K. Socially intelligent robots: dimensions of human–robot interaction. <em>Philos. Trans. R. Soc. B Biol. Sci.</em> <strong>2007</strong>, <em>362</em>, 679–704.</p>
</li>
<li><p>Breazeal, C.L. <em>Designing Sociable Robots</em>; MIT Press: Cambridge, MA, USA, 2004.</p>
</li>
<li><p>Dautenhahn, K. The art of designing socially intelligent agents: Science, fiction, and the human in the loop.</p>
</li>
</ol>
<p><em>Appl. Artif. Intell.</em> <strong>1998</strong>, <em>12</em>, 573–617.</p>
<ol start="6">
<li>Ferland, F.; Agrigoroaie, R.; Tapus, A. Assistive Humanoid Robots for the Elderly with Mild Cognitive</li>
</ol>
<p>Impairment. In <em>Humanoid Robotics: A Reference</em>; Springer: Berlin/Heidelberg, Germany, 2019; pp. 2377–2396.</p>
<ol start="7">
<li>Flandorfer, P. Population ageing and socially assistive robots for elderly persons: The importance of sociodemographic factors for user acceptance. <em>Int. J. Popul. Res.</em> <strong>2012</strong>, <em>2012</em>, 829835.</li>
<li>Meghdari, A.; Shariati, A.; Alemi, M.; Vossoughi, G.R.; Eydi, A.; Ahmadi, E.; Mozafari, B.; Amoozandeh Nobaveh, A.; Tahami, R. Arash: A social robot buddy to support children with cancer in a hospital environment. <em>Proc. Inst. Mech. Eng. Part H J. Eng. Med.</em> <strong>2018</strong>, <em>232</em>, 605–618.</li>
<li>Conti, D.; Di Nuovo, S.; Buono, S.; Di Nuovo, A. Robots in education and care of children with developmental disabilities: a study on acceptance by experienced and future professionals. <em>Int. J. Soc. Robot.</em> <strong>2017</strong>, <em>9</em>, 51–62. </li>
<li>Belpaeme, T.; Kennedy, J.; Ramachandran, A.; Scassellati, B.; Tanaka, F. Social robots for education: A review.</li>
</ol>
<p><em>Sci. Robot.</em> <strong>2018</strong>, <em>3</em>, eaat5954.</p>
<ol start="11">
<li><p>Siciliano, B.; Khatib, O. <em>Springer Handbook of Robotics</em>; Springer: Berlin/Heidelberg, Germany, 2016.</p>
</li>
<li><p>Bartneck, C.; Forlizzi, J. A design-centred framework for social human-robot interaction. In Proceedings of the RO-MAN 2004. 13th IEEE International Workshop on Robot and Human Interactive Communication (IEEE Catalog No. 04TH8759), Kurashiki, Japan, 22–22 September 2004; pp. 591–594.</p>
</li>
<li><p>Kemper, N. Effects of Proactive Behavior and Physical Interaction with a Social Robot. Master’s Thesis, University of Amsterdam, Amsterdam, The Netherlands, 2009.</p>
</li>
<li><p>Quigley, M.; Conley, K.; Gerkey, B.; Faust, J.; Foote, T.; Leibs, J.; Wheeler, R.; Ng, A.Y. ROS: An open-source Robot Operating System. In Proceedings of the ICRA Workshop on Open Source Software, Kobe, Japan, 17 May 2009; Volume 3, p. 5.</p>
</li>
<li><p>Bratman, M. <em>Intention, Plans, and Practical Reason</em>; Harvard University Press Cambridge: Cambridge, MA, USA, 1987; Volume 10.</p>
</li>
<li><p>Myers, K.; Yorke-Smith, N. Proactive behavior of a personal assistive agent. In Proceedings of the AAMAS Workshop on Metareasoning in Agent-Based Systems, Honolulu, HI, USA, 14 May 2007; pp. 31–45.</p>
</li>
<li><p>Dignum, F.; Kinny, D.; Sonenberg, L. From desires, obligations and norms to goals. <em>Cogn. Sci. Q.</em> <strong>2002</strong>, <em>2</em>, 407–430.</p>
</li>
<li><p>Myers, K.L.; Yorke-Smith, N. A cognitive framework for delegation to an assistive user agent. In Proceedings of the AAAI 2005 Fall Symposium on Mixed-Initiative Problem-Solving Assistants, Arlington, Virginia, 4–6 November 2005; pp. 94–99.</p>
</li>
<li><p>Russell, S.; Jordan, H.; O’Hare, G.M.; Collier, R.W. Agent factory: A framework for prototyping logic-based AOP languages. In Proceedings of the German Conference on Multiagent System Technologies, Berlin, Germany, 6–7 October 2011; pp. 125–136.</p>
</li>
<li><p>Winikoff, M. JACKTM intelligent agents: An industrial strength platform. In <em>Multi-Agent Programming</em>; Springer: Berlin/Heidelberg, Germany, 2005; pp. 175–193.</p>
</li>
<li><p>Jedrzejowicz, P.; Wierzbowska, I. JADE-Based a-team environment. In Proceedings of the International Conference on Computational Science, Reading, UK, 28–31 May 2006; pp. 719–726.</p>
</li>
<li><p>Braubach, L.; Pokahr, A. The jadex project: Simulation. In <em>Multiagent Systems and Applications</em>; Springer: Berlin/Heidelberg, Germany, 2013; pp. 107–128.</p>
</li>
<li><p>Rao, A.S. AgentSpeak (L): BDI agents speak out in a logical computable language. In Proceedings of the European Workshop on Modelling Autonomous Agents in a Multi-Agent World, Eindhoven, The Netherlands, 22–25 January 1996; pp. 42–55.</p>
</li>
<li><p>Bordini, R.H.; Hübner, J.F.; Wooldridge, M. <em>Programming Multi-Agent Systems in AgentSpeak Using Jason</em>; John Wiley &amp; Sons: Hoboken, NJ, USA, 2007; Volume 8.</p>
</li>
<li><p>25.Finzi, A.; Orlandini, A. Human-Robot Interaction Through Mixed-Initiative Planning for Rescue and Search Rovers. In <em>AI*IA 2005: Advances in Artificial Intelligence</em>; Bandini, S., Manzoni, S., Eds.; Springer: Berlin/Heidelberg, Germany, 2005; pp. 483–494.</p>
</li>
<li><p>Adams, J.A.; Rani, P.; Sarkar, N. Mixed initiative interaction and robotic systems. In Proceedings of the AAAI Workshop on Supervisory Control of Learning and Adaptive Systems, San Jose, CA, USA, 25–26 July 2004; pp. 6–13.</p>
</li>
<li><p>27.Acosta, M.; Kang, D.; Choi, H.J. Robot with emotion for triggering mixed-initiative interaction planning. In Proceedings of the 2008 IEEE 8th International Conference on Computer and Information Technology Workshops, Sydney, Australia, 8–11 July 2008; pp. 98–103.</p>
</li>
<li><p>28.Satake, S.; Kanda, T.; Glas, D.F.; Imai, M.; Ishiguro, H.; Hagita, N. How to approach humans?: Strategies for social robots to initiate interaction. In Proceedings of the 4th ACM/IEEE International Conference on Human Robot Interaction, La Jolla, CA, USA, 9–13 March 2009; pp. 109–116.</p>
</li>
<li><p>Shi, C.; Shimada, M.; Kanda, T.; Ishiguro, H.; Hagita, N. Spatial Formation Model for Initiating Conversation. In Proceedings of the 7th Annual Robotics: Science and Systems Conference, Los Angeles, CA, USA, 16–20 October 2011; doi:10.15607/RSS.2011.VII.039.</p>
</li>
<li><p>Garrell, A.; Villamizar, M.; Moreno-Noguer, F.; Sanfeliu, A. Proactive behavior of an autonomous mobile robot for human-assisted learning. In Proceedings of the 2013 IEEE RO-MAN, Gyeongju, Korea, 26–29 August 2013; pp. 107–113.</p>
</li>
<li><p>Araiza-Illan, D.; Pipe, T.; Eder, K. Model-Based Testing, Using Belief-Desire-Intentions Agents, of Control Code for Robots in Collaborative Human-Robot Interactions. <em>arXiv</em> <strong>2016</strong>, arXiv:1603.00656.</p>
</li>
<li><p>Gottifredi, S.; Tucat, M.; Corbatta, D.; García, A.J.; Simari, G.R. A BDI architecture for high level robot deliberation. In Proceedings of the XIV Congreso Argentino de Ciencias de la Computación, Chilecito, Argentina, 8–12 August 2008.</p>
</li>
<li><p>Duffy, B.R.; Dragone, M.; O’Hare, G.M. Social robot architecture: A framework for explicit social interaction. In Proceedings of the Toward Social Mechanisms of Android Science: A CogSci 2005 Workshop, Stresa, Italy, 25–26 July 2005.</p>
</li>
<li><p>Pereira, D.; Oliveira, E.; Moreira, N.; Sarmento, L. Towards an architecture for emotional BDI agents. In Proceedings of the 2005 Portuguese Conference on Artificial Intelligence, Covilha, Portugal, 5–8 December 2005; pp. 40–46.</p>
</li>
<li><p>Immersive Robotics. Available online: <a href="http://immersive-robotics.com/">http://immersive-robotics.com/</a> (accessed on 12 February 2017).</p>
</li>
</ol>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
</search>
